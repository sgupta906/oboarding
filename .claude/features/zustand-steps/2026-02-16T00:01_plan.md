# Plan: zustand-steps

## Metadata
- **Feature:** zustand-steps
- **Created:** 2026-02-16T00:01
- **Status:** plan-complete
- **Based On:** 2026-02-16T00:00_research.md

## Overview

Add a `StepsSlice` to the existing Zustand store and migrate the `useSteps` hook to read from it. This is slice 2 of 5 in the incremental Zustand migration. The migration fixes the `step-button-fix` race condition (optimistic updates and realtime callbacks writing to two separate `useState` variables) by consolidating all step state into a single store field per instanceId.

## Architecture

### Current Architecture

```
OnboardingHub
  |
  +-- useSteps(employeeInstance?.id ?? '')
  |     |-- useState<Step[]>(data)          <-- source 1 (optimistic writes here)
  |     |-- useState<boolean>(isLoading)
  |     |-- useState<Error|null>(error)
  |     |-- useEffect -> subscribeToSteps() <-- source 2 (realtime writes here)
  |     +-- useCallback(updateStatus)       <-- closes over `data` (stale closure)
  |
  +-- useSteps(selectedInstance?.id ?? '')
        |-- (same independent state)
```

Problem: Two sources of truth (`useState` for optimistic + subscription callback) cause the step-button-fix race.

### Target Architecture

```
Zustand Store
  |
  +-- InstancesSlice (existing, from slice 1)
  |     |-- instances: OnboardingInstance[]
  |     |-- instancesLoading, instancesError
  |     +-- _startInstancesSubscription()
  |
  +-- StepsSlice (NEW)
        |-- stepsByInstance: Record<string, Step[]>
        |-- stepsLoadingByInstance: Record<string, boolean>
        |-- stepsErrorByInstance: Record<string, Error | null>
        |-- _startStepsSubscription(instanceId) -> () => void
        +-- _updateStepStatus(instanceId, stepId, status) -> Promise<void>

OnboardingHub
  |
  +-- useSteps(employeeInstance?.id ?? '')
  |     |-- selectors read from store  <-- ONE source of truth
  |     |-- useEffect -> _startStepsSubscription()
  |     +-- updateStatus -> _updateStepStatus()  <-- reads via get(), no stale closure
  |
  +-- useSteps(selectedInstance?.id ?? '')
        |-- (reads different instanceId from SAME store)
```

### Data Flow: Step Status Update (after migration)

```
1. User clicks "Mark as Done"
   |
2. OnboardingHub.handleStatusChange(stepId, 'completed')
   |
3. updateStatus(stepId, 'completed')   <-- from useSteps hook
   |
4. store._updateStepStatus(instanceId, stepId, 'completed')
   |
   +---> [sync] set(optimistic): stepsByInstance[instanceId][stepId].status = 'completed'
   |         UI re-renders immediately with completed state
   |
   +---> [async] service.updateStepStatus(instanceId, stepId, 'completed')
   |         3 DB queries: update step, recalc progress, update instance
   |
   +---> [on error] set(rollback): stepsByInstance[instanceId] = snapshot
   |
5. [async, independent] Realtime event fires (300ms debounce)
   |
   +---> subscribeToSteps callback fires
   +---> set(): stepsByInstance[instanceId] = freshSteps
            If server committed: freshSteps matches optimistic -> no visual change
            If server not yet committed: brief revert, but single state source
            eliminates the two-source flicker from the old architecture
```

### Per-InstanceId Ref-Counting

Unlike the instances slice (one global subscription), steps require per-instanceId subscriptions because OnboardingHub calls `useSteps` with two different instanceIds simultaneously.

```
Module-level Maps (not in store state):
  stepsRefCounts: Map<string, number>    e.g. { 'inst-1': 2, 'inst-7': 1 }
  stepsCleanups:  Map<string, () => void>

_startStepsSubscription('inst-1'):
  1. stepsRefCounts['inst-1']++ (or set to 1)
  2. If count == 1: call subscribeToSteps('inst-1', callback), store cleanup
  3. Return cleanup fn that decrements count, unsubscribes at 0

Cleanup at refCount 0 for 'inst-1':
  1. Call stepsCleanups.get('inst-1')()
  2. Delete entries from both Maps
  3. Delete stepsByInstance['inst-1'], stepsLoadingByInstance['inst-1'],
     stepsErrorByInstance['inst-1'] from store state
```

## Tech Stack (no changes)

- Zustand 5.x (already installed from slice 1)
- React 18 + TypeScript
- Vitest + React Testing Library

## File Structure

### New Files

None. All changes are modifications to existing files.

### Modified Files

| File | Lines (current) | Change Description |
|------|----------------|-------------------|
| `src/store/useOnboardingStore.ts` | 105 | Add `StepsSlice` interface, update `OnboardingStore` type to `InstancesSlice & StepsSlice`, add per-instanceId ref-counting Maps, add `_startStepsSubscription` and `_updateStepStatus` actions, extend `resetStoreInternals()`, add step state fields to `create()` |
| `src/store/index.ts` | 9 | Add `StepsSlice` to type exports |
| `src/store/useOnboardingStore.test.ts` | 210 | Add `describe('StepsSlice')` block with ~12 new tests for step subscription lifecycle, ref-counting, optimistic updates, rollback, and reset |
| `src/hooks/useSteps.ts` | 76 | Rewrite internals: remove `useState`, import from store, `useEffect` calls `_startStepsSubscription`, `updateStatus` delegates to `_updateStepStatus`, preserve `UseStepsReturn` type |
| `src/hooks/useSteps.test.ts` | 94 | Update `beforeEach` to reset store internals, possibly adjust mock targets; existing assertions preserved |

### Files NOT Modified

| File | Reason |
|------|--------|
| `src/services/supabase/instanceService.ts` | Service layer consumed as-is |
| `src/components/OnboardingHub.tsx` | Uses `useSteps` via unchanged API contract |
| `src/views/EmployeeView.tsx` | Receives steps as props |
| `src/components/onboarding/*` | All receive data as props |
| All other hooks | Not migrated in this slice |

## Store Shape (detailed)

### StepsSlice Interface

```typescript
interface StepsSlice {
  /** Steps keyed by instanceId. Empty object initially. */
  stepsByInstance: Record<string, Step[]>;

  /** Per-instanceId loading state. Defaults to true when subscription starts. */
  stepsLoadingByInstance: Record<string, boolean>;

  /** Per-instanceId error state. */
  stepsErrorByInstance: Record<string, Error | null>;

  /**
   * Starts a ref-counted realtime subscription for the given instanceId.
   * Multiple calls with the same instanceId share one subscription.
   * Returns a cleanup function that decrements the ref count and
   * unsubscribes when no consumers remain for that instanceId.
   */
  _startStepsSubscription: (instanceId: string) => () => void;

  /**
   * Optimistically updates a step's status, calls the server,
   * and rolls back on error. Re-throws server errors.
   */
  _updateStepStatus: (instanceId: string, stepId: number, status: StepStatus) => Promise<void>;
}
```

### Combined Store Type

```typescript
type OnboardingStore = InstancesSlice & StepsSlice;
```

### Initial State

```typescript
{
  // InstancesSlice (existing)
  instances: [],
  instancesLoading: false,
  instancesError: null,
  _startInstancesSubscription: ...,

  // StepsSlice (new)
  stepsByInstance: {},
  stepsLoadingByInstance: {},
  stepsErrorByInstance: {},
  _startStepsSubscription: ...,
  _updateStepStatus: ...,
}
```

## Hook Migration: useSteps

### Before (current -- 76 lines)

- 3x `useState` (data, isLoading, error)
- `useEffect` with direct `subscribeToSteps()` call
- `useCallback` closing over `data` (stale closure risk)
- Returns `{ data, isLoading, error, updateStatus }`

### After (migrated -- ~30 lines)

```typescript
const EMPTY_STEPS: Step[] = [];

export function useSteps(instanceId: string): UseStepsReturn {
  const data = useOnboardingStore(s => s.stepsByInstance[instanceId] ?? EMPTY_STEPS);
  const isLoading = useOnboardingStore(s => s.stepsLoadingByInstance[instanceId] ?? false);
  const error = useOnboardingStore(s => s.stepsErrorByInstance[instanceId] ?? null);

  useEffect(() => {
    if (!instanceId) return;
    const cleanup = useOnboardingStore.getState()._startStepsSubscription(instanceId);
    return cleanup;
  }, [instanceId]);

  const updateStatus = useCallback(
    (stepId: number, status: StepStatus) =>
      useOnboardingStore.getState()._updateStepStatus(instanceId, stepId, status),
    [instanceId]
  );

  return {
    data: instanceId ? data : EMPTY_STEPS,
    isLoading: instanceId ? isLoading : false,
    error: instanceId ? error : null,
    updateStatus,
  };
}
```

Key improvements:
1. `EMPTY_STEPS` constant prevents new array reference on each render when no data exists
2. `updateStatus` no longer closes over `data` -- store action reads current state via `get()`
3. `useCallback` dependency is `[instanceId]` only (not `[data, instanceId]`), stable reference
4. Subscription lifecycle delegated to store's ref-counted action

## Testing Strategy

### Store Tests (new, in `useOnboardingStore.test.ts`)

Add a `describe('StepsSlice')` block with these tests:

| # | Test | What it verifies |
|---|------|-----------------|
| 1 | Initializes with empty steps state | `stepsByInstance`, `stepsLoadingByInstance`, `stepsErrorByInstance` are all `{}` |
| 2 | `_startStepsSubscription` calls `subscribeToSteps` | Service function called with correct instanceId and callback |
| 3 | `_startStepsSubscription` sets loading state for instanceId | `stepsLoadingByInstance[id]` becomes `true` |
| 4 | Subscription callback updates steps and clears loading | `stepsByInstance[id]` populated, `stepsLoadingByInstance[id]` false |
| 5 | Subscription error sets error and clears loading | `stepsErrorByInstance[id]` set, `stepsLoadingByInstance[id]` false |
| 6 | Second start for same instanceId is no-op | `subscribeToSteps` called once |
| 7 | Different instanceIds get separate subscriptions | `subscribeToSteps` called twice with different IDs |
| 8 | Cleanup decrements ref count per instanceId | First cleanup does not unsubscribe when 2 consumers exist |
| 9 | Last cleanup for instanceId unsubscribes and clears state | Unsubscribe called, `stepsByInstance[id]` removed |
| 10 | Double cleanup is safe (idempotent) | No crash, unsubscribe called once |
| 11 | `_updateStepStatus` applies optimistic update immediately | `stepsByInstance[id]` updated synchronously |
| 12 | `_updateStepStatus` rolls back on server error | `stepsByInstance[id]` reverted to snapshot |
| 13 | `resetStoreInternals` clears steps ref-counting and state | Maps cleared, `stepsByInstance` reset |

Estimated: ~13 new tests.

### Hook Tests (updated, in `useSteps.test.ts`)

Existing tests (3) verify the public API contract:
1. Returns `{ data, isLoading, error, updateStatus }`
2. `updateStatus` applies optimistic change immediately
3. `updateStatus` rolls back on server error

These tests mock `../services/supabase` at module level. After migration, `useSteps` reads from the store, which reads from services. The mock target stays the same (`../services/supabase`) because the store imports from the same path. However, `beforeEach` must be updated to:
- Call `resetStoreInternals()` to reset per-instanceId ref-counting
- Call `useOnboardingStore.setState(...)` to reset store state

The existing assertions should pass without changes because the return type API is preserved.

### Full Suite Verification

All 370 existing tests must continue passing. No test files outside of `useOnboardingStore.test.ts` and `useSteps.test.ts` should need changes.

## Implementation Notes

### Key Design Decisions

1. **Per-instanceId keyed state** -- Required because OnboardingHub calls `useSteps` with two different instanceIds simultaneously (employee's own + manager-selected employee). A flat array would not support this.

2. **Optimistic update in store, not hook** -- The store action reads current state via `get()`, avoiding stale closures. Both optimistic writes and realtime callbacks target the same state field, eliminating the two-source-of-truth race.

3. **Module-level Maps for ref-counting** -- Following the instances slice pattern but using `Map<string, number>` and `Map<string, () => void>` instead of scalars, to support per-instanceId granularity.

4. **`EMPTY_STEPS` constant** -- Module-level `const EMPTY_STEPS: Step[] = []` prevents selector `?? []` from creating a new array reference on every render.

5. **State cleanup on last unsubscribe** -- When the last consumer for an instanceId unmounts, the store deletes that instanceId's entries from all three state maps. This prevents memory leaks when managers browse many employees.

6. **`resetStoreInternals()` extended, not duplicated** -- One function resets both instances and steps ref-counting, keeping test setup simple.

### Patterns Followed

- Slice interface with prefixed state names (`stepsByInstance`, `stepsLoadingByInstance`, `stepsErrorByInstance`)
- Internal actions prefixed with `_` (`_startStepsSubscription`, `_updateStepStatus`)
- TSDoc comments on all exports
- Barrel exports via `src/store/index.ts`
- Supabase mocking via `vi.mock('../services/supabase')` in tests
- `set` + `get` pattern for store actions (not closures)

### Error Handling

- `_startStepsSubscription`: wraps `subscribeToSteps` in try/catch; on error, sets `stepsErrorByInstance[instanceId]` and clears loading
- `_updateStepStatus`: captures snapshot before optimistic update; on server error, rolls back to snapshot and re-throws the error so callers (OnboardingHub) can display toast

## Non-Goals

- **No changes to service layer** -- `subscribeToSteps` and `updateStepStatus` consumed as-is
- **No changes to UI components** -- OnboardingHub and all child components work via unchanged hook API
- **No `useShallow`** -- Not needed; selectors return either the same store reference or a stable `EMPTY_STEPS` constant
- **No devtools middleware** -- Deferred (consistent with slice 1 decision)
- **No migration of other hooks** -- Only `useSteps` is migrated in this slice
- **No Playwright E2E tests** -- Store tests + hook tests provide sufficient coverage for this internal refactor; the `/test` phase will run full suite verification
