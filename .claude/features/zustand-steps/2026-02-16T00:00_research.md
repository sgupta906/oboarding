# Research: zustand-steps

## Metadata
- **Feature:** zustand-steps
- **Created:** 2026-02-16T00:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context

This is slice 2 of 5 in the incremental Zustand migration. Slice 1 (`zustand-store`) is complete -- it installed Zustand, created the store with an `instances` slice, and migrated `useOnboardingInstances` + `useEmployeeOnboarding`. That slice is committed and all 370 tests pass.

**This slice adds a `steps` slice to the existing Zustand store and migrates `useSteps`.** It also fixes the `step-button-fix` bug: employee step buttons glitch/delay before registering because optimistic updates race between local `useState` and the realtime subscription callback.

### Where it fits in the project

| # | Feature | Status |
|---|---------|--------|
| 1 | `zustand-store` | **Complete** -- store + instances slice |
| 2 | `zustand-steps` | **THIS** -- steps slice |
| 3 | `zustand-users` | Queued |
| 4 | `zustand-activities` | Queued |
| 5 | `zustand-cleanup` | Queued |

### Dependencies on other features
- **Depends on:** `zustand-store` (slice 1) -- the Zustand store at `src/store/useOnboardingStore.ts` must exist with the `InstancesSlice` and the ref-counting pattern. **Complete.**

### What depends on this feature
- All subsequent slices (3-5) extend the store but do not depend on the steps slice specifically.
- Bug fix verification: `step-button-fix` is verified as fixed after this slice.

## Requirements

### Functional Requirements
- [x] FR1: Add a `StepsSlice` to the existing Zustand store that manages steps keyed by `instanceId` (source: STATUS.md roadmap)
- [x] FR2: The steps slice must subscribe to realtime step changes for a given `instanceId` via `subscribeToSteps()` from the service layer (source: code analysis)
- [x] FR3: The steps slice must provide an `updateStepStatus` action that applies optimistic updates immediately to the store, calls the server, and rolls back on error (source: `step-button-fix` bug, existing `useSteps` behavior)
- [x] FR4: Migrate `useSteps` hook to read from the store instead of maintaining its own `useState` + subscription (source: STATUS.md)
- [x] FR5: `useSteps` must preserve its exact return type API: `{ data: Step[], isLoading: boolean, error: Error | null, updateStatus: (stepId: number, status: StepStatus) => Promise<void> }` (source: code analysis)
- [x] FR6: `OnboardingHub` must continue working unchanged -- it calls `useSteps(employeeInstance?.id ?? '')` and `useSteps(selectedInstance?.id ?? '')` (source: code analysis of `OnboardingHub.tsx`)
- [x] FR7: Steps subscriptions must be per-instanceId, ref-counted: multiple calls to `useSteps(sameId)` share one subscription, and cleanup happens when the last consumer for that `instanceId` unmounts (source: architectural requirement)
- [x] FR8: When `instanceId` is empty string `''`, the hook must return empty data and not start a subscription (source: existing `useSteps` behavior, lines 33-37)
- [x] FR9: The `step-button-fix` bug must be resolved: optimistic updates should apply to the single store state, eliminating the race between local `useState` and the realtime callback (source: STATUS.md)
- [x] FR10: Existing hooks that are NOT migrated (`useSuggestions`, `useActivities`, `useTemplates`, etc.) must continue working unchanged (source: STATUS.md -- "Old hooks and new store coexist")

### Technical Requirements
- [x] TR1: Store file must be extended (not replaced) -- add `StepsSlice` alongside `InstancesSlice` using intersection types as documented in the existing store comments
- [x] TR2: All 370 existing tests must continue passing after migration
- [x] TR3: New unit tests must be added for the steps slice and migrated `useSteps` hook
- [x] TR4: TypeScript types must be correct -- `Step`, `StepStatus` from `src/types/index.ts`
- [x] TR5: Follow the same patterns established in slice 1: TSDoc comments, module-level ref-counting, barrel exports, Supabase service mocking in tests

### Constraints
- The app must be fully functional after this slice -- no half-broken state
- No changes to the Supabase service layer (`instanceService.ts`) -- the store consumes `subscribeToSteps` and `updateStepStatus` as-is
- The steps slice is keyed by `instanceId` (unlike the instances slice which is a flat array) because steps are always fetched per-instance
- Old hooks that are NOT being migrated in this slice must remain untouched

## Existing Code Analysis

### Project State
- Project exists: YES (16 features completed, including `zustand-store`)
- Test baseline: 370 tests across 28 test files, all passing
- Build: Clean (`npx tsc -b` + `npx vite build`)
- Zustand: Already installed (^5.x) from slice 1

### Current Data Flow (Steps)

```
Employee clicks "Mark as Done"
        |
        v
OnboardingHub.handleStatusChange(id, newStatus)
        |
        v
updateStatus(id, newStatus)   <-- from useSteps(employeeInstance?.id ?? '')
        |
        v
useSteps.updateStatus (useCallback):
  1. snapshot = data                     <-- captures current useState data
  2. setData(prev => optimistic update)  <-- local useState update
  3. await updateStepStatus(...)         <-- server call
  4. on error: setData(snapshot)         <-- rollback
        |
        v (independently)
subscribeToSteps realtime callback:
  fires setData(freshSteps)             <-- OVERWRITES the optimistic update
```

**The Race Condition (step-button-fix bug):**

When the user clicks "Mark as Done":
1. `updateStatus` optimistically sets the step to `completed` via `setData()` (local `useState`)
2. The server call `updateStepStatus()` updates the DB
3. The DB change triggers a Supabase Realtime event
4. `subscribeToSteps`'s debounced callback (300ms) re-fetches all steps from DB and calls `setData(freshSteps)`
5. If the realtime callback fires BEFORE the server call completes, the `freshSteps` may still show the old status (because the update hasn't committed yet), **reverting the optimistic update visually**
6. When the server call finally commits, another realtime event fires and the UI finally shows the correct state

This creates a visible "glitch" where the button appears to un-complete itself briefly.

### Target Data Flow (After migration)

```
Employee clicks "Mark as Done"
        |
        v
OnboardingHub.handleStatusChange(id, newStatus)
        |
        v
updateStatus(id, newStatus)   <-- from useSteps(instanceId), which reads store
        |
        v
store.updateStepStatus(instanceId, stepId, status):
  1. snapshot = get().stepsByInstance[instanceId]
  2. set() -> optimistic update to stepsByInstance[instanceId]
  3. await service.updateStepStatus(...)
  4. on error: set() -> rollback to snapshot
        |
        v (independently)
subscribeToSteps realtime callback:
  fires set({ stepsByInstance: { [instanceId]: freshSteps } })
  BUT: if the optimistic update already made the change,
       the store data is identical, so NO visual flicker
```

**Why the store fixes the race:**
- The optimistic update and the realtime callback both write to the SAME store state (`stepsByInstance[instanceId]`)
- When the realtime callback arrives with "the old state" (before the server committed), the store's optimistic state already shows `completed`, so the callback would revert it... UNLESS we guard against it
- **Key design decision:** The `updateStepStatus` store action should set a flag or use a version counter to prevent realtime callbacks from overwriting in-flight optimistic updates. Alternatively, since the realtime callback is debounced 300ms and the server call typically completes in <100ms, the race window is small. The simplest approach is: after the server call succeeds, do nothing (the store already has the correct state from the optimistic update). If the server call fails, rollback. The realtime callback will eventually reconcile with the server truth.

**Even simpler approach (recommended):** The realtime callback always overwrites with server truth. The optimistic update applies immediately. If the realtime arrives before the server commits, it briefly reverts -- but since both writes go to ONE state variable (not two independent `useState` calls), the revert and re-apply happen in the same render cycle, making the flicker invisible. The key improvement is eliminating the "two sources of truth" problem where `useState` in the hook and `useState` in the subscription fight.

**Clarification on the race fix:** In the current code, the race is between:
- `setData(optimistic)` in `updateStatus` (useCallback closure over `data`)
- `setData(serverTruth)` in the subscription callback

These are TWO different React state updates that batch unpredictably. In the store, both write to `store.stepsByInstance[instanceId]`, which is ONE piece of state. The optimistic write happens synchronously. The subscription callback writes asynchronously. React batches these correctly because they update the same reference path.

### Detailed Analysis: useSteps Hook (current)

**File:** `src/hooks/useSteps.ts` (76 lines)

**State managed:**
- `data: Step[]` -- local `useState`, updated by both subscription callback and optimistic updates
- `isLoading: boolean` -- local `useState`
- `error: Error | null` -- local `useState`

**Subscription lifecycle:**
- `useEffect` with `[instanceId]` dependency
- Calls `subscribeToSteps(instanceId, callback)` on mount
- Returns cleanup function (unsubscribe) on unmount or instanceId change
- Guards against empty `instanceId` (returns early, sets empty data)

**Optimistic update logic (updateStatus):**
- `useCallback` with `[data, instanceId]` dependencies
- Captures `snapshot = data` (current state at call time)
- Calls `setData(prev => prev.map(...))` for optimistic update
- Calls `await updateStepStatus(instanceId, stepId, status)` for server update
- On error: `setData(snapshot)` for rollback, re-throws error

**Return type:**
```typescript
interface UseStepsReturn {
  data: Step[];
  isLoading: boolean;
  error: Error | null;
  updateStatus: (stepId: number, status: StepStatus) => Promise<void>;
}
```

### Detailed Analysis: subscribeToSteps Service Function

**File:** `src/services/supabase/instanceService.ts` (lines 441-490)

**Signature:** `subscribeToSteps(instanceId: string, callback: (steps: Step[]) => void): () => void`

**Behavior:**
1. Defines `fetchSteps()` -- queries `instance_steps` table filtered by `instance_id`, ordered by `position ASC`, maps rows through `toStep()`
2. Creates `debouncedRefetch` with 300ms debounce
3. Calls `fetchSteps().then(callback)` immediately (NOT debounced)
4. Sets up Supabase channel `instance-steps-${instanceId}` listening on `instance_steps` table filtered by `instance_id=eq.${instanceId}`
5. On any `postgres_changes` event, calls `debouncedRefetch()`
6. Returns cleanup function that cancels debounce and removes channel

**Key detail:** This subscribes to `instance_steps` table only (not `onboarding_instances`). The instances slice already handles parent table changes.

### Detailed Analysis: updateStepStatus Service Function

**File:** `src/services/supabase/instanceService.ts` (lines 204-261)

**Signature:** `updateStepStatus(instanceId: string, stepId: number, status: StepStatus): Promise<void>`

**Behavior (3 queries):**
1. UPDATE `instance_steps` SET `status` WHERE `instance_id` AND `position = stepId`
2. SELECT all steps for instance to recalculate progress
3. UPDATE `onboarding_instances` SET `progress`, `status`, `completed_at` based on calculated progress

**Important:** This function updates the PARENT instance row (progress, status, completed_at). This means the instances subscription (`subscribeToOnboardingInstances`) will also fire when a step status changes, keeping the instances slice in sync.

### Detailed Analysis: OnboardingHub (consumer of useSteps)

**File:** `src/components/OnboardingHub.tsx` (343 lines)

**useSteps usage (2 calls):**

1. **Line 51-53:** `const { data: employeeStepsData, isLoading: employeeStepsLoading, updateStatus } = useSteps(employeeInstance?.id ?? '')`
   - Used for the employee's own onboarding steps
   - `employeeInstance` comes from `useEmployeeOnboarding(employeeEmail)` (already migrated to store)
   - When `employeeInstance` is null, passes `''` to `useSteps`
   - Destructures: `data` (as `employeeStepsData`), `isLoading` (as `employeeStepsLoading`), `updateStatus`

2. **Line 78:** `const { data: selectedInstanceSteps } = useSteps(selectedInstance?.id ?? '')`
   - Used when a manager views a specific employee's onboarding
   - `selectedInstance` is derived from `onboardingInstances` (from the store via `useManagerData`)
   - Only destructures `data` (as `selectedInstanceSteps`)

**How updateStatus is used:**
- `handleStatusChange` (line 101-125): `await updateStatus(id, newStatus)` with try/catch for toast error display
- `handleReportStuck` (line 159-175): `await updateStatus(activeModal.stepId, 'stuck')` with try/catch

**Key observation:** `updateStatus` is called from `OnboardingHub` event handlers, not directly from child components. Children (`EmployeeView`, `StepTimeline`, `StepCard`, `ActionBar`) receive `onStatusChange` as a prop callback. This means the migration only needs to change `useSteps` internals -- `OnboardingHub` calls `updateStatus` via the same hook return type.

### Detailed Analysis: Existing Zustand Store (slice 1 patterns)

**File:** `src/store/useOnboardingStore.ts` (105 lines)

**Patterns established:**
1. **Slice interface:** `InstancesSlice` with state + actions, prefixed with `instances` (e.g., `instancesLoading`, `instancesError`)
2. **Combined type:** `OnboardingStore = InstancesSlice` (to be extended with `& StepsSlice`)
3. **Module-level ref-counting:** `let refCount = 0; let cleanup: (() => void) | null = null;`
4. **`resetStoreInternals()`:** Exported for test isolation (resets refCount and cleanup)
5. **Subscription action:** `_startInstancesSubscription()` returns a cleanup function, guarded against double invocation via `let cleaned = false`
6. **Store creation:** `create<OnboardingStore>((set) => ({ ... }))`
7. **State reset on last cleanup:** `set({ instances: [], instancesLoading: false, instancesError: null })`

**Comment on line 9:** "Future slices (steps, users, activities) extend this store via intersection types: `OnboardingStore = InstancesSlice & StepsSlice & ...`"

### Detailed Analysis: Existing Store Tests (patterns)

**File:** `src/store/useOnboardingStore.test.ts` (210 lines)

**Patterns:**
1. Mocks `../services/supabase` at module level
2. Uses `useOnboardingStore.setState({...})` in `beforeEach` to reset state
3. Uses `resetStoreInternals()` in `beforeEach` to reset ref-counting
4. Tests state initialization, subscription start, callback data flow, error handling, ref-counting (second start is no-op, cleanup decrements, last cleanup unsubscribes + resets state, double cleanup is safe, re-subscribe after full cleanup works)
5. Uses `useOnboardingStore.getState()._startInstancesSubscription()` to invoke actions directly (no React rendering needed)

### Step Type (from src/types/index.ts)

```typescript
interface Step {
  id: number;        // Maps to DB `position` column
  title: string;
  description: string;
  role: string;      // 'All', 'Engineering', 'Sales', etc.
  owner: string;     // Department or team responsible
  expert: string;    // Subject Matter Expert name
  status: StepStatus;
  link: string;      // Reference link
}

type StepStatus = 'pending' | 'completed' | 'stuck';
```

## Store Design (Steps Slice)

### State Shape

Unlike the instances slice (flat array), steps must be keyed by `instanceId` because:
- Multiple components may subscribe to steps for DIFFERENT instances simultaneously (employee's own instance + manager viewing another employee's instance)
- Each `instanceId` has its own subscription and its own set of steps

```typescript
interface StepsSlice {
  /** Steps keyed by instanceId */
  stepsByInstance: Record<string, Step[]>;
  /** Loading state keyed by instanceId */
  stepsLoadingByInstance: Record<string, boolean>;
  /** Error state keyed by instanceId */
  stepsErrorByInstance: Record<string, Error | null>;

  /** Starts a ref-counted subscription for a specific instanceId. Returns cleanup. */
  _startStepsSubscription: (instanceId: string) => () => void;

  /** Optimistically updates a step's status, calls server, rolls back on error. */
  _updateStepStatus: (instanceId: string, stepId: number, status: StepStatus) => Promise<void>;
}
```

### Ref-Counting Per InstanceId

Unlike the instances slice (one global ref count), steps need per-instanceId ref-counting:

```typescript
// Module-level
const stepsRefCounts: Map<string, number> = new Map();
const stepsCleanups: Map<string, () => void> = new Map();
```

When `_startStepsSubscription('inst-1')` is called:
1. Increment `stepsRefCounts.get('inst-1')` (or set to 1 if absent)
2. If count is 1, call `subscribeToSteps('inst-1', callback)` and store cleanup in `stepsCleanups`
3. Return a cleanup function that decrements the count and unsubscribes when count hits 0

### Optimistic Update Pattern

```typescript
_updateStepStatus: async (instanceId, stepId, status) => {
  const snapshot = get().stepsByInstance[instanceId] ?? [];

  // Optimistic update
  set(state => ({
    stepsByInstance: {
      ...state.stepsByInstance,
      [instanceId]: (state.stepsByInstance[instanceId] ?? []).map(s =>
        s.id === stepId ? { ...s, status } : s
      ),
    },
  }));

  try {
    await updateStepStatus(instanceId, stepId, status);
  } catch (err) {
    // Rollback
    set(state => ({
      stepsByInstance: {
        ...state.stepsByInstance,
        [instanceId]: snapshot,
      },
    }));
    throw err;
  }
}
```

### Hook Migration

```typescript
// useSteps (after migration)
export function useSteps(instanceId: string): UseStepsReturn {
  const data = useOnboardingStore(s => s.stepsByInstance[instanceId] ?? []);
  const isLoading = useOnboardingStore(s => s.stepsLoadingByInstance[instanceId] ?? true);
  const error = useOnboardingStore(s => s.stepsErrorByInstance[instanceId] ?? null);

  useEffect(() => {
    if (!instanceId) return;
    const unsub = useOnboardingStore.getState()._startStepsSubscription(instanceId);
    return unsub;
  }, [instanceId]);

  const updateStatus = useCallback(
    (stepId: number, status: StepStatus) =>
      useOnboardingStore.getState()._updateStepStatus(instanceId, stepId, status),
    [instanceId]
  );

  return {
    data: instanceId ? data : [],
    isLoading: instanceId ? isLoading : false,
    error: instanceId ? error : null,
    updateStatus,
  };
}
```

**Key improvements over current implementation:**
1. `updateStatus` no longer closes over `data` -- it calls a store action that reads current state via `get()`. This eliminates stale closure bugs.
2. The subscription callback and optimistic update both write to the same store field (`stepsByInstance[instanceId]`), eliminating the two-source-of-truth race.
3. The `useCallback` dependency is just `[instanceId]`, not `[data, instanceId]`, so the function reference is stable and doesn't cause re-renders in consumers.

## Code to Reuse

| File | What can be reused |
|------|-------------------|
| `src/store/useOnboardingStore.ts` | Extend with `StepsSlice` -- existing `InstancesSlice` + `create()` + `resetStoreInternals()` pattern |
| `src/store/index.ts` | Add `StepsSlice` to barrel exports |
| `src/services/supabase/instanceService.ts` | `subscribeToSteps()` and `updateStepStatus()` consumed as-is |
| `src/store/useOnboardingStore.test.ts` | Test patterns: mock setup, `setState()` + `resetStoreInternals()` in `beforeEach` |
| `src/hooks/useSteps.test.ts` | Existing tests verify the public API contract -- must continue passing (may need mock adjustments) |

## Code to Modify

| File | What Changes | Current Lines |
|------|-------------|--------------|
| `src/store/useOnboardingStore.ts` | Add `StepsSlice` interface, update `OnboardingStore` type, add per-instanceId ref-counting, add `_startStepsSubscription` and `_updateStepStatus` actions, extend `resetStoreInternals()` | 105 |
| `src/store/index.ts` | Export `StepsSlice` type | 9 |
| `src/hooks/useSteps.ts` | Rewrite internals to read from store, preserve return type API | 76 |
| `src/hooks/useSteps.test.ts` | Update mocks if needed (now mocking store services rather than direct service import) | 94 |
| `src/store/useOnboardingStore.test.ts` | Add tests for steps slice alongside existing instances tests | 210 |

## Code NOT to Modify

| File | Reason |
|------|--------|
| `src/services/supabase/instanceService.ts` | Service layer stays as-is |
| `src/components/OnboardingHub.tsx` | Uses `useSteps` via same API contract |
| `src/views/EmployeeView.tsx` | Receives steps as props, no hook dependency |
| `src/components/onboarding/StepTimeline.tsx` | Receives steps as props, no hook dependency |
| `src/components/onboarding/StepCard.tsx` | Receives step as props, no hook dependency |
| `src/components/onboarding/ActionBar.tsx` | Receives callbacks as props, no hook dependency |
| `src/hooks/useManagerData.ts` | Does not use `useSteps`, unaffected |
| `src/hooks/useOnboardingInstances.ts` | Already migrated in slice 1, unaffected |
| `src/hooks/useEmployeeOnboarding.ts` | Already migrated in slice 1, unaffected |
| All other hooks | Not migrated in this slice |

## Patterns to Follow

1. **Slice interface with prefixed state names:** `InstancesSlice` uses `instances`, `instancesLoading`, `instancesError`. Steps should use `stepsByInstance`, `stepsLoadingByInstance`, `stepsErrorByInstance`.

2. **Module-level ref-counting:** Use `Map<string, number>` for per-instanceId ref counts (extending the scalar pattern from instances slice).

3. **`resetStoreInternals()` must reset steps state too:** Extend the existing function to clear steps ref counts and cleanups.

4. **Action naming:** Internal actions prefixed with `_` (e.g., `_startStepsSubscription`, `_updateStepStatus`).

5. **Hook as thin wrapper:** The migrated `useSteps` should be a thin wrapper over the store, using selectors to read state and `useEffect` for subscription lifecycle.

6. **Supabase mocking pattern:** Tests mock `../services/supabase` at module level with `vi.mock()`.

7. **TSDoc comments on all exports.**

8. **Barrel exports via `src/store/index.ts` and `src/hooks/index.ts`.**

## Constraints

### Performance
- Steps data is per-instance (typically 5-20 steps). Map lookups by instanceId are O(1). No performance concerns.
- Optimistic updates are synchronous `set()` calls -- instant UI feedback.
- The 300ms debounce on realtime re-fetches is preserved (it's in the service layer).
- Selectors like `s => s.stepsByInstance[instanceId] ?? []` create a new array reference when `instanceId` has no entry, but this is an edge case (only on initial mount before data arrives).

### Platform
- React 18 + Zustand 5.x: fully compatible, same as slice 1.
- No SSR concerns (client-only SPA).

### Dependencies
- `subscribeToSteps` and `updateStepStatus` from `instanceService.ts` -- consumed as-is.
- Zustand already installed from slice 1.

## Risk Assessment

### Technical Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Per-instanceId ref-counting is more complex than scalar ref-counting | Medium | Medium | Use a `Map<string, number>` instead of a scalar. Clear and well-tested. Follow existing pattern closely. |
| Optimistic update + realtime callback interaction: the realtime callback might overwrite the optimistic state if it arrives with stale data | Medium | Low | The 300ms debounce means the realtime re-fetch typically happens AFTER the server commit. Even if it arrives early, both writes go to the same store field, so React batches them correctly. Worst case: brief visual revert for ~300ms, same as current behavior but without the "two source" flicker. |
| `OnboardingHub` calls `useSteps` twice (for employee + selected instance). Both must work independently with per-instanceId state. | Medium | Low | The per-instanceId keyed state (`stepsByInstance[id]`) naturally supports this. Each call gets its own subscription and state slice. |
| Test mock changes break existing `useSteps.test.ts` | Low | Medium | The existing tests mock `../services/supabase` (subscribeToSteps, updateStepStatus). After migration, `useSteps` reads from the store which reads from services. Tests may need to mock services at the store level or mock the store directly. Keep the same mock target (`../services/supabase`) for consistency. |
| `updateStatus` stale closure: the current hook's `useCallback` closes over `data` and `instanceId`. Moving to store eliminates the `data` dependency but the function must still use the correct `instanceId`. | Low | Low | The new `updateStatus` calls `store.getState()._updateStepStatus(instanceId, ...)` -- the store action reads current state via `get()`, not a closure. The `instanceId` is stable from the hook parameter. |

### Complexity
- **Level:** Medium
- **Rationale:** The core logic (add slice, migrate hook) follows the exact pattern from slice 1. The added complexity is (a) per-instanceId ref-counting instead of scalar, (b) optimistic update action in the store, and (c) ensuring the two `useSteps` calls in `OnboardingHub` work independently. All of these have clear implementation paths.

## Open Questions

- [x] Q1: Should steps state be a flat array or keyed by instanceId?
  - Resolution: Keyed by instanceId (`Record<string, Step[]>`). OnboardingHub calls `useSteps` with two different instanceIds simultaneously. Keyed state supports this naturally.

- [x] Q2: Should the optimistic update action be in the store or stay in the hook?
  - Resolution: In the store as `_updateStepStatus`. This ensures the optimistic update writes to the same state that the subscription callback writes to, eliminating the race condition. The hook's `updateStatus` becomes a thin wrapper that calls the store action.

- [x] Q3: How to handle the realtime callback potentially overwriting optimistic state?
  - Resolution: Let it overwrite. The realtime callback brings server truth. The optimistic update was already applied, so if the server committed, the realtime data matches. If the server hasn't committed yet, the 300ms debounce usually means it will by the time the re-fetch completes. In the rare case of a revert, it's brief and the next realtime event corrects it. This is a significant improvement over the current two-source-of-truth race.

- [x] Q4: Should `resetStoreInternals()` be extended or should we add a separate `resetStepsInternals()`?
  - Resolution: Extend `resetStoreInternals()` to also reset steps ref-counting and cleanups. This keeps a single test cleanup function consistent with the existing pattern.

- [x] Q5: What happens when `instanceId` changes in `useSteps` (e.g., manager selects different employee)?
  - Resolution: The `useEffect` with `[instanceId]` dependency handles this: cleanup fires for the old instanceId (decrementing its ref count), then starts a new subscription for the new instanceId. This is identical to the current behavior, just routed through the store.

- [x] Q6: Do we need `useShallow` for the steps selector?
  - Resolution: No. `s => s.stepsByInstance[instanceId] ?? []` returns either the same array reference (from the store) or a new empty array. The `?? []` creates a new empty array on each render when no data exists, but this is only during the brief loading phase. We can stabilize this with a module-level `EMPTY_STEPS: Step[] = []` constant.

## Recommended Approach

### Implementation Strategy

**Extend the existing store with a `StepsSlice`, then rewrite `useSteps` as a thin wrapper, following the exact patterns from slice 1.**

### Order of Work

1. **Extend `src/store/useOnboardingStore.ts`:**
   - Add `StepsSlice` interface
   - Update `OnboardingStore = InstancesSlice & StepsSlice`
   - Add per-instanceId ref-counting (`Map<string, number>` and `Map<string, () => void>`)
   - Add `_startStepsSubscription(instanceId)` action
   - Add `_updateStepStatus(instanceId, stepId, status)` action
   - Extend `resetStoreInternals()` to clear steps maps
   - Add new state fields to `create()`: `stepsByInstance: {}`, `stepsLoadingByInstance: {}`, `stepsErrorByInstance: {}`

2. **Update `src/store/index.ts`:**
   - Export `StepsSlice` type

3. **Add store tests for steps slice in `src/store/useOnboardingStore.test.ts`:**
   - Initial state (empty maps)
   - `_startStepsSubscription` starts subscription for instanceId
   - Subscription callback updates `stepsByInstance[instanceId]` and clears loading
   - Error handling
   - Per-instanceId ref-counting: second start for same ID is no-op
   - Different instanceIds get separate subscriptions
   - Cleanup decrements ref count per instanceId
   - Last cleanup for instanceId unsubscribes and clears that entry
   - `_updateStepStatus` optimistic update applies immediately
   - `_updateStepStatus` rollback on server error
   - `resetStoreInternals` clears steps state

4. **Rewrite `src/hooks/useSteps.ts`:**
   - Import from store instead of local useState
   - `useEffect` calls `_startStepsSubscription(instanceId)` with cleanup
   - `updateStatus` calls `_updateStepStatus` on the store
   - Return type unchanged: `{ data, isLoading, error, updateStatus }`

5. **Update `src/hooks/useSteps.test.ts`:**
   - Adjust mocks if needed (the hook now reads from the store, which reads from services)
   - Existing test assertions should still pass since the return type API is preserved

6. **Run full test suite** -- all 370+ tests must pass

### What to Defer

- **Users slice** -- slice 3 (`zustand-users`)
- **Activities/suggestions slices** -- slice 4 (`zustand-activities`)
- **Removing old hooks** -- slice 5 (`zustand-cleanup`)
- **Devtools middleware** -- deferred from slice 1, still deferred
- **Changes to OnboardingHub component** -- works via unchanged hook API
- **Changes to service layer** -- consumed as-is

## Next Step

**All questions resolved.**
Run `/plan zustand-steps` to create the implementation plan.
