# Research: edit-new-hires

## Metadata
- **Feature:** edit-new-hires
- **Created:** 2026-02-17T20:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context

Managers need to edit existing onboarding instances (new hires) after creation. Currently, the New Hires panel is read-only with only a delete action. This feature adds the ability to:
1. Change a hire's role and department
2. Reassign or add a different template (replacing the instance's steps with new template steps)
3. Templates are assigned one at a time -- an employee might do "General Onboarding" first, then "Engineering Onboarding" later

### Where it fits
- The New Hires tab in the Manager Dashboard currently shows a table with Name, Email, Department, Role, Status, Progress, Start Date, and a Delete action
- No edit functionality exists -- there is no edit button, no edit modal, and no service function for "reassign template"
- The `updateOnboardingInstance` service function already exists and supports updating role, department, template_id, and steps

### Dependencies on other features
- Zustand migration is complete (all 5 slices done)
- Instance CRUD operations are fully implemented in instanceService.ts
- Template listing is already available via useTemplates hook
- Roles listing is already available via useRoles hook

## Requirements

### Functional Requirements
- FR1: Add an "Edit" button to each row in the NewHiresPanel table (source: user request)
- FR2: Create an EditHireModal that pre-fills with the existing hire's data (source: user request)
- FR3: Allow changing the hire's role (source: user request)
- FR4: Allow changing the hire's department (source: user request)
- FR5: Allow reassigning a different template to the hire (source: user request)
- FR6: When a new template is assigned, replace the instance's steps with the new template's steps (source: user request)
- FR7: Preserve step completion status when possible -- if the new template has steps with matching titles, keep the existing status (source: existing pattern in syncTemplateStepsToInstances)
- FR8: Recalculate progress after template reassignment (source: existing pattern)
- FR9: Allow editing employee name and email (source: reasonable extension)
- FR10: Show a template preview when selecting a new template (source: existing pattern in CreateOnboardingModal)
- FR11: Log an activity entry when a hire is edited (source: existing pattern)
- FR12: Show success toast after successful edit (source: existing pattern)
- FR13: Show warning when reassigning a template that the employee has partially completed steps (source: UX safety)

### Technical Requirements
- TR1: Use the existing `updateOnboardingInstance` service function for persistence
- TR2: Update the Zustand store optimistically after edit (or at minimum after server confirms)
- TR3: Follow the existing modal pattern (ModalWrapper, form validation, field errors, dark mode support)
- TR4: Follow the existing UserModal create/edit dual-mode pattern OR create a dedicated EditHireModal
- TR5: Support dark mode (all dark: Tailwind variants)
- TR6: Full a11y support (aria labels, role attributes, focus management)
- TR7: Add unit tests for the new modal component
- TR8: Add unit tests for the edit handler logic

### Constraints
- The `instance_steps` table has a unique constraint on `(instance_id, position)` -- steps must be deleted and re-inserted when changing templates (already handled by `updateOnboardingInstance`)
- The `onboarding_instances.template_id` is a nullable FK to `templates(id)` -- can be updated to point to a new template
- Steps are COPIED from the template at creation time -- they are NOT live references. Changing the template_id and steps is effectively a "reassign"

## Existing Code Analysis

### Project State
- Project exists: YES
- All prerequisite features complete: YES

### Key Files to Understand

#### Data Model
- `onboarding_instances` table: has `template_id` (UUID FK, nullable), `role`, `department`, `employee_name`, `employee_email`, `status`, `progress`
- `instance_steps` table: child table with `instance_id` FK, `position`, `title`, `description`, `role`, `owner`, `expert`, `status`, `link`
- The `OnboardingInstance` TypeScript type includes `templateId: string`, `role: string`, `department: string`, `steps: Step[]`, `progress: number`

#### How Templates Get Assigned to Instances
1. Manager fills out `CreateOnboardingModal` (name, email, role, department, templateId, startDate)
2. `useCreateOnboarding.mutate()` calls `createOnboardingRunFromTemplate()`
3. `createOnboardingRunFromTemplate()`:
   - Validates input
   - Fetches the template via `getTemplate(templateId)`
   - Creates instance with `template.steps` copied as initial steps
   - All steps start with `status: 'pending'`
4. Steps are COPIED -- they live in `instance_steps` table, independent of `template_steps`

#### What Happens When a Template Is Updated
- `syncTemplateStepsToInstances()` in `templateService.ts` does title-based matching:
  - Steps with matching titles: preserve `status` from instance, update all other fields from template
  - Steps without title match: added as new with `status: 'pending'`
  - Orphan instance steps (title not in template): dropped
  - Progress is recalculated
- This SAME logic should be used when reassigning templates

#### Instance Update Service
`updateOnboardingInstance(id, updates)` in `instanceService.ts`:
- Accepts `Partial<OnboardingInstance>` updates
- Updates instance row fields (role, department, template_id, etc.)
- If `steps` is included: deletes ALL old instance_steps, inserts new ones
- This is exactly what we need for template reassignment

### Code to Reuse
- `src/services/supabase/instanceService.ts`: `updateOnboardingInstance()` -- handles instance + steps update
- `src/services/supabase/templateService.ts`: `getTemplate()` -- fetch template with steps for preview and reassignment
- `src/components/modals/CreateOnboardingModal.tsx`: Pattern for template selection, preview, form validation
- `src/components/modals/UserModal.tsx`: Pattern for create/edit dual-mode modal with pre-fill
- `src/components/ui/ModalWrapper.tsx`: Base modal component
- `src/hooks/useTemplates.ts`: Template listing hook
- `src/hooks/useRoles.ts`: Role listing hook
- `src/store/useOnboardingStore.ts`: `_addInstance` pattern for optimistic updates (need to add `_updateInstance` action)

### Code to Modify
- `src/components/manager/NewHiresPanel.tsx`: Add Edit button to each row, wire up edit modal state
- `src/store/useOnboardingStore.ts`: Add `_updateInstance` action to InstancesSlice
- `src/hooks/useOnboardingInstances.ts`: Expose `updateInstance` from the hook return
- `src/components/modals/index.ts`: Export the new EditHireModal
- `src/types/index.ts`: May need to add `EditHireFormData` interface (or reuse `OnboardingFormData`)

### Code to Create
- `src/components/modals/EditHireModal.tsx`: New modal component for editing hires
- `src/components/modals/EditHireModal.test.tsx`: Unit tests

### Patterns to Follow
1. **Modal pattern**: Use ModalWrapper, same button layout (Cancel + Submit), same validation approach (field errors, hasAttemptedSubmit)
2. **Dark mode**: All interactive elements need `dark:` Tailwind variants
3. **Accessibility**: aria-labels on all interactive elements, role="alert" for errors
4. **Optimistic updates**: Update Zustand store immediately, rollback on server error
5. **Activity logging**: Fire-and-forget logActivity after successful operations
6. **Toast notifications**: Use `useToast` for success/error feedback
7. **Form reset on open**: useEffect to reset form when `isOpen` changes to prevent stale data (Bug #28 pattern)

## Constraints

### Performance
- No specific targets. Standard form submission + Supabase update. The `updateOnboardingInstance` does at most 3 queries (update instance, delete old steps, insert new steps).

### Platform
- Must support both light and dark modes
- Desktop-only (no mobile responsive requirements per Bug #29 resolution)

### Dependencies
- `@supabase/supabase-js` for data operations
- `lucide-react` for icons (Pencil/Edit icon for the edit button)
- No new package dependencies needed

### Database
- `instance_steps` unique constraint: `(instance_id, position)` -- must delete-then-insert when changing steps
- `onboarding_instances.template_id` FK to `templates(id) ON DELETE SET NULL` -- safe to change

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Step status loss when reassigning template | High | Medium | Use title-based matching (same as syncTemplateStepsToInstances) to preserve status of steps with matching titles |
| Race condition with Realtime subscription | Low | Low | Realtime subscription will re-fetch after server update, overwriting any stale optimistic state |
| Employee actively working on steps during edit | Medium | Low | Show warning in modal if hire has completed steps; the edit is manager-only so employees cannot interfere |
| Template deleted between opening modal and submitting | Low | Low | Validate template still exists before submitting; show error if not found |

### Complexity
- **Level:** Medium
- **Rationale:** The backend pieces already exist (updateOnboardingInstance, getTemplate). The main work is UI: creating the EditHireModal, wiring it into NewHiresPanel, and adding the _updateInstance store action. The template reassignment logic (title-based step merging) needs careful implementation to preserve step completion status.

## Open Questions

- [x] Q1: Should we create a separate EditHireModal or extend CreateOnboardingModal with a mode prop (like UserModal)?
  - Resolution: Create a SEPARATE EditHireModal. The CreateOnboardingModal and EditHireModal have different enough UX requirements (edit shows current state, has a template change warning, shows progress info) that a dual-mode modal would be overly complex. The UserModal dual-mode pattern works because create and edit have nearly identical fields. For hires, edit needs to show current progress, step completion warnings, and has a fundamentally different flow (editing existing data vs creating new).

- [x] Q2: What happens to existing steps when a template is reassigned?
  - Resolution: Use the same title-based matching logic as `syncTemplateStepsToInstances()`. Steps with matching titles keep their completion status. Steps not in the new template are dropped. New steps from the template start as 'pending'. Progress is recalculated.

- [x] Q3: Should the modal allow editing the employee's name and email?
  - Resolution: Yes. Name and email are simple text field updates. The service already supports updating `employee_name` and `employee_email`. This covers the common case of typo correction.

- [x] Q4: Is there a template_id on the instance, or are steps copied at creation time?
  - Resolution: BOTH. The `onboarding_instances` table has a `template_id` FK column that records which template was used. Steps are ALSO copied into `instance_steps` at creation time. When reassigning, we update both the `template_id` and replace the `instance_steps`.

- [x] Q5: How does the instance-to-template relationship work in the DB?
  - Resolution: `onboarding_instances.template_id` is a nullable UUID FK to `templates(id) ON DELETE SET NULL`. There's also an `instance_template_refs` junction table (for multi-template support, currently unused in the main flow). Steps are stored independently in `instance_steps` -- they are copies, not live references.

- [x] Q6: What UI exists for managing hires currently?
  - Resolution: The NewHiresPanel shows a read-only table with Name, Email, Department, Role, Status, Progress, Start Date, and an Actions column with only a Delete button (Trash2 icon). No edit UI exists.

## Recommended Approach

### Implementation Strategy

**Approach: Dedicated EditHireModal + NewHiresPanel wiring + Store action**

1. **Add `_updateInstance` action to Zustand store** -- optimistic update pattern matching `_editUser`
2. **Expose `updateInstance` from `useOnboardingInstances` hook** -- matching the `removeInstance` pattern
3. **Create `EditHireModal` component** -- pre-filled form with template reassignment support
4. **Add Edit button to NewHiresPanel** -- Pencil icon next to existing Trash2 icon
5. **Wire EditHireModal into NewHiresPanel** -- state management for which instance is being edited

### Key Design Decisions

1. **Template reassignment flow**: When the manager selects a different template in the edit modal, show a warning: "Changing the template will reset step progress. Steps with matching titles will keep their completion status." Then, on submit, fetch the new template's steps, merge with existing instance steps using title-based matching, and call `updateOnboardingInstance` with the merged steps + recalculated progress.

2. **Store update pattern**: Add `_updateInstance` to InstancesSlice. It should: (a) optimistically update the instance in the local array, (b) call `updateOnboardingInstance` on the server, (c) rollback on error.

3. **Form pre-fill**: When the edit modal opens, pre-fill all fields from the selected OnboardingInstance. Template dropdown shows current template_id as selected. If template is changed, show template preview + warning.

### Order of Work
1. Add `_updateInstance` action to Zustand store (`useOnboardingStore.ts`)
2. Expose `updateInstance` from `useOnboardingInstances` hook
3. Create `EditHireModal` component with form, validation, template preview, and change warning
4. Add Edit button to `NewHiresPanel` table rows
5. Wire modal state and handlers in `NewHiresPanel`
6. Add activity logging for edits
7. Write unit tests for `EditHireModal`
8. Write unit tests for store `_updateInstance` action
9. Update barrel exports (`modals/index.ts`)

### What to Defer
- Multi-template assignment (assigning multiple templates to one instance simultaneously) -- the user said "templates are assigned one at a time", so single template reassignment is sufficient
- `instance_template_refs` junction table usage -- this exists in the schema but is unused in the current flow; can be populated later for audit trail
- Editing status (active/completed/on_hold) -- keep this as a separate feature if needed; the current edit focuses on role, department, and template

## Next Step

**All questions resolved. Ready for planning.**

Run `/plan edit-new-hires` to create implementation plan.
