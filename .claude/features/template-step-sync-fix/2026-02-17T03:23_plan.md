# Plan: template-step-sync-fix

## Metadata
- **Feature:** template-step-sync-fix
- **Created:** 2026-02-17T03:23 UTC
- **Status:** plan-complete
- **Based On:** `.claude/features/template-step-sync-fix/2026-02-17T03:23_research.md`

---

## Architecture Overview

### Problem

The current `syncTemplateStepsToInstances()` function (templateService.ts:170-219) only adds NEW steps by comparing position-based `step.id` values. Since step IDs are always `{1, 2, 3, ...N}` regardless of content (reassigned as `index + 1` on every save), a reorder/rename/removal produces the exact same ID set. The function sees no difference, skips the instance entirely, and no changes propagate.

### Solution: Title-Based Reconciliation

Replace the broken ID-set-difference logic with a title-based merge algorithm that walks template steps in order and matches against a title map of existing instance steps.

```
BEFORE (broken):                      AFTER (fixed):

  templateStepIds = {1,2,3,4}           For each template step:
  instanceStepIds = {1,2,3,4}            match = instanceMap[step.title]
  stepsToAdd = {} -- empty!              if match: preserve status, update all else
  --> SKIP (no sync)                     if no match: add as pending
                                        Orphan instance steps: dropped
                                        Recalculate progress
```

### Reconciliation Algorithm (ASCII Diagram)

```
Template Steps (new order)          Instance Steps (existing)
========================           =========================
1. "Meet team lead"                1. "Set up laptop"       [completed]
2. "Set up laptop"                 2. "Meet team lead"      [completed]
3. "Security training"  (NEW)      3. "Install tools"       [pending]
                                   4. "Read handbook"       [stuck]

                     Build Map<title, step>
                     from instance steps:
                     ┌─────────────────────────────────┐
                     │ "Set up laptop"  -> {completed}  │
                     │ "Meet team lead" -> {completed}  │
                     │ "Install tools"  -> {pending}    │
                     │ "Read handbook"  -> {stuck}       │
                     └─────────────────────────────────┘

Walk template steps in order:
┌───┬─────────────────────┬──────────┬──────────────────────┐
│ # │ Template Step        │ Match?   │ Result               │
├───┼─────────────────────┼──────────┼──────────────────────┤
│ 1 │ "Meet team lead"    │ YES      │ id:1, status:completed│
│ 2 │ "Set up laptop"     │ YES      │ id:2, status:completed│
│ 3 │ "Security training" │ NO (new) │ id:3, status:pending  │
└───┴─────────────────────┴──────────┴──────────────────────┘

Orphans (in instance but NOT in template):
  - "Install tools"  -> DROPPED (removed from template)
  - "Read handbook"  -> DROPPED (removed from template)

Progress: 2/3 completed = 67%
```

### What Changes Per Field

```
┌─────────────┬──────────────┬────────────────────────────────┐
│ Step Field  │ Source       │ Notes                          │
├─────────────┼──────────────┼────────────────────────────────┤
│ id          │ Template     │ New position (index + 1)       │
│ title       │ Template     │ Updated from template          │
│ description │ Template     │ Updated from template          │
│ role        │ Template     │ Updated from template          │
│ owner       │ Template     │ Updated from template          │
│ expert      │ Template     │ Updated from template          │
│ link        │ Template     │ Updated from template          │
│ status      │ Instance     │ PRESERVED (critical!)          │
└─────────────┴──────────────┴────────────────────────────────┘
```

---

## Tech Stack

No new dependencies. Pure TypeScript logic change within existing service architecture.

- **Language:** TypeScript
- **Testing:** Vitest (unit tests with mocked Supabase client)
- **Service Pattern:** Supabase mock via `vi.mock('../../config/supabase')`
- **Instance Update:** Lazy-imported `updateOnboardingInstance()` (delete-all-then-insert pattern)

---

## File Structure

### Files to Create

| File | Purpose |
|------|---------|
| `src/services/supabase/templateService.test.ts` | Unit tests for `syncTemplateStepsToInstances()` -- 12+ test cases covering reorder, rename, add, remove, status preservation, progress recalculation, and edge cases |

### Files to Modify

| File | Lines | Change |
|------|-------|--------|
| `src/services/supabase/templateService.ts` | 170-219 | Rewrite `syncTemplateStepsToInstances()` with title-based matching algorithm |

No other files are modified. No database migrations. No type changes. No UI changes.

---

## Data Model

No schema changes. The algorithm works entirely with the existing `Step` interface:

```typescript
interface Step {
  id: number;         // position (1-based), reassigned from template order
  title: string;      // used as match key
  description: string;
  role: string;
  owner: string;
  expert: string;
  status: StepStatus; // 'pending' | 'completed' | 'stuck' -- PRESERVED from instance
  link: string;
}
```

The `updateOnboardingInstance()` function handles the DB write:
1. DELETE all `instance_steps` WHERE `instance_id = id`
2. INSERT new `instance_steps` rows from the merged array

This delete-all-then-insert pattern means no UNIQUE constraint violations are possible.

---

## Component Architecture

Not applicable -- this is a pure service-layer fix with no UI changes.

---

## Testing Strategy

### Unit Tests (12 test cases in `templateService.test.ts`)

The test file mocks:
- `supabase.from('onboarding_instances').select().eq()` -- returns controlled instance data
- `updateOnboardingInstance` via `vi.mock('./instanceService')` -- captures calls for assertion
- `supabase.from('templates')` / `supabase.from('template_steps')` -- for `updateTemplate` chain

Since `syncTemplateStepsToInstances` is a private function (not exported), tests exercise it indirectly through `updateTemplate()`, which calls it when `updates.steps` is provided.

**Test Categories:**

1. **Reorder tests (3):**
   - Pure reorder: steps A,B,C,D reordered to B,A,D,C -- positions updated, statuses preserved
   - Reorder with mixed statuses (completed + pending + stuck) -- all statuses preserved
   - Single step template -- no reorder possible, verify passthrough

2. **Field update tests (2):**
   - Description change propagates to instance while preserving status
   - Owner/expert/role/link changes propagate to instance while preserving status

3. **Add/remove tests (3):**
   - New step added to template -- appears in instance with `status: 'pending'`
   - Step removed from template -- dropped from instance, progress recalculated
   - Mixed: add one step, remove another, reorder rest -- verify full reconciliation

4. **Progress calculation tests (2):**
   - 2/4 completed steps -> remove 2 pending steps -> progress should be 100% (2/2)
   - 3/3 completed + add 1 new pending -> progress should be 75% (3/4)

5. **Edge case tests (2):**
   - Empty template steps -- instance steps should all be dropped, progress 0
   - Multiple instances -- each synced independently with correct results

### Integration Tests

Not applicable -- the function's integration with `updateOnboardingInstance()` is verified via the mock. The `updateOnboardingInstance` function itself is already tested in `instanceService.test.ts`.

### E2E Tests

Not in scope for this fix. The `/test` agent will verify via Playwright that:
- Editing a template's step order propagates to the employee view
- Adding/removing template steps reflects in active instances

---

## Implementation Notes

### Key Decisions

1. **Title-based matching chosen over stable UUID:** No migration needed, titles are naturally unique within a template, and the edge case (rename = new step) has acceptable behavior.

2. **Orphan steps are dropped, not archived:** When a step is removed from a template, the corresponding instance step is simply not included in the merged array. The delete-all-then-insert pattern in `updateOnboardingInstance` handles the cleanup.

3. **Status is the only preserved field:** All other fields (position, title, description, role, owner, expert, link) are overwritten from the template. This ensures instances always reflect the latest template content.

4. **Progress recalculation follows existing pattern:** `Math.round((completedCount / totalSteps) * 100)` with a 0-division guard. No status auto-transition (active/completed) is done in the sync function -- that is handled by `updateStepStatus` when employees interact.

### Patterns to Follow

- Lazy import of `updateOnboardingInstance` to avoid circular dependency (existing pattern at line 173)
- Per-instance try/catch with `console.warn` on failure (existing pattern at lines 206-211)
- Outer try/catch wrapping the entire function (existing pattern at lines 213-218)

### Trade-offs

| Decision | Benefit | Cost |
|----------|---------|------|
| Title matching | Zero migration, simple | Rename + reorder = status reset |
| Drop removed steps | Clean, matches intent | Completed work is lost if step removed |
| Preserve only status | Simple, predictable | Cannot preserve custom instance-only data |

### Non-Goals

- **Stable UUID approach:** Deferred. Can be added as a future enhancement.
- **Removed step archival:** Not flagging removed steps. They are simply dropped.
- **Conflict detection:** Not warning about rename+reorder edge case.
- **Batch DB operations:** Not using RPC for multi-instance updates. Sequential is fine at current scale.
- **UI changes:** No template editor or instance viewer changes.
- **Status auto-transition:** The sync function does NOT change instance `status` to 'completed' even if progress reaches 100%. That logic lives in `updateStepStatus` and is triggered by employee actions, not template edits.

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Duplicate titles within a template cause wrong match | Titles are naturally distinct. No validation added now, but could be added as future enhancement. |
| Rename + reorder resets step status to pending | Documented and accepted. Renaming a step semantically creates a "new" step. |
| Large number of instances causes slow sync | Sequential per-instance is fine at current scale (tens, not thousands). |
| Race condition with concurrent employee step update | Last writer wins (delete-then-insert). Acceptable since template edits are infrequent. |
