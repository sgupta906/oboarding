# Research: template-step-sync-fix

## Metadata
- **Feature:** template-step-sync-fix
- **Created:** 2026-02-17T03:23 UTC
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context

### Description
When a manager edits an onboarding template (reorders steps, renames steps, changes descriptions, or removes steps), those changes do not propagate to existing onboarding instances that were created from that template. The current `syncTemplateStepsToInstances()` function only adds NEW steps (by comparing step IDs), but since step IDs are position-based (1, 2, 3, 4) and get reassigned on every save, the ID set never changes on a pure reorder, so the function finds nothing to add and skips silently.

### Where It Fits
This is a data integrity bug in the template-to-instance synchronization layer. It affects:
- **Manager workflow:** Editing templates is ineffective for active instances
- **Employee experience:** Employees see stale step data that doesn't match the current template
- **Data consistency:** Template and instance steps drift apart over time

### Dependencies on Other Features
- **Zustand store (complete):** Steps and instances are managed via Zustand. The sync function writes directly to Supabase, and Realtime subscriptions pick up changes.
- **Template reorder fix (bug #37, complete):** Step IDs are now always `index + 1` on submit. This fix is prerequisite context.
- **Template steps UX (bug #14, complete):** Reorder UI (ChevronUp/ChevronDown) is implemented.

---

## Requirements

### Functional Requirements
- FR1: When a template's steps are reordered, all active instances using that template have their steps reordered to match
- FR2: When a template step's title is changed, the corresponding instance step's title is updated
- FR3: When a template step's description is changed, the corresponding instance step's description is updated
- FR4: When a template step's owner/expert fields are changed, the corresponding instance step fields are updated
- FR5: When a truly new step is added to the template, it is added to instances with `status: 'pending'`
- FR6: When a step is removed from the template, the instance step is removed from the merged steps array
- FR7: Completion status (pending/completed/stuck) of each instance step is preserved through all sync operations
- FR8: Progress percentage is recalculated after any sync
- FR9: Instance status (active/completed/on_hold) is recalculated based on progress

### Technical Requirements
- TR1: The sync function handles all active instances for a given template_id
- TR2: Step matching works reliably across reorders using title-based matching strategy
- TR3: The sync uses `updateOnboardingInstance()` from instanceService (lazy-imported to avoid circular dependency)
- TR4: Errors on individual instance syncs are caught and logged, not abort the entire sync
- TR5: The function handles edge cases: empty steps arrays, instances with zero steps, templates with more/fewer steps than instances

### Constraints
- No database migration needed (title-based matching works within existing schema)
- Must not break the `UNIQUE (instance_id, position)` constraint on instance_steps
- Must not break the `UNIQUE (template_id, position)` constraint on template_steps
- The `updateOnboardingInstance()` function does delete-all-then-insert for steps, so position uniqueness is handled

---

## Existing Code Analysis

### Project State
- **Project exists:** YES
- **Relevant existing files:** 8 files directly involved

### Current `syncTemplateStepsToInstances()` (templateService.ts:170-219)

The current implementation has a fundamental flaw:

```typescript
// Current broken logic (lines 191-193):
const existingStepIds = new Set(instance.steps.map((step) => step.id));
const stepsToAdd = newSteps.filter((step) => !existingStepIds.has(step.id));
if (stepsToAdd.length === 0) continue;
```

**Why it fails:**
- Step `id` is actually the `position` field (1, 2, 3, 4)
- After bug #37 fix, step IDs are always `index + 1` on save
- A template with steps [A, B, C, D] has IDs {1, 2, 3, 4}
- After reorder to [B, A, D, C], IDs are STILL {1, 2, 3, 4} (reassigned by position)
- `stepsToAdd` is empty because {1,2,3,4} - {1,2,3,4} = {}
- The function skips the instance entirely
- Renames and description changes are also invisible because the function only adds, never updates

### How `updateTemplate()` Works (templateService.ts:100-163)

```
1. Update template row metadata (name, description, role, is_active)
2. If steps changed:
   a. DELETE all template_steps WHERE template_id = id
   b. INSERT new template_steps with position = step.id (which is index+1)
   c. Call syncTemplateStepsToInstances(id, updates.steps)
```

Key insight: The template steps are fully replaced (delete + insert), so template_steps always reflect the latest state perfectly. The problem is only in the sync-to-instances function.

### How `updateOnboardingInstance()` Works (instanceService.ts:135-198)

```
1. Update instance row fields (employee_name, progress, status, etc.)
2. If steps included in updates:
   a. DELETE all instance_steps WHERE instance_id = id
   b. INSERT new instance_steps
```

This is the same delete-all-then-insert pattern. It means the sync function can pass a fully-built steps array and `updateOnboardingInstance()` will handle the DB operations atomically.

**Important:** The `position` field maps to `step.id` in the app type (via `toStep` mapper at mappers.ts:116-127).

### How Steps Are Created from Templates (instanceService.ts:324-360)

When a new onboarding run is created via `createOnboardingRunFromTemplate()`:
- Template is fetched via `getTemplate()`
- `template.steps` are directly assigned to the new instance: `steps: template.steps`
- All steps start with their template status (which is always 'pending' for template steps)

This means instance steps are a snapshot of template steps at creation time. There's no stored link between a specific template_step row and its corresponding instance_step row -- they're matched only by position.

### Step Type Definition (types/index.ts:117-127)

```typescript
export interface Step {
  id: number;         // Actually the position (1-based)
  title: string;
  description: string;
  role: string;
  owner: string;
  expert: string;
  status: StepStatus; // 'pending' | 'completed' | 'stuck'
  link: string;
}
```

### Database Schema for Steps (migration 00002)

**template_steps:**
- `id` UUID (PK, auto-generated -- NOT used in app code)
- `template_id` UUID (FK to templates)
- `position` INTEGER (maps to Step.id)
- `title`, `description`, `role`, `owner`, `expert`, `status`, `link`
- UNIQUE constraint: `(template_id, position)`

**instance_steps:**
- `id` UUID (PK, auto-generated -- NOT used in app code)
- `instance_id` UUID (FK to onboarding_instances)
- `position` INTEGER (maps to Step.id)
- `title`, `description`, `role`, `owner`, `expert`, `status`, `link`
- UNIQUE constraint: `(instance_id, position)`

**Critical observation:** Neither table has a `template_step_id` or stable UUID linking template steps to instance steps. The only link is the content itself.

### TemplateModal Submission (TemplateModal.tsx:204-213)

```typescript
const templateSteps: Step[] = stepsToProcess.map((s, index) => ({
  id: index + 1,           // Position-based ID, always 1,2,3,...
  title: s.title,
  description: s.description,
  role: selectedRoles[0] || selectedRoles.join(', '),
  owner: s.owner,
  expert: s.expert,
  status: 'pending' as const,  // Always pending in template
  link: '',
}));
```

All steps submitted from the modal have `status: 'pending'`. This is correct for template steps, but the sync function must NOT overwrite instance step statuses.

### Code to Reuse
- `templateService.ts`: Keep the `updateTemplate()` function as-is. Only rewrite `syncTemplateStepsToInstances()`.
- `instanceService.ts`: Use `updateOnboardingInstance()` exactly as the current sync function does.
- `mappers.ts`: No changes needed. The `toStep()` and `toInstance()` mappers work correctly.

### Code to Modify
- `templateService.ts` lines 170-219: Complete rewrite of `syncTemplateStepsToInstances()`

### Patterns to Follow
- Lazy import of `updateOnboardingInstance` to avoid circular dependency (existing pattern at line 173)
- Try/catch per instance with console.warn on failure (existing pattern at lines 206-211)
- Outer try/catch wrapping the entire function (existing pattern at lines 213-218)
- Progress calculation: `Math.round((completedCount / totalSteps) * 100)` (existing pattern)

---

## Step Matching Strategy Analysis

### Option A: Match by Title (RECOMMENDED)

**How it works:**
- Build a map from `title -> instance_step` for all existing instance steps
- For each template step, look up the matching instance step by title
- If found: preserve the instance step's `status`, update position/description/owner/expert
- If not found: it's a new step, add with `status: 'pending'`
- Instance steps not matched to any template step: these are "removed" from the template

**Pros:**
- No migration needed
- Titles are typically unique within a template (step titles like "Set up laptop", "Meet team lead" are naturally distinct)
- Simple to implement

**Cons:**
- Fails if two steps have identical titles (unlikely but possible)
- Fails if a step is renamed AND reordered simultaneously (the old title won't match)

**Mitigation for rename+reorder:** When a step is renamed, it creates a "no match" situation. The old instance step is treated as removed, and the renamed step is treated as new (added with `status: 'pending'`). This is acceptable behavior -- if you rename a step, it's semantically a new step, and resetting to pending is reasonable.

### Option B: Add Stable UUID to Steps (Most Robust)

**How it works:**
- Add a `stable_id` UUID column to both `template_steps` and `instance_steps`
- When a template step is created, generate a UUID. When an instance is created from a template, copy the `stable_id` to instance steps.
- Sync matches by `stable_id`.

**Pros:** 100% accurate matching regardless of title changes or reorders
**Cons:** Requires database migration, backfill of existing data, changes to mappers, types, and UI code

**Verdict:** Overkill for current needs. Can be added later if title-matching proves insufficient.

### Option C: Match by Content Fingerprint (title + description hash)

**Pros:** Slightly more robust than title alone
**Cons:** Even more fragile when content changes, more complex, no real benefit over title matching

**Verdict:** Rejected. Title matching is simpler and equally effective.

### DECISION: Use Title-Based Matching (Option A)

Title-based matching is the right choice because:
1. No migration needed
2. Template step titles are naturally unique within a template
3. The edge case (rename + reorder) has acceptable behavior (reset to pending)
4. It can be implemented entirely within `syncTemplateStepsToInstances()`

---

## Detailed Sync Algorithm

```
function syncTemplateStepsToInstances(templateId, newTemplateSteps):
  1. Fetch all instances WHERE template_id = templateId
  2. For each instance:
     a. Build a Map<title, instanceStep> from instance.steps
     b. Build the merged steps array:
        - For each templateStep (in template order):
          - Look up instanceStep by title match
          - If found:
            - Keep instanceStep.status (PRESERVE completion state)
            - Use templateStep.id as the new position
            - Use templateStep.title, description, owner, expert, role, link
          - If not found:
            - Create new step with templateStep fields + status: 'pending'
        - (Instance steps not matched to any template step are dropped --
           they correspond to removed template steps)
     c. Calculate progress from merged steps
     d. Call updateOnboardingInstance(instance.id, { steps: mergedSteps, progress })
```

### Fields PRESERVED from Instance Step
- `status` (pending / completed / stuck) -- this is the critical one

### Fields UPDATED from Template Step
- `id` (position) -- reassigned from template order
- `title` -- updated from template
- `description` -- updated from template
- `role` -- updated from template
- `owner` -- updated from template
- `expert` -- updated from template
- `link` -- updated from template

---

## Risk Assessment

### Technical Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Duplicate titles within a template cause wrong match | Medium | Low | Template titles are naturally distinct. Could add a validation check in the future. |
| Rename + reorder causes step to be treated as new (resets status) | Low | Low | This is acceptable -- renaming a step semantically creates a "new" step. Document this behavior. |
| Large number of instances causes timeout | Medium | Low | Current codebase has no timeout concerns. The sync is sequential per-instance but the volume is small (dozens, not thousands). |
| `updateOnboardingInstance` fails on one instance, others still succeed | Low | Medium | Already handled by existing try/catch per instance pattern. |
| Race condition: employee updates step while sync is running | Medium | Low | The delete-then-insert pattern in `updateOnboardingInstance` means the sync's write will overwrite any concurrent employee update. Mitigated by the fact that template edits and step completions rarely coincide. |
| UNIQUE constraint violation on instance_steps | High | None | `updateOnboardingInstance` does DELETE ALL then INSERT, so no constraint violations possible. |

### Complexity
- **Level:** Medium
- **Rationale:** The algorithm is straightforward (map by title, merge, recalculate). The complexity is in the edge cases (removed steps, new steps, preserving status). The actual code change is ~50 lines replacing ~50 lines in a single function. No UI changes, no schema changes, no migration needed.

---

## Open Questions

- [x] Q1: What is the best step matching strategy?
  - Resolution: Title-based matching. See detailed analysis above.

- [x] Q2: What fields should be preserved vs updated during sync?
  - Resolution: Only `status` is preserved from the instance step. All other fields (position, title, description, role, owner, expert, link) are updated from the template.

- [x] Q3: How should removed steps (in template but not instance, or vice versa) be handled?
  - Resolution: Instance steps that don't match any template step title are dropped (not included in the merged array). This effectively removes them. Truly new template steps are added with `status: 'pending'`.

- [x] Q4: Can `updateOnboardingInstance()` handle the full step replacement?
  - Resolution: Yes. It uses delete-all-then-insert for steps (instanceService.ts:166-197). The sync function builds the full merged array and passes it in.

- [x] Q5: Are there existing tests for the sync function?
  - Resolution: No. There are no tests for `syncTemplateStepsToInstances()`. The instanceService tests only cover `updateStepStatus` and `createOnboardingRunFromTemplate`. New tests are needed.

- [x] Q6: What about concurrent edits?
  - Resolution: The risk is low. Template edits happen rarely and the sync is fast (single Supabase query per instance). The delete-then-insert pattern means the last writer wins. This is acceptable for the current scale.

---

## Recommended Approach

### Implementation Strategy

**Single-function rewrite** of `syncTemplateStepsToInstances()` in `src/services/supabase/templateService.ts`. No other files need to change.

The new function will:
1. Fetch all instances for the template (existing code, keep as-is)
2. For each instance, build a title-based mapping of existing instance steps
3. Walk through template steps in order, matching by title to preserve status
4. Handle new steps (add with pending) and removed steps (drop from merged array)
5. Recalculate progress
6. Update instance via `updateOnboardingInstance()`

### Order of Work
1. Write unit tests for the new sync behavior (TDD approach per project conventions)
   - Test: reorder preserves completion status
   - Test: rename propagates title change (unmatched step becomes new/pending)
   - Test: new step added with pending status
   - Test: removed step is dropped from instance
   - Test: progress is recalculated correctly
   - Test: description/owner/expert updates propagate
2. Rewrite `syncTemplateStepsToInstances()` to pass all tests
3. Verify existing tests still pass (`npx vitest run`)

### What to Defer
- **Stable UUID approach:** Can be added later as an enhancement if title-matching proves insufficient in practice
- **Removed step archival:** Could flag removed steps as "archived" instead of dropping them. Not needed for MVP.
- **Conflict detection:** Could detect and warn about rename+reorder. Not needed for MVP.
- **Batch Supabase operations:** Could use a single RPC call to update all instances at once. Not needed at current scale.

---

## Files That Will Be Modified

| File | Change |
|------|--------|
| `src/services/supabase/templateService.ts` | Rewrite `syncTemplateStepsToInstances()` (lines 170-219) |

## Files That Will Be Created

| File | Purpose |
|------|---------|
| Test file (location TBD by plan agent) | Unit tests for the new sync function |

---

## Next Step

**All questions resolved. Status: research-complete.**

Run `/plan template-step-sync-fix` to create the implementation plan.
