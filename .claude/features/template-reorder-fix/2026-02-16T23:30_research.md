# Research: template-reorder-fix

## Metadata
- **Feature:** template-reorder-fix
- **Bug #:** 37 (`template-reorder-not-persisted`)
- **Priority:** P1 HIGH
- **Created:** 2026-02-16T23:30
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context

Template step reordering (via ChevronUp/ChevronDown buttons added in bug #14 / `template-steps-ux`) appears to work in the UI (optimistic state update) but reverts to the original order on page reload. The new step positions are never persisted to the database.

This is a single-line root cause bug in `TemplateModal.tsx` with a straightforward fix. However, the design reveals a broader architectural pattern worth documenting: the app uses `Step.id` as a proxy for `position`, which conflates identity with ordering.

### Dependencies
- Bug #14 (`template-no-step-reorder`) added the reorder UI -- already complete (commit 6879d18)
- No other features depend on this fix

## Requirements

### Functional Requirements
- [ ] FR1: When a user reorders template steps and saves, the new order must persist to the database and survive page reload (source: bug report #37)
- [ ] FR2: Creating a new template must also assign correct 1-based positions to steps (source: code analysis -- same code path)

### Technical Requirements
- [ ] TR1: `Step.id` values in the submitted template data must reflect the new array position (1-based), not the original position
- [ ] TR2: `templateService.ts` already writes `position: step.id` -- this is correct as long as `step.id` carries the new position
- [ ] TR3: The unique constraint `(template_id, position)` on `template_steps` must not be violated -- the service uses delete-then-insert, so this is safe

### Constraints
- The `Step.id` field is typed as `number` and serves dual purpose: it is both the array position (1-based) and the value written to `position` column in the database
- All 3 step tables (`template_steps`, `instance_steps`, `profile_template_steps`) have `UNIQUE (parent_id, position)` constraints
- The mapper `toStep()` reads `id: row.position` -- so on read, `Step.id` always equals the DB `position` column

## Root Cause Analysis

### The Bug Chain

1. **TemplateModal.tsx line 205** -- When building the `Step[]` array for submission:
   ```typescript
   const templateSteps: Step[] = stepsToProcess.map((s, index) => ({
     id: s.id || index + 1,  // BUG: s.id is always truthy for existing steps
     ...
   }));
   ```
   - `s.id` comes from the original template data (e.g., step at original position 1 has `s.id = 1`)
   - For existing steps, `s.id` is always a positive integer (truthy), so `index + 1` is NEVER used
   - After reordering steps [A(id=1), B(id=2), C(id=3)] to [B, A, C], the submitted `Step.id` values are still [2, 1, 3] instead of the correct [1, 2, 3]

2. **templateService.ts line 141** -- Writes `position: step.id` to the database:
   ```typescript
   const stepRows: TemplateStepInsert[] = updates.steps.map((step) => ({
     template_id: id,
     position: step.id,  // Carries the OLD position value
     ...
   }));
   ```
   - Since `step.id` was never updated in step 1, the old positions are written back
   - The delete-then-insert pattern means old rows are removed first, then re-inserted with old positions

3. **mappers.ts line 140** -- On the next read, sorts by position:
   ```typescript
   steps: stepRows
     .sort((a, b) => a.position - b.position)
     .map(toStep),
   ```
   - Steps are sorted by position, restoring the original order

4. **useTemplates.ts line 102-104** -- Optimistic update masks the bug:
   ```typescript
   setData(prev => prev.map(t =>
     t.id === id ? { ...t, ...updates, updatedAt: Date.now() } : t
   ));
   ```
   - The `updates` object contains the steps in the new UI order
   - This immediately updates local state, making it LOOK like the reorder worked
   - On next page load or realtime push, the DB order overwrites the optimistic state

### Why `createTemplate` Has the Same Issue

**templateService.ts line 74** also uses `position: step.id`:
```typescript
const stepRows: TemplateStepInsert[] = template.steps.map((step) => ({
  template_id: newId,
  position: step.id,  // Same pattern
  ...
}));
```

For create mode, the TemplateModal line 205 expression `s.id || index + 1` does work correctly because new steps have `s.id = undefined` (the local `TemplateStep` interface has `id?: number`). So `index + 1` IS used for new templates. However, this only works by accident -- the intent is unclear.

### Where `position: step.id` Appears (6 locations)

| File | Line | Context | Affected by fix? |
|------|------|---------|------------------|
| `templateService.ts` | 74 | `createTemplate` -- insert steps | No change needed (receives correct ids after fix) |
| `templateService.ts` | 141 | `updateTemplate` -- insert steps | No change needed (receives correct ids after fix) |
| `instanceService.ts` | 109 | `createOnboardingInstance` -- insert steps | Not affected (instances get steps from template, already correct) |
| `instanceService.ts` | 179 | `updateOnboardingInstance` -- insert steps | Not affected |
| `profileTemplateService.ts` | 108 | `createProfileTemplate` -- insert steps | Not affected (different modal) |
| `profileTemplateService.ts` | 193 | `updateProfileTemplate` -- insert steps | Not affected (different modal) |

All 6 locations use the same `position: step.id` pattern. This is correct by design -- `Step.id` IS the position. The bug is that `TemplateModal.tsx` fails to update `Step.id` to the new position after reordering.

## Existing Code Analysis

### Project State
- Project exists: YES
- Test count: 508 tests across 30 test files
- Existing reorder tests: 6 tests in `TemplateModal.test.tsx` (lines 420-579) testing UI reorder behavior

### Code to Modify (1 file, 1 line)

**`/home/sanjay/Workspace/onboarding/src/components/templates/TemplateModal.tsx` line 205:**
```typescript
// BEFORE (buggy):
id: s.id || index + 1,

// AFTER (fixed):
id: index + 1,
```

This ensures that after reordering, each step gets its new 1-based position regardless of its original position.

### Code That Requires No Changes
- `templateService.ts` -- `position: step.id` is correct (will now receive updated ids)
- `mappers.ts` -- `id: row.position` read path is correct
- `useTemplates.ts` -- optimistic update is correct (already uses the submitted data)

### Existing Tests to Verify
The 6 existing reorder tests in `TemplateModal.test.tsx` test UI behavior (visual reorder) but do NOT verify the `onSubmit` payload. A new test should verify that the submitted `Step.id` values reflect the new positions.

### Test Gap
**Missing test:** "After reorder, submitted step IDs should match new positions"
```typescript
// Should verify:
// 1. Reorder steps [A(id=1), B(id=2)] to [B, A]
// 2. Submit
// 3. Assert onSubmit called with steps where:
//    - steps[0].id === 1 (B is now position 1)
//    - steps[1].id === 2 (A is now position 2)
```

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Fix breaks create mode | Medium | Low | Create mode already uses `index + 1` when `s.id` is undefined; with fix, create mode continues to use `index + 1` (same result) |
| Instance sync breaks | Medium | Low | `syncTemplateStepsToInstances` uses `step.id` for identity matching -- after fix, reordered steps get new ids, which may cause duplicates if instance has steps with old ids. BUT: the service deletes old template_steps first and inserts new ones, so the sync compares against instance steps (different table). The sync only ADDS steps, never removes. Risk is low. |
| Unique constraint violation | High | None | Service uses delete-all-then-insert pattern, so no duplicate positions |

### Complexity
- **Level:** Simple
- **Rationale:** Single line change with clear root cause. The `||` operator short-circuits on truthy values, and existing step IDs are always truthy positive integers. Changing to unconditional `index + 1` is the obvious fix.

## Open Questions

- [x] Q1: Does `createTemplate` have the same bug?
  - Resolution: No -- for new templates, `s.id` is `undefined` (falsy), so `index + 1` is already used. The fix makes this consistent for both paths.

- [x] Q2: Could the fix break the `syncTemplateStepsToInstances` function?
  - Resolution: No. The sync function compares `step.id` values between new template steps and existing instance steps. After a reorder, the template steps have new `id` values (e.g., step that was id=3 is now id=1). The sync function sees these as "new" steps (not matching existing instance step ids) and would add them. However, since `updateTemplate` deletes all old template_steps and inserts new ones, and the sync only adds non-matching steps to instances, this is safe. The worst case is that a reorder might trigger adding duplicate step content to instances -- but this is a pre-existing design limitation of the sync function, not introduced by this fix.

- [x] Q3: Are there any other places where `Step.id` values are assigned from user input?
  - Resolution: `TemplateModal.tsx` line 205 is the ONLY place. All other code paths receive `Step.id` from the database (via `toStep` mapper) or pass it through unchanged.

## Recommended Approach

### Implementation Strategy

**Single-line fix in `TemplateModal.tsx`:**

Change line 205 from:
```typescript
id: s.id || index + 1,
```
To:
```typescript
id: index + 1,
```

### Order of Work
1. Apply the one-line fix in `TemplateModal.tsx`
2. Add a test that verifies submitted step IDs match new positions after reorder
3. Run full test suite to confirm no regressions

### What to Defer
- The broader `Step.id` / `position` conflation is a design smell but NOT worth fixing now -- it works correctly everywhere once this bug is fixed
- The `syncTemplateStepsToInstances` duplicate-step risk is pre-existing and orthogonal to this fix

## Next Step

**All questions resolved. Run `/plan template-reorder-fix` to create implementation plan.**
