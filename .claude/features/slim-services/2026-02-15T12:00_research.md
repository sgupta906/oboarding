# Research: slim-services

## Metadata
- **Feature:** slim-services
- **Created:** 2026-02-15T12:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context
- **Description:** Replace 8 repetitive Supabase service files with a generic CRUD service factory, eliminating ~1,500 lines of boilerplate while preserving all service-specific behavior.
- **Where it fits:** Second of three "fat-trim" features. Follows `slim-modals` (complete). Precedes `slim-tests`.
- **Dependencies:** None -- this is a refactor of existing stable code.

## Requirements

### Functional Requirements
- [ ] FR1: Create a `createCrudService<TRow, TApp>(config)` factory function that generates standard CRUD + subscribe operations (source: user request)
- [ ] FR2: All 8 services must continue to export the same public API (same function names, same signatures) (source: barrel export compatibility)
- [ ] FR3: All service-specific custom operations must remain functional (e.g., `roleNameExists`, `isRoleInUse`, `updateStepStatus`, `createOnboardingRunFromTemplate`, etc.) (source: existing code analysis)
- [ ] FR4: The subscription pattern (debounce + shared subscription + multi-table listening) must be preserved (source: performance-loading feature)
- [ ] FR5: The mapper layer (snake_case DB rows to camelCase app types) must continue to work (source: existing architecture)
- [ ] FR6: Barrel export (`index.ts`) must re-export everything identically (source: consumer compatibility)

### Technical Requirements
- [ ] TR1: No new dependencies -- factory must be pure TypeScript
- [ ] TR2: Must not break the 696 existing tests
- [ ] TR3: Must preserve lazy-init Supabase client Proxy pattern
- [ ] TR4: Must preserve the `subscriptionManager.ts` shared subscription pattern for services that use it (roles only currently)
- [ ] TR5: Must preserve the debounce pattern for all realtime subscriptions
- [ ] TR6: Factory should be simple -- not an over-engineered abstraction framework

### Constraints
- Existing test files mock `./supabase` barrel -- the mock surface must stay the same
- Some services have lazy `import()` calls to avoid circular dependencies (templateService imports instanceService; instanceService imports templateService and userService; userService imports activityService)
- The `userService.ts` has auth credential helpers in localStorage that are NOT CRUD -- these must remain separate

## Existing Code Analysis

### Service-by-Service Breakdown

#### 1. roleService.ts (246 lines)

**Standard CRUD:**
| Operation | Signature | Query Pattern |
|-----------|-----------|---------------|
| `listRoles()` | `() => Promise<CustomRole[]>` | `.select('*').limit(200)` |
| `getRole(id)` | `(id: string) => Promise<CustomRole \| null>` | `.select('*').eq('id', id).single()` |
| `createRole(name, description, createdBy)` | CUSTOM signature | Custom: UUID validation, trimming, unique constraint handling |
| `updateRole(roleId, updates)` | `(id: string, updates: {...}) => Promise<void>` | `.update(safeUpdates).eq('id', roleId)` |
| `deleteRole(roleId)` | `(id: string) => Promise<void>` | Checks `isRoleInUse` first, then `.delete().eq('id', roleId)` |

**Custom Operations (NOT standardizable):**
- `roleNameExists(name)` -- case-insensitive `.ilike()` check
- `isRoleInUse(roleId)` -- checks templates + instances tables in parallel
- UUID validation helper (`isValidUUID`)

**Subscription Pattern:**
- Uses `createSharedSubscription` (the ONLY service that does)
- `_subscribeToRolesRaw` -> debounce -> listRoles re-fetch
- Single table: `roles`

**Mapper:** `toRole` (simple, no child rows)

---

#### 2. templateService.ts (310 lines)

**Standard CRUD:**
| Operation | Signature | Query Pattern |
|-----------|-----------|---------------|
| `listTemplates()` | `() => Promise<Template[]>` | `.select('*, template_steps(*)').limit(200)` |
| `getTemplate(id)` | `(id: string) => Promise<Template \| null>` | `.select('*, template_steps(*)').eq('id', id).single()` |
| `createTemplate(template)` | CUSTOM: `Omit<Template, 'id' \| 'createdAt'>` | Parent insert + child step rows insert |
| `updateTemplate(id, updates)` | `(id: string, updates: Partial<Template>) => Promise<void>` | Parent update + delete+insert child steps + sync to instances |
| `deleteTemplate(id)` | `(id: string) => Promise<void>` | `.delete().eq('id', id)` (CASCADE handles steps) |

**Custom Operations:**
- `syncTemplateStepsToInstances(templateId, newSteps)` -- private, called from updateTemplate
- Lazy import of `instanceService` to avoid circular dep

**Subscription Pattern:**
- Direct (no shared subscription)
- Listens on TWO tables: `templates` + `template_steps`
- Debounce 300ms

**Mapper:** `toTemplate(row, stepRows)` -- parent + child step rows

---

#### 3. userService.ts (480 lines)

**Standard CRUD:**
| Operation | Signature | Query Pattern |
|-----------|-----------|---------------|
| `listUsers()` | `() => Promise<User[]>` | `.select('*, user_roles(*), user_profiles(*)').limit(200)` |
| `getUser(id)` | `(id: string) => Promise<User \| null>` | `.select('*, user_roles(*), user_profiles(*)').eq('id', id).single()` |
| `createUser(userData, createdBy)` | CUSTOM complex | Email check + parent insert + 2 junction table inserts + auth credentials |
| `updateUser(userId, updates)` | CUSTOM complex | Email check + parent update + 2 junction table delete+insert |
| `deleteUser(userId)` | CUSTOM | Fetch user for email, delete (CASCADE), remove auth credentials |

**Custom Operations (NOT standardizable -- ~150 lines):**
- `userEmailExists(email, excludeUserId?)` -- case-insensitive check with optional exclusion
- `addUserToAuthCredentials(email, role, userId)` -- localStorage dev-mode auth
- `getAuthCredential(email)` -- localStorage lookup
- `removeUserFromAuthCredentials(email)` -- localStorage cleanup
- `saveLocalUsers(users)` -- test helper
- `setDisableDefaultUserSeeding(disable)` -- test helper
- `clearAllUsersForTesting()` -- test helper
- `logActivity(activity)` -- lazy import to activityService

**Subscription Pattern:**
- Direct (no shared subscription)
- Listens on THREE tables: `users`, `user_roles`, `user_profiles`
- Debounce 300ms

**Mapper:** `toUser(row, roleRows, profileRows)` -- parent + 2 junction row arrays

---

#### 4. activityService.ts (95 lines)

**Standard CRUD (partial -- no get/update/delete):**
| Operation | Signature | Query Pattern |
|-----------|-----------|---------------|
| `listActivities()` | `() => Promise<Activity[]>` | `.select('*').order('timestamp', { ascending: false }).limit(50)` |
| `logActivity(activity)` | CUSTOM create | Insert with custom field mapping |

**No:** get, update, delete operations

**Subscription Pattern:**
- Direct (no shared subscription)
- Single table: `activities`
- Debounce 300ms

**Mapper:** `toActivity` (simple, no child rows, but uses `formatTimeAgo`)

---

#### 5. suggestionService.ts (124 lines)

**Standard CRUD:**
| Operation | Signature | Query Pattern |
|-----------|-----------|---------------|
| `listSuggestions()` | `() => Promise<Suggestion[]>` | `.select('*').limit(200)` |
| `createSuggestion(suggestion)` | CUSTOM: `Omit<Suggestion, 'id' \| 'createdAt'>` | Insert with field mapping |
| `updateSuggestionStatus(id, status)` | CUSTOM: status-only update | `.update({ status }).eq('id', id)` |
| `deleteSuggestion(id)` | `(id: string) => Promise<void>` | `.delete().eq('id', id)` |

**No:** get operation

**Subscription Pattern:**
- Direct (no shared subscription)
- Single table: `suggestions`
- Debounce 300ms

**Mapper:** `toSuggestion` (simple, no child rows)

---

#### 6. instanceService.ts (614 lines -- LARGEST)

**Standard CRUD:**
| Operation | Signature | Query Pattern |
|-----------|-----------|---------------|
| `listOnboardingInstances()` | `() => Promise<OnboardingInstance[]>` | `.select('*, instance_steps(*)').limit(200)` |
| `getOnboardingInstance(id)` | `(id: string) => Promise<OnboardingInstance \| null>` | `.select('*, instance_steps(*)').eq('id', id).single()` |
| `createOnboardingInstance(instance)` | CUSTOM complex | Parent insert + child step rows insert |
| `updateOnboardingInstance(id, updates)` | CUSTOM complex | Field mapping + optional child step delete+insert |
| `deleteOnboardingInstance` | NOT PRESENT (no delete) |

**Custom Operations (NOT standardizable -- ~335 lines):**
- `updateStepStatus(instanceId, stepId, status)` -- targeted step update + progress recalculation
- `OnboardingValidationError` class
- `CreateOnboardingRunInput` interface
- `validateEmployeeData(data)` -- validation function
- `createOnboardingRunFromTemplate(employeeData)` -- complex orchestration: validate, fetch template, create instance, create user
- `subscribeToOnboardingInstance(instanceId, callback)` -- single-instance subscription with filter
- `subscribeToSteps(instanceId, callback)` -- steps-only subscription
- `subscribeToEmployeeInstance(email, callback)` -- email-filtered subscription

**Subscription Pattern (MULTIPLE):**
- `subscribeToOnboardingInstances` -- all instances, 2 tables: `onboarding_instances` + `instance_steps`
- `subscribeToOnboardingInstance(instanceId)` -- filtered by ID, 2 tables with filter
- `subscribeToSteps(instanceId)` -- `instance_steps` only, filtered
- `subscribeToEmployeeInstance(email)` -- filtered by email, 2 tables
- All use debounce 300ms

**Mapper:** `toInstance(row, stepRows)`, `toStep(row)` -- parent + child

---

#### 7. profileService.ts (221 lines)

**Standard CRUD:**
| Operation | Signature | Query Pattern |
|-----------|-----------|---------------|
| `listProfiles()` | `() => Promise<Profile[]>` | `.select('*, profile_role_tags(*)').limit(200)` |
| `getProfile(id)` | `(id: string) => Promise<Profile \| null>` | `.select('*, profile_role_tags(*)').eq('id', id).single()` |
| `createProfile(name, desc, roleTags, createdBy)` | CUSTOM | Parent insert + junction table insert |
| `updateProfile(profileId, updates)` | CUSTOM | Parent update + junction table delete+insert |
| `deleteProfile(profileId)` | `(id: string) => Promise<void>` | `.delete().eq('id', id)` (CASCADE) |

**Subscription Pattern:**
- Direct (no shared subscription)
- Listens on TWO tables: `profiles` + `profile_role_tags`
- Debounce 300ms

**Mapper:** `toProfile(row, roleTagRows)` -- parent + junction rows

---

#### 8. profileTemplateService.ts (271 lines)

**Standard CRUD:**
| Operation | Signature | Query Pattern |
|-----------|-----------|---------------|
| `listProfileTemplates(profileId?)` | `(profileId?: string) => Promise<ProfileTemplate[]>` | Conditional `.eq('profile_id', profileId)`, then `.limit(200)` |
| `getProfileTemplate(id)` | `(id: string) => Promise<ProfileTemplate \| null>` | `.select('*, profile_template_steps(*)').eq('id', id).single()` |
| `createProfileTemplate(profileId, name, desc, steps, createdBy)` | CUSTOM | Parent insert + child step rows insert |
| `updateProfileTemplate(templateId, updates)` | CUSTOM | Parent update + child step delete+insert |
| `deleteProfileTemplate(templateId)` | `(id: string) => Promise<void>` | `.delete().eq('id', id)` (CASCADE) |

**Custom:** `listProfileTemplates` has optional filter parameter

**Subscription Pattern:**
- Direct (no shared subscription)
- Filtered by profileId on parent table
- Listens on TWO tables: `profile_templates` (filtered) + `profile_template_steps` (unfiltered)
- Debounce 300ms

**Mapper:** `toProfileTemplate(row, stepRows)` -- parent + child

---

### Pattern Analysis: What's STANDARD vs CUSTOM

#### STANDARD patterns (identical across most services):

1. **`list()`** -- All 8 services have this. Pattern: `.select(selectClause).limit(N)` then `.map(mapper)`. Variations:
   - Select clause varies: `'*'` vs `'*, child_table(*)'`
   - Limit varies: 200 (most) vs 50 (activities)
   - One has optional filter param (profileTemplateService)
   - One has `.order()` (activityService)

2. **`get(id)`** -- 6 of 8 services have this (NOT activity, NOT suggestion). Pattern: `.select(selectClause).eq('id', id).single()` with PGRST116 not-found handling.

3. **`delete(id)`** -- 6 of 8 services have this (NOT activity, NOT instance). Pattern: `.delete().eq('id', id)`. Some pre-check (role checks in-use).

4. **`subscribe(callback)`** -- All 8 services have at least one. Pattern: debounce(300ms) + list re-fetch + channel listen on `event: '*'`. Variations:
   - Number of tables listened: 1, 2, or 3
   - Filter vs unfiltered
   - Some use `createSharedSubscription`, most don't
   - Instance service has 4 different subscribe functions

5. **Error handling** -- All throw `new Error(\`Failed to X: ${error.message}\`)`. Identical pattern.

6. **Timestamp handling** -- All use `toISO(Date.now())` for created_at/updated_at.

#### CUSTOM patterns (unique per service):

1. **Create operations** -- All have different signatures and logic. Cannot be generically factored without losing clarity.
2. **Update operations** -- Most have custom field mapping. Template/instance/profile/profileTemplate have child table management (delete+insert).
3. **Business rules** -- UUID validation (role), email uniqueness (user), in-use checks (role), step sync (template), progress calculation (instance), validation error class (instance), auth credential management (user).
4. **Lazy imports** -- 3 services use `await import()` for circular dependency avoidance.

### What the Factory CAN Handle

Based on analysis, a factory can standardize these operations:

| Operation | Lines saved per service | Services applicable |
|-----------|----------------------|---------------------|
| `list()` | ~10 lines | 8/8 |
| `get(id)` | ~12 lines | 6/8 |
| `delete(id)` | ~8 lines | 6/8 |
| `subscribe()` (basic all-items) | ~25 lines | 7/8 (not instance -- it has 4 variants) |
| Error message pattern | Embedded in above | All |

**Estimated standard lines per service saved:** ~50 lines
**Total standard lines saved across 8 services:** ~350-400 lines

### What the Factory CANNOT Handle

| Custom Code | Service | Lines |
|-------------|---------|-------|
| `create` logic | All 8 | ~200 lines total |
| `update` logic (field mapping, child tables) | All 8 | ~250 lines total |
| Business rules (roleNameExists, isRoleInUse, UUID validation) | roleService | ~50 lines |
| Auth credential helpers | userService | ~120 lines |
| Test helpers | userService | ~30 lines |
| Step status update + progress calc | instanceService | ~55 lines |
| Create onboarding run from template | instanceService | ~60 lines |
| Validation error class + validator | instanceService | ~50 lines |
| Template-to-instance sync | templateService | ~50 lines |
| Filtered subscriptions (4 variants) | instanceService | ~100 lines |
| logActivity delegation | userService | ~5 lines |

### Subscription Pattern Variations

| Service | Channel Name | Tables Listened | Filter | Shared? |
|---------|-------------|-----------------|--------|---------|
| roles | `roles-all` | 1: `roles` | No | YES (createSharedSubscription) |
| templates | `templates-all` | 2: `templates`, `template_steps` | No | No |
| users | `users-all` | 3: `users`, `user_roles`, `user_profiles` | No | No |
| activities | `activities-all` | 1: `activities` | No | No |
| suggestions | `suggestions-all` | 1: `suggestions` | No | No |
| instances (all) | `instances-all` | 2: `onboarding_instances`, `instance_steps` | No | No |
| instances (single) | `instance-{id}` | 2: filtered by id | Yes (eq filter) | No |
| steps | `instance-steps-{id}` | 1: `instance_steps` | Yes (eq filter) | No |
| employee instance | `employee-instance-{email}` | 2: filtered by email | Yes (eq filter) | No |
| profiles | `profiles-all` | 2: `profiles`, `profile_role_tags` | No | No |
| profile templates | `profile-templates-{id}` | 2: `profile_templates` (filtered), `profile_template_steps` | Yes (eq filter) | No |

### Mapper Complexity

| Mapper | Arity | Notes |
|--------|-------|-------|
| `toRole(row)` | 1 arg | Simple flat mapping |
| `toActivity(row)` | 1 arg | Simple + `formatTimeAgo` |
| `toSuggestion(row)` | 1 arg | Simple, field name remap |
| `toStep(row)` | 1 arg | Simple, position->id |
| `toTemplate(row, stepRows)` | 2 args | Parent + sorted child rows |
| `toInstance(row, stepRows)` | 2 args | Parent + sorted child rows |
| `toProfile(row, tagRows)` | 2 args | Parent + junction rows |
| `toProfileTemplate(row, stepRows)` | 2 args | Parent + sorted child rows |
| `toUser(row, roleRows, profileRows)` | 3 args | Parent + 2 junction arrays |

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Factory abstraction hides important service-specific behavior | Medium | Medium | Only abstract truly standard operations (list/get/delete/subscribe), keep create/update as custom code |
| Tests break because mock surface changes | High | Low | Keep barrel export API identical; tests mock the barrel |
| Type safety lost in generic factory | Medium | Medium | Use strict generics with proper type constraints |
| Circular dependency issues with factory | Medium | Low | Factory only handles Supabase client calls, not cross-service imports |
| Subscription refactoring breaks realtime | High | Low | Parameterize subscription config, don't change the pattern itself |

### Complexity
- **Level:** Medium
- **Rationale:** The standard patterns are genuinely identical and easily factored. The risk is in the boundary between standard and custom -- each service has unique create/update logic. The factory must have clean extension points, not try to handle everything.

## Open Questions

- [x] Q1: Should create and update operations be part of the factory?
  - Resolution: NO. Every service has a unique create/update signature and custom logic (field mapping, child tables, business rules, side effects). Trying to genericize these would create a more complex abstraction than the current code. The factory should handle list/get/delete/subscribe only.

- [x] Q2: Should the subscription factory support the `createSharedSubscription` pattern?
  - Resolution: YES, as an opt-in config option. Only roleService uses it currently, but the factory should accept a `shared: true` flag.

- [x] Q3: Should we keep 8 separate service files, or merge into fewer files?
  - Resolution: Keep separate files. Each service has custom operations that warrant their own file. The factory just reduces boilerplate within each file.

- [x] Q4: How should the factory handle the different select clauses (`'*'` vs `'*, child_table(*)'`)?
  - Resolution: `selectClause` should be a config parameter on the factory.

- [x] Q5: How should the factory handle multi-argument mappers?
  - Resolution: The factory's `list()` and `get()` should accept a `mapRow` function that receives the raw Supabase response row and returns the app type. The mapper function itself handles extracting child rows from the joined data. This keeps the factory simple.

## Recommended Approach

### Implementation Strategy

Create a `createCrudService` factory that handles the 4 standardizable operations, then refactor each service file to use it while keeping custom operations as standalone functions.

#### Factory Configuration Interface

```typescript
interface CrudServiceConfig<TApp> {
  table: string;                          // Primary table name
  selectClause: string;                   // e.g., '*' or '*, template_steps(*)'
  mapRow: (row: any) => TApp;            // Maps raw Supabase row to app type
  entityName: string;                     // For error messages: 'role', 'template', etc.
  listLimit?: number;                     // Default: 200
  listOrder?: { column: string; ascending: boolean }; // Optional ordering
  subscription?: {
    channelName: string;                  // e.g., 'roles-all'
    tables: { table: string; filter?: string }[]; // Tables to listen on
    shared?: boolean;                     // Use createSharedSubscription?
  };
}
```

#### Factory Output

```typescript
interface CrudServiceResult<TApp> {
  list: () => Promise<TApp[]>;
  get: (id: string) => Promise<TApp | null>;
  remove: (id: string) => Promise<void>;
  subscribe: (callback: (items: TApp[]) => void) => () => void;
}
```

#### Example: roleService.ts AFTER refactor

```typescript
// Factory handles: list, get, delete, subscribe
const crud = createCrudService<CustomRole>({
  table: 'roles',
  selectClause: '*',
  mapRow: (row) => toRole(row as RoleRow),
  entityName: 'role',
  subscription: {
    channelName: 'roles-all',
    tables: [{ table: 'roles' }],
    shared: true,
  },
});

export const listRoles = crud.list;
export const getRole = crud.get;
export const deleteRole = /* keep custom: checks isRoleInUse first */;
export const subscribeToRoles = crud.subscribe;

// Custom operations remain as explicit functions
export async function roleNameExists(name: string): Promise<boolean> { /* ... */ }
export async function isRoleInUse(roleId: string): Promise<boolean> { /* ... */ }
export async function createRole(...): Promise<CustomRole> { /* ... */ }
export async function updateRole(...): Promise<void> { /* ... */ }
```

### Estimated Line Savings

| File | Before | After (est.) | Savings |
|------|--------|-------------|---------|
| Factory (NEW) | 0 | ~100 | +100 |
| roleService.ts | 246 | ~120 | -126 |
| templateService.ts | 310 | ~180 | -130 |
| userService.ts | 480 | ~360 | -120 |
| activityService.ts | 95 | ~50 | -45 |
| suggestionService.ts | 124 | ~60 | -64 |
| instanceService.ts | 614 | ~480 | -134 |
| profileService.ts | 221 | ~120 | -101 |
| profileTemplateService.ts | 271 | ~150 | -121 |
| index.ts | 100 | ~100 | 0 |
| subscriptionManager.ts | 75 | ~75 | 0 |
| mappers.ts | 276 | ~276 | 0 |
| **Total** | **2,812** | **~2,071** | **~-741** |

Net savings: ~741 lines (~26% reduction). The factory adds 100 lines but eliminates ~841 lines of boilerplate across the 8 services.

### Order of Work
1. Create `src/services/supabase/crudFactory.ts` -- the factory function with tests
2. Refactor `roleService.ts` first (simplest, good validation case)
3. Refactor `activityService.ts` (simplest CRUD, partial operations)
4. Refactor `suggestionService.ts` (simple, standard)
5. Refactor `profileService.ts` (introduces junction table pattern)
6. Refactor `profileTemplateService.ts` (child table + filtered subscription)
7. Refactor `templateService.ts` (child table + template-to-instance sync)
8. Refactor `instanceService.ts` (most complex, last -- has 4 subscription variants)
9. Refactor `userService.ts` (complex with junction tables + auth helpers)
10. Verify all tests pass (`npx vitest run`)
11. Update barrel export if needed

### What to Defer
- Do NOT try to genericize create/update operations -- the unique logic per service makes this a net negative
- Do NOT merge service files -- keeping them separate maintains clarity
- Do NOT refactor the hooks -- they consume the barrel export and are unaffected
- Do NOT change the test mock surface -- the barrel API stays identical
- Consider but defer: a generic `createWithChildRows` helper for the 4 services that insert parent + child rows. This is a secondary optimization that could save ~80 more lines but adds complexity.

## Next Step

**All questions resolved.**
Run `/plan slim-services` to create the implementation plan.
