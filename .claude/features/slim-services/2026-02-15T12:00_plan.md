# Plan: slim-services

## Metadata
- **Feature:** slim-services
- **Created:** 2026-02-15T12:00
- **Status:** plan-complete
- **Based On:** `.claude/features/slim-services/2026-02-15T12:00_research.md`

---

## Architecture Overview

### Goal

Replace duplicated CRUD boilerplate across 8 Supabase service files with a single `createCrudService` factory. The factory handles 4 operations (list, get, remove, subscribe) that are structurally identical across services. Custom operations (create, update, business rules) stay in each service file untouched.

### Before vs After

```
BEFORE (2,561 service lines):
  roleService.ts ......... 246 lines  (list/get/delete/subscribe = ~90 lines boilerplate)
  activityService.ts ..... 95  lines  (list/subscribe = ~55 lines boilerplate)
  suggestionService.ts ... 124 lines  (list/delete/subscribe = ~65 lines boilerplate)
  templateService.ts ..... 310 lines  (list/get/delete/subscribe = ~100 lines boilerplate)
  profileService.ts ...... 221 lines  (list/get/delete/subscribe = ~90 lines boilerplate)
  profileTemplateService . 271 lines  (list/get/delete/subscribe = ~90 lines boilerplate)
  instanceService.ts ..... 614 lines  (list/get/subscribe-all = ~70 lines boilerplate)
  userService.ts ......... 480 lines  (list/get/subscribe = ~70 lines boilerplate)

AFTER (~1,870 service lines + ~120 factory):
  crudFactory.ts ......... ~120 lines (NEW)
  roleService.ts ......... ~155 lines (-91)
  activityService.ts ..... ~40  lines (-55)
  suggestionService.ts ... ~60  lines (-64)
  templateService.ts ..... ~210 lines (-100)
  profileService.ts ...... ~130 lines (-91)
  profileTemplateService . ~180 lines (-91)
  instanceService.ts ..... ~545 lines (-69)
  userService.ts ......... ~410 lines (-70)

  Net savings: ~510 lines from services + ~120 added for factory = ~510 net reduction
```

### Component Diagram

```
src/services/supabase/
 |
 +-- crudFactory.ts              <-- NEW: generic factory
 |     |
 |     +-- uses: supabase client (from ../../config/supabase)
 |     +-- uses: debounce (from ../../utils/debounce)
 |     +-- uses: createSharedSubscription (from ./subscriptionManager) [optional]
 |
 +-- roleService.ts              <-- MODIFIED: uses crudFactory for list/get/subscribe
 +-- activityService.ts          <-- MODIFIED: uses crudFactory for list/subscribe
 +-- suggestionService.ts        <-- MODIFIED: uses crudFactory for list/remove/subscribe
 +-- templateService.ts          <-- MODIFIED: uses crudFactory for list/get/remove/subscribe
 +-- profileService.ts           <-- MODIFIED: uses crudFactory for list/get/remove/subscribe
 +-- profileTemplateService.ts   <-- MODIFIED: uses crudFactory for list/get/remove
 +-- instanceService.ts          <-- MODIFIED: uses crudFactory for list/get/subscribe-all
 +-- userService.ts              <-- MODIFIED: uses crudFactory for list/get/subscribe
 |
 +-- crudFactory.test.ts         <-- NEW: unit tests for factory
 +-- index.ts                    <-- UNCHANGED: barrel export stays identical
 +-- mappers.ts                  <-- UNCHANGED
 +-- subscriptionManager.ts      <-- UNCHANGED
```

### Data Flow (Factory Operations)

```
Consumer (hook/component)
    |
    v
Barrel export (index.ts)   <--- API stays identical
    |
    v
Service file (e.g., roleService.ts)
    |
    +-- crud.list() ---------> crudFactory.list()
    |                              |
    +-- crud.get(id) --------> crudFactory.get()
    |                              |
    +-- crud.remove(id) -----> crudFactory.remove()
    |                              |
    +-- crud.subscribe(cb) --> crudFactory.subscribe()
    |                              |
    +-- createRole(...)        (custom - stays in service file)
    +-- updateRole(...)        (custom - stays in service file)
    +-- roleNameExists(...)    (custom - stays in service file)
    +-- isRoleInUse(...)       (custom - stays in service file)
                                   |
                                   v
                            supabase client (Proxy)
                                   |
                                   v
                            Supabase Postgres
```

---

## Tech Stack Summary

No new dependencies. The factory is pure TypeScript using existing:
- `supabase` client from `../../config/supabase`
- `debounce` from `../../utils/debounce`
- `createSharedSubscription` from `./subscriptionManager` (optional, for shared subscriptions)

---

## Factory Design

### Config Interface

```typescript
interface CrudServiceConfig<TApp> {
  table: string;
  selectClause: string;
  mapRow: (row: any) => TApp;
  entityName: string;
  listLimit?: number;                  // default: 200
  listOrder?: { column: string; ascending: boolean };
  subscription?: {
    channelName: string;
    tables: Array<{
      table: string;
      filter?: string;
    }>;
    shared?: boolean;
  };
}
```

### Return Interface

```typescript
interface CrudService<TApp> {
  list: () => Promise<TApp[]>;
  get: (id: string) => Promise<TApp | null>;
  remove: (id: string) => Promise<void>;
  subscribe: (callback: (items: TApp[]) => void) => () => void;
}
```

### Implementation Details

**`list()`:**
1. Build query: `supabase.from(table).select(selectClause)`
2. Apply optional `.order()` if `listOrder` is set
3. Apply `.limit(listLimit)` (default 200)
4. On error, throw `Failed to fetch ${entityName}s: ${error.message}`
5. Map results via `(data ?? []).map(mapRow)`

**`get(id)`:**
1. Build query: `supabase.from(table).select(selectClause).eq('id', id).single()`
2. If error code `PGRST116`, return `null` (not found)
3. On other error, throw `Failed to fetch ${entityName} ${id}: ${error.message}`
4. Return `data ? mapRow(data) : null`

**`remove(id)`:**
1. `supabase.from(table).delete().eq('id', id)`
2. On error, throw `Failed to delete ${entityName} ${id}: ${error.message}`

**`subscribe(callback)`:**
1. Create debounced re-fetch: `debounce(() => list().then(callback).catch(console.error), 300)`
2. Immediate initial fetch: `list().then(callback).catch(console.error)`
3. Build channel: `supabase.channel(channelName)`
4. For each table in config, chain `.on('postgres_changes', { event: '*', schema: 'public', table, filter? }, () => debouncedRefetch())`
5. Call `.subscribe()` on channel
6. If `shared: true`, wrap with `createSharedSubscription`
7. Return cleanup: `() => { debouncedRefetch.cancel(); supabase.removeChannel(channel); }`

### Key Design Decisions

1. **`mapRow` takes `any`** -- This is pragmatic. The Supabase `.select()` with joins returns dynamic shapes (`*, child_table(*)`). Each service's mapper already handles the type casting. Trying to type this generically would add complexity without practical benefit since the mappers are thoroughly tested.

2. **`remove` instead of `delete`** -- `delete` is a reserved word in JavaScript. Using `remove` avoids syntax issues and is a common convention.

3. **Subscription is a separate concern** -- Not all services use all CRUD operations (activity has no get/delete, suggestion has no get, instance has no delete). The factory returns all 4 operations, but services only re-export the ones they need.

4. **No generic create/update** -- Every service has unique create/update logic (different signatures, child table management, validation, side effects). Trying to genericize these would make the factory harder to understand than the code it replaces.

5. **Shared subscription is opt-in** -- Only roles and templates use `createSharedSubscription`. The factory builds the raw subscription function, then wraps it in shared subscription only if `shared: true`.

---

## File Structure

### New Files

| File | Purpose | Est. Lines |
|------|---------|------------|
| `src/services/supabase/crudFactory.ts` | Generic CRUD+subscribe factory | ~120 |
| `src/services/supabase/crudFactory.test.ts` | Unit tests for factory (list, get, remove, subscribe) | ~250 |

### Modified Files

| File | Changes | Lines Before | Lines After (est.) |
|------|---------|-------------|-------------------|
| `roleService.ts` | Replace list/get/subscribe with factory call. Keep deleteRole (has isRoleInUse check), createRole, updateRole, roleNameExists, isRoleInUse, UUID helper. | 246 | ~155 |
| `activityService.ts` | Replace list/subscribe with factory call. Keep logActivity. | 95 | ~40 |
| `suggestionService.ts` | Replace list/delete/subscribe with factory call. Keep createSuggestion, updateSuggestionStatus. | 124 | ~60 |
| `templateService.ts` | Replace list/get/delete/subscribe with factory call. Keep createTemplate, updateTemplate, syncTemplateStepsToInstances. | 310 | ~210 |
| `profileService.ts` | Replace list/get/delete/subscribe with factory call. Keep createProfile, updateProfile. | 221 | ~130 |
| `profileTemplateService.ts` | Replace list/get/delete with factory call. Keep subscribeToProfileTemplates (has filtered subscription with dynamic profileId), createProfileTemplate, updateProfileTemplate. | 271 | ~180 |
| `instanceService.ts` | Replace list/get/subscribeToOnboardingInstances with factory call. Keep createOnboardingInstance, updateOnboardingInstance, updateStepStatus, createOnboardingRunFromTemplate, OnboardingValidationError, CreateOnboardingRunInput, subscribeToOnboardingInstance, subscribeToSteps, subscribeToEmployeeInstance. | 614 | ~545 |
| `userService.ts` | Replace list/get/subscribe with factory call. Keep createUser, updateUser, deleteUser (has auth cleanup), all auth credential helpers, test helpers, logActivity delegation. | 480 | ~410 |

### Unchanged Files

| File | Reason |
|------|--------|
| `src/services/supabase/index.ts` | Barrel export API must not change |
| `src/services/supabase/mappers.ts` | Mappers are consumed by factory config, not changed |
| `src/services/supabase/mappers.test.ts` | No changes to mappers |
| `src/services/supabase/subscriptionManager.ts` | Used by factory, not changed |
| `src/services/supabase/subscriptionManager.test.ts` | No changes to subscription manager |
| All consumer files (hooks, components) | Barrel API unchanged |
| All existing test files | Mock the barrel, which is unchanged |

---

## Per-Service Refactoring Details

### 1. roleService.ts

**Factory operations:** `list`, `get`, `subscribe`
**Custom (kept):** `deleteRole` (has isRoleInUse pre-check), `createRole`, `updateRole`, `roleNameExists`, `isRoleInUse`, `isValidUUID`

```typescript
const crud = createCrudService<CustomRole>({
  table: 'roles',
  selectClause: '*',
  mapRow: (row) => toRole(row as RoleRow),
  entityName: 'role',
  subscription: {
    channelName: 'roles-all',
    tables: [{ table: 'roles' }],
    shared: true,
  },
});

export const listRoles = crud.list;
export const getRole = crud.get;
// deleteRole is CUSTOM (checks isRoleInUse first)
// subscribeToRoles uses crud.subscribe wrapped in createSharedSubscription
```

Note: `deleteRole` cannot use `crud.remove` because it calls `isRoleInUse()` first. The subscription uses `shared: true` which wraps it in `createSharedSubscription`.

### 2. activityService.ts

**Factory operations:** `list`, `subscribe`
**Custom (kept):** `logActivity`
**Not applicable:** `get`, `remove` (activity has no get/delete)

```typescript
const crud = createCrudService<Activity>({
  table: 'activities',
  selectClause: '*',
  mapRow: (row) => toActivity(row as ActivityRow),
  entityName: 'activity',
  listLimit: 50,
  listOrder: { column: 'timestamp', ascending: false },
  subscription: {
    channelName: 'activities-all',
    tables: [{ table: 'activities' }],
  },
});

export const listActivities = crud.list;
export const subscribeToActivities = crud.subscribe;
```

### 3. suggestionService.ts

**Factory operations:** `list`, `remove`, `subscribe`
**Custom (kept):** `createSuggestion`, `updateSuggestionStatus`
**Not applicable:** `get` (suggestion has no get)

```typescript
const crud = createCrudService<Suggestion>({
  table: 'suggestions',
  selectClause: '*',
  mapRow: (row) => toSuggestion(row as SuggestionRow),
  entityName: 'suggestion',
  subscription: {
    channelName: 'suggestions-all',
    tables: [{ table: 'suggestions' }],
  },
});

export const listSuggestions = crud.list;
export const deleteSuggestion = crud.remove;
export const subscribeToSuggestions = crud.subscribe;
```

### 4. templateService.ts

**Factory operations:** `list`, `get`, `remove`, `subscribe`
**Custom (kept):** `createTemplate`, `updateTemplate`, `syncTemplateStepsToInstances`

```typescript
const crud = createCrudService<Template>({
  table: 'templates',
  selectClause: '*, template_steps(*)',
  mapRow: (row: any) =>
    toTemplate(row as TemplateRow, (row.template_steps ?? []) as TemplateStepRow[]),
  entityName: 'template',
  subscription: {
    channelName: 'templates-all',
    tables: [{ table: 'templates' }, { table: 'template_steps' }],
    shared: true,
  },
});

export const listTemplates = crud.list;
export const getTemplate = crud.get;
export const deleteTemplate = crud.remove;
// subscribeToTemplates uses crud.subscribe wrapped in createSharedSubscription
```

### 5. profileService.ts

**Factory operations:** `list`, `get`, `remove`, `subscribe`
**Custom (kept):** `createProfile`, `updateProfile`

```typescript
const crud = createCrudService<Profile>({
  table: 'profiles',
  selectClause: '*, profile_role_tags(*)',
  mapRow: (row: any) =>
    toProfile(row as ProfileRow, (row.profile_role_tags ?? []) as ProfileRoleTagRow[]),
  entityName: 'profile',
  subscription: {
    channelName: 'profiles-all',
    tables: [{ table: 'profiles' }, { table: 'profile_role_tags' }],
  },
});

export const listProfiles = crud.list;
export const getProfile = crud.get;
export const deleteProfile = crud.remove;
export const subscribeToProfiles = crud.subscribe;
```

### 6. profileTemplateService.ts

**Factory operations:** `list` (partial -- has optional filter), `get`, `remove`
**Custom (kept):** `listProfileTemplates` (has optional `profileId` filter -- factory list is too simple), `subscribeToProfileTemplates` (has dynamic channel name and filter per profileId), `createProfileTemplate`, `updateProfileTemplate`

Decision: `listProfileTemplates` has an optional filter parameter that the factory's simple `list()` cannot handle. Two approaches:

- **Option A:** Keep `listProfileTemplates` custom, only use factory for `get` and `remove`.
- **Option B:** Use the factory's `list()` internally as the "list all" path and add the filter logic on top.

Going with **Option A** -- the filter is core to how this service is used, and wrapping the factory would be more confusing than keeping the explicit code. The factory still saves lines on `get` and `remove`.

```typescript
const crud = createCrudService<ProfileTemplate>({
  table: 'profile_templates',
  selectClause: '*, profile_template_steps(*)',
  mapRow: (row: any) =>
    toProfileTemplate(
      row as ProfileTemplateRow,
      (row.profile_template_steps ?? []) as ProfileTemplateStepRow[]
    ),
  entityName: 'profile template',
});

export const getProfileTemplate = crud.get;
export const deleteProfileTemplate = crud.remove;
// listProfileTemplates: CUSTOM (has optional profileId filter)
// subscribeToProfileTemplates: CUSTOM (has dynamic channel name + filter)
```

### 7. instanceService.ts

**Factory operations:** `list`, `get`
**Custom (kept):** `createOnboardingInstance`, `updateOnboardingInstance`, `updateStepStatus`, `createOnboardingRunFromTemplate`, `OnboardingValidationError`, `CreateOnboardingRunInput`, `subscribeToOnboardingInstance`, `subscribeToSteps`, `subscribeToOnboardingInstances`, `subscribeToEmployeeInstance`

Decision: instanceService has 4 different subscribe functions with different signatures. The `subscribeToOnboardingInstances` (list-all) could use the factory, but for consistency with the other 3 custom subscriptions and because the savings are minimal (~25 lines), it is simpler to keep all 4 subscriptions custom. The factory saves the most on the `list` and `get` functions.

```typescript
const crud = createCrudService<OnboardingInstance>({
  table: 'onboarding_instances',
  selectClause: '*, instance_steps(*)',
  mapRow: (row: any) =>
    toInstance(row as InstanceRow, (row.instance_steps ?? []) as InstanceStepRow[]),
  entityName: 'onboarding instance',
});

export const listOnboardingInstances = crud.list;
export const getOnboardingInstance = crud.get;
// All 4 subscribe functions: CUSTOM
// create, update, stepStatus, runFromTemplate: CUSTOM
```

Wait -- `subscribeToOnboardingInstances` (the list-all subscription) *does* follow the standard pattern: debounce + listOnboardingInstances + 2 tables. The factory's `subscribe` can handle this. Let me reconsider.

Revised decision: Use factory for `list`, `get`, and `subscribeToOnboardingInstances`. Keep the 3 specialized subscriptions custom.

```typescript
const crud = createCrudService<OnboardingInstance>({
  table: 'onboarding_instances',
  selectClause: '*, instance_steps(*)',
  mapRow: (row: any) =>
    toInstance(row as InstanceRow, (row.instance_steps ?? []) as InstanceStepRow[]),
  entityName: 'onboarding instance',
  subscription: {
    channelName: 'instances-all',
    tables: [{ table: 'onboarding_instances' }, { table: 'instance_steps' }],
  },
});

export const listOnboardingInstances = crud.list;
export const getOnboardingInstance = crud.get;
export const subscribeToOnboardingInstances = crud.subscribe;
```

### 8. userService.ts

**Factory operations:** `list`, `get`, `subscribe`
**Custom (kept):** `createUser`, `updateUser`, `deleteUser` (has auth credential cleanup), `userEmailExists`, all auth credential helpers, test helpers, `logActivity`

```typescript
const crud = createCrudService<User>({
  table: 'users',
  selectClause: '*, user_roles(*), user_profiles(*)',
  mapRow: (row: any) =>
    toUser(
      row as UserRow,
      (row.user_roles ?? []) as UserRoleRow[],
      (row.user_profiles ?? []) as UserProfileRow[]
    ),
  entityName: 'user',
  subscription: {
    channelName: 'users-all',
    tables: [{ table: 'users' }, { table: 'user_roles' }, { table: 'user_profiles' }],
  },
});

export const listUsers = crud.list;
export const getUser = crud.get;
export const subscribeToUsers = crud.subscribe;
// deleteUser: CUSTOM (fetches user for email, then removes auth credentials)
```

---

## Testing Strategy

### Factory Tests (`crudFactory.test.ts`) -- ~20 tests

Unit tests that mock the Supabase client to verify factory behavior:

**`list()`:**
- Returns mapped results from Supabase query
- Applies selectClause correctly
- Applies limit (default 200)
- Applies custom limit
- Applies ordering when configured
- Throws on Supabase error
- Returns empty array when data is null

**`get(id)`:**
- Returns mapped result for existing ID
- Returns null for PGRST116 (not found)
- Throws on other Supabase errors
- Returns null when data is null

**`remove(id)`:**
- Calls delete on correct table with ID
- Throws on Supabase error

**`subscribe(callback)`:**
- Performs initial fetch immediately
- Sets up channel with correct tables
- Debounces re-fetches on change events
- Returns cleanup function that cancels debounce and removes channel
- Handles multi-table listening
- Works with shared subscription when configured

### Existing Tests (696 tests) -- Must All Pass

The existing 696 tests mock `./supabase` (the barrel). Since the barrel's exported function names and signatures remain identical, all tests should continue to pass without modification.

**Verification strategy:**
1. After each service refactoring, run `npx vitest run` to confirm no regressions
2. Final run after all services are refactored

### Integration Verification

After implementation, verify with Playwright MCP in browser:
- Create a role
- Create a template
- Create an onboarding instance from template
- Verify real-time updates flow through

---

## Implementation Notes

### Decisions

1. **Factory returns all 4 operations unconditionally** -- Services only export/use what they need. This keeps the factory simple (no conditional return types).

2. **`shared` subscription handling** -- When `shared: true`, the factory builds the raw subscription function, then wraps it with `createSharedSubscription` internally. The caller gets back the shared version. This means services using shared subscriptions (role, template) do NOT need to import `createSharedSubscription` themselves.

3. **`mapRow` receives `any`** -- The factory does `(data ?? []).map(mapRow)` for list and `data ? mapRow(data) : null` for get. The `mapRow` function handles all type casting internally. This mirrors how the services already work.

4. **Order of refactoring** -- Start with the simplest services (activity, suggestion) to validate the factory, then move to medium complexity (role, profile), then complex (template, profileTemplate, instance, user). This creates confidence progressively.

5. **profileTemplateService.listProfileTemplates keeps custom list** -- It has an optional `profileId` parameter that adds a conditional `.eq()` to the query. The factory's `list()` does not support runtime filter parameters. Making it support this would over-complicate the factory for a single use case.

6. **instanceService keeps 3 of 4 subscription functions custom** -- `subscribeToOnboardingInstance`, `subscribeToSteps`, and `subscribeToEmployeeInstance` all have unique signatures (take an ID/email parameter, use filtered channels). Only `subscribeToOnboardingInstances` (list-all) uses the factory.

7. **roleService.deleteRole stays custom** -- It calls `isRoleInUse()` before deleting. The factory's `remove` does a straight delete with no pre-checks.

8. **userService.deleteUser stays custom** -- It fetches the user to get their email, deletes them, then removes auth credentials from localStorage.

### Patterns to Preserve

- Lazy-init Supabase client (Proxy) -- factory imports from same `../../config/supabase`
- Debounce 300ms for all subscriptions -- factory uses same `debounce` utility
- `createSharedSubscription` reference counting -- factory wraps with it when `shared: true`
- Error message format: `Failed to ${verb} ${entityName}: ${error.message}`
- PGRST116 handling in `get()` -- return null instead of throwing

### Trade-offs

| Decision | Pro | Con |
|----------|-----|-----|
| `mapRow: any` | Simple, matches existing code | No compile-time type safety on raw rows |
| Factory returns all 4 ops | Simple factory, no conditional types | Services may import unused ops |
| No generic create/update | Keeps custom logic readable | Less line savings |
| Keep 8 separate files | Clear ownership, easy to find | More files to maintain |

---

## Non-Goals

Things we are explicitly NOT doing in this feature:

1. **Not genericizing create/update operations** -- Each service has unique signatures, field mappings, child table management, and side effects. A generic create/update would be harder to understand than the current code.
2. **Not merging service files** -- Each file maps to one entity. Keeping them separate maintains clarity.
3. **Not changing the barrel export API** -- Consumers (hooks, components) must not be touched.
4. **Not refactoring hooks or components** -- They consume the barrel and are unaffected.
5. **Not changing the test mock surface** -- Tests mock the barrel. Since the barrel API is unchanged, tests should pass as-is.
6. **Not adding a `createWithChildRows` helper** -- This was considered for the 4 services that insert parent + child rows, but deferred. It would save ~80 more lines but adds another abstraction layer. Can be done in a future pass.
7. **Not changing subscription manager** -- It works correctly and is used by the factory as-is.
8. **Not adding new test infrastructure** -- Using existing Vitest + vi.mock patterns.
