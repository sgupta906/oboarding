# Plan: supabase-setup

## Metadata
- **Feature:** supabase-setup
- **Created:** 2026-02-14T03:15
- **Status:** plan-complete
- **Based On:** 2026-02-14T03:00_research.md
- **Migration Step:** 1 of 5

---

## Architecture Overview

This step creates the Supabase infrastructure layer parallel to the existing Firebase setup. No existing application code is modified. The Firebase services remain fully functional.

```
BEFORE (current state):
+---------------------+
|    React App        |
|  (Vite + TS + TW)   |
+----------+----------+
           |
   src/config/firebase.ts
           |
  +--------v--------+
  |    Firebase      |
  |  Auth + Firestore|
  |  + Storage       |
  +-----------------+

AFTER this step (coexistence):
+---------------------+
|    React App        |
|  (Vite + TS + TW)   |
+---+-------------+---+
    |             |
firebase.ts   supabase.ts  <-- NEW (not wired to app yet)
    |             |
+---v---+   +----v----+
|Firebase|   |Supabase |  <-- NEW (schema ready, not used yet)
| (live) |   |(standby)|
+-------+   +---------+
```

### What Gets Created

```
New infrastructure (no app code changes):

  supabase/
    migrations/
      00001_create_core_tables.sql      -- 8 core tables
      00002_create_step_tables.sql      -- 3 step child tables
      00003_create_junction_tables.sql  -- 5 junction tables
      00004_create_indexes.sql          -- Performance indexes
      00005_enable_rls.sql              -- RLS + permissive policies
      00006_create_triggers.sql         -- updated_at triggers

  src/
    config/
      supabase.ts                       -- Client init (parallel to firebase.ts)
      supabase.test.ts                  -- Unit tests for config
    types/
      database.types.ts                 -- TypeScript DB types

  .env.template                         -- Updated with Supabase vars (appended)
```

---

## Tech Stack Summary

| Component | Current | Added by This Step |
|-----------|---------|-------------------|
| Runtime | React 18 + Vite 7 + TypeScript 5.5 | No change |
| Database | Firebase Firestore | + Supabase (Postgres) |
| Auth | Firebase Auth | No change (step 3) |
| Client SDK | `firebase@12.6.0` | + `@supabase/supabase-js@2.x` |
| Testing | Vitest 4.0 + RTL | No change |
| CSS | Tailwind CSS 3.4 | No change |

---

## File Structure

### New Files to Create

| # | File | Purpose | Lines (est.) |
|---|------|---------|-------------|
| 1 | `supabase/migrations/00001_create_core_tables.sql` | 8 core tables (users, roles, profiles, templates, profile_templates, onboarding_instances, suggestions, activities) | ~120 |
| 2 | `supabase/migrations/00002_create_step_tables.sql` | 3 step child tables (template_steps, instance_steps, profile_template_steps) | ~70 |
| 3 | `supabase/migrations/00003_create_junction_tables.sql` | 5 junction tables (user_roles, user_profiles, profile_role_tags, instance_profiles, instance_template_refs) | ~50 |
| 4 | `supabase/migrations/00004_create_indexes.sql` | Performance indexes for common query patterns | ~25 |
| 5 | `supabase/migrations/00005_enable_rls.sql` | Enable RLS on all 16 tables + permissive policies | ~70 |
| 6 | `supabase/migrations/00006_create_triggers.sql` | updated_at auto-update function + triggers | ~30 |
| 7 | `src/config/supabase.ts` | Supabase client initialization with env vars | ~20 |
| 8 | `src/config/supabase.test.ts` | Unit tests for Supabase config | ~70 |
| 9 | `src/types/database.types.ts` | TypeScript types for all 16 database tables | ~350 |

### Files to Modify

| # | File | Change | Lines Affected |
|---|------|--------|---------------|
| 1 | `.env.template` | Append Supabase env vars (3 new lines + comment block) | Append at end |

### Files NOT Modified (explicit)

- `src/config/firebase.ts` - No changes
- `src/services/dataClient.ts` - No changes (step 2)
- `src/services/authService.ts` - No changes (step 3)
- `src/types/index.ts` - No changes (app types stay separate from DB types)
- `package.json` - Modified only by `npm install` command
- `package-lock.json` - Modified only by `npm install` command

---

## Database Schema Design

### Entity Relationship Diagram (ASCII)

```
                         +-------------+
                         |    users    |
                         +------+------+
                           |    |    |
              +------------+    |    +------------+
              |                 |                 |
        +-----v-----+    +-----v-----+    +------v------+
        | user_roles |    |user_profiles|  |   roles     |
        +-----------+    +-----------+    +------+------+
                                                  |
                                           (name ref)
                                                  |
        +------------+    +----------+    +-------v------+
        |  profiles  +----+profile   |    |  templates   |
        +-----+------+   |role_tags |    +------+-------+
              |           +----------+          |
        +-----v---------+              +--------v---------+
        |profile_templates|            | template_steps   |
        +-----+---------+             +------------------+
              |
   +----------v--------------+
   |profile_template_steps   |
   +-------------------------+

        +---------------------+
        |onboarding_instances |
        +-+-------+--------+-+
          |       |        |
   +------v--+ +-v------+ +v------------------+
   |instance | |instance| |instance_template   |
   |_steps   | |profiles| |_refs               |
   +---------+ +--------+ +-------------------+

        +-------------+     +-------------+
        | suggestions |     | activities  |
        +-------------+     +-------------+
```

### Table Specifications

**Total: 16 tables** (8 core + 3 step child + 5 junction)

#### Core Tables (8)

**1. users** - System users (employees, managers, admins)
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL,
  CONSTRAINT users_email_unique UNIQUE (lower(email))
);
```

**2. roles** - Custom role definitions
```sql
CREATE TABLE roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL,
  CONSTRAINT roles_name_unique UNIQUE (lower(name))
);
```

**3. profiles** - Department/role profiles
```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL
);
```

**4. templates** - Onboarding templates
```sql
CREATE TABLE templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  role TEXT NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
```

**5. profile_templates** - Profile-specific templates
```sql
CREATE TABLE profile_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  version INTEGER NOT NULL DEFAULT 1,
  is_published BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL
);
```

**6. onboarding_instances** - Active onboarding runs
```sql
CREATE TABLE onboarding_instances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  employee_name TEXT NOT NULL,
  employee_email TEXT NOT NULL,
  role TEXT NOT NULL,
  department TEXT NOT NULL,
  template_id UUID REFERENCES templates(id) ON DELETE SET NULL,
  progress INTEGER NOT NULL DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'completed', 'on_hold')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  start_date TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  template_snapshots JSONB
);
```

**7. suggestions** - Step feedback/suggestions
```sql
CREATE TABLE suggestions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  step_id INTEGER NOT NULL,
  user_name TEXT NOT NULL,
  text TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'reviewed', 'implemented')),
  created_at TIMESTAMPTZ DEFAULT now(),
  instance_id UUID REFERENCES onboarding_instances(id) ON DELETE SET NULL
);
```

**8. activities** - Audit trail
```sql
CREATE TABLE activities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_initials TEXT NOT NULL,
  action TEXT NOT NULL,
  time_ago TEXT,
  timestamp TIMESTAMPTZ DEFAULT now(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  resource_type TEXT,
  resource_id TEXT
);
```

#### Step Child Tables (3)

All three step tables share an identical column structure. They are separate tables because they have different parent foreign keys and different CASCADE behaviors.

```sql
-- Columns shared by all step tables:
--   id UUID PRIMARY KEY
--   <parent>_id UUID NOT NULL REFERENCES <parent>(id) ON DELETE CASCADE
--   position INTEGER NOT NULL (ordering, was step.id in Firestore)
--   title TEXT NOT NULL
--   description TEXT NOT NULL DEFAULT ''
--   role TEXT NOT NULL DEFAULT 'All'
--   owner TEXT NOT NULL DEFAULT ''
--   expert TEXT NOT NULL DEFAULT ''
--   status TEXT NOT NULL DEFAULT 'pending' CHECK (...)
--   link TEXT DEFAULT ''
--   UNIQUE (<parent>_id, position)
```

**9. template_steps** - parent: templates
**10. instance_steps** - parent: onboarding_instances
**11. profile_template_steps** - parent: profile_templates

#### Junction Tables (5)

**12. user_roles** - PK(user_id, role_name) - User.roles[]
**13. user_profiles** - PK(user_id, profile_name) - User.profiles[]
**14. profile_role_tags** - PK(profile_id, role_tag) - Profile.roleTags[]
**15. instance_profiles** - PK(instance_id, profile_id) - OnboardingInstance.profileIds[]
**16. instance_template_refs** - PK(instance_id, template_id) - OnboardingInstance.templateIds[]

### Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Steps storage | Child tables (not JSONB) | Steps are queried/updated individually; JSONB would require read-modify-write |
| templateSnapshots | JSONB column | Write-once, read-whole-blob; never individually queried |
| Role references in steps | Name strings (TEXT) | Matches current behavior; changing to FK would require UI refactoring (out of scope) |
| Primary keys | UUID via gen_random_uuid() | Standard Supabase pattern; replaces Firestore auto-IDs |
| Timestamps | TIMESTAMPTZ with DEFAULT now() | Native Postgres type; conversion from Unix timestamps happens during data migration (step 2) |
| Step ordering | UUID PK + position column | Most flexible; supports reordering without PK changes |
| Suggestion.user | user_name TEXT (not FK) | Matches current behavior of storing display name |
| Activity.timeAgo | Stored TEXT field | Matches current behavior; computed approach deferred |

### Indexes

```
Performance indexes (13 total):
  - onboarding_instances: employee_email (lower), template_id, status
  - suggestions: instance_id
  - activities: timestamp DESC, user_id
  - template_steps: template_id
  - instance_steps: instance_id, status
  - profile_templates: profile_id
  - profile_template_steps: profile_template_id
  - user_roles: user_id
  - user_profiles: user_id
```

### RLS Strategy

For Step 1, all tables get:
1. RLS enabled (`ALTER TABLE ... ENABLE ROW LEVEL SECURITY`)
2. A single permissive policy per table: `FOR ALL USING (true) WITH CHECK (true)`

This mirrors the current Firestore rules (`allow read, write: if true`) and will be tightened in Step 3 (supabase-auth) when Supabase Auth is integrated.

### Triggers

An `update_updated_at()` function is created once and applied to the 5 tables that have an `updated_at` column:
- users
- roles
- templates
- profile_templates
- onboarding_instances

---

## Component Architecture

### Supabase Client (`src/config/supabase.ts`)

```
src/config/supabase.ts
  |
  +-- Reads env vars: VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY
  |
  +-- Validates env vars are present (throws if missing)
  |
  +-- Creates typed Supabase client: createClient<Database>(url, key)
  |
  +-- Exports: { supabase }
```

Pattern mirrors `src/config/firebase.ts`:
- Both read from `VITE_*` env vars
- Both validate configuration
- Both export a configured client instance
- Both are tested with similar test patterns

### TypeScript Database Types (`src/types/database.types.ts`)

This file defines the `Database` interface that provides type safety for all Supabase queries. Structure:

```typescript
Database {
  public: {
    Tables: {
      users: { Row, Insert, Update }
      roles: { Row, Insert, Update }
      profiles: { Row, Insert, Update }
      templates: { Row, Insert, Update }
      profile_templates: { Row, Insert, Update }
      onboarding_instances: { Row, Insert, Update }
      suggestions: { Row, Insert, Update }
      activities: { Row, Insert, Update }
      template_steps: { Row, Insert, Update }
      instance_steps: { Row, Insert, Update }
      profile_template_steps: { Row, Insert, Update }
      user_roles: { Row, Insert, Update }
      user_profiles: { Row, Insert, Update }
      profile_role_tags: { Row, Insert, Update }
      instance_profiles: { Row, Insert, Update }
      instance_template_refs: { Row, Insert, Update }
    }
  }
}
```

Each table's `Row` type represents a fully-loaded row. `Insert` makes optional fields (with defaults) optional. `Update` makes all fields optional (partial updates).

---

## Testing Strategy

### Unit Tests (1 test file, ~6-8 test cases)

**File:** `src/config/supabase.test.ts`

Tests mirror the pattern established in `src/config/firebase.test.ts`:

| # | Test Case | What It Validates |
|---|-----------|-------------------|
| 1 | Supabase SDK package is importable | `@supabase/supabase-js` installed correctly |
| 2 | `createClient` function exists | SDK exports expected API |
| 3 | Config module exports `supabase` client | Module structure is correct |
| 4 | Client has expected methods (from, auth, etc.) | Client initialized properly |
| 5 | Throws when VITE_SUPABASE_URL is missing | Env var validation works |
| 6 | Throws when VITE_SUPABASE_ANON_KEY is missing | Env var validation works |
| 7 | Database types are importable | TypeScript types file is valid |
| 8 | Database types have expected table names | Type structure is correct |

### SQL Validation (Manual/CI -- not automated in Vitest)

The SQL migrations will be validated by:
1. SQL syntax correctness (parseable)
2. Consistent naming conventions (snake_case)
3. All FK references are valid
4. All CHECK constraints use correct values
5. All UNIQUE constraints match requirements

### Integration Tests

No integration tests in this step. Integration with a running Supabase instance will be tested in Step 2 (supabase-data-layer).

### E2E Tests

No E2E tests in this step. The Supabase infrastructure is not wired to the application.

---

## Implementation Notes

### Pattern: Parallel Config Files

The Supabase config follows the same export pattern as Firebase:

```
firebase.ts:  export { app, auth, firestore, storage }
supabase.ts:  export { supabase }
```

Supabase is simpler because it uses a single client for all services (database, auth, storage, realtime) rather than separate service instances.

### Pattern: Environment Variable Naming

Following Vite convention (must use `VITE_` prefix for client-side access):

```
Firebase: VITE_FIREBASE_*
Supabase: VITE_SUPABASE_*
```

### Migration File Naming

Using `00001_` through `00006_` numeric prefix convention (Supabase CLI standard). Files are executed in order. Each migration is idempotent where possible (using `IF NOT EXISTS` for tables, functions).

### TypeScript Types: Manual vs Generated

The research suggests using `supabase gen types typescript` to generate types. However, since we may not have a running Supabase instance during development, we will:

1. Write the types manually in `src/types/database.types.ts` to match the SQL schema exactly
2. Document how to regenerate them from a live database
3. The manual types follow the same structure as `supabase gen types typescript` output

This approach ensures types are available immediately without requiring a running database.

### Constraint: No Circular Import Risk

`src/config/supabase.ts` imports only from `@supabase/supabase-js` and `../types/database.types`. It does not import from any existing application code, so there is zero risk of circular dependencies.

---

## Non-Goals (Explicitly Out of Scope)

1. **Wiring Supabase to the React app** -- No components, hooks, or services import supabase.ts
2. **Data migration from Firestore** -- No data copying; schema only
3. **Granular RLS policies** -- All policies are permissive; tightened in Step 3
4. **Supabase Auth configuration** -- Deferred to Step 3
5. **Realtime channel setup** -- Deferred to Step 4
6. **Supabase Storage setup** -- Deferred; minimal usage currently
7. **Removing Firebase dependencies** -- Deferred to Step 5 (cleanup)
8. **Supabase CLI local dev environment** -- Optional; migrations work with hosted Supabase too
9. **Seed data** -- No default data inserted; clean schema only
10. **Modifying any existing `.ts` or `.tsx` files** -- Strict constraint

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| npm install conflicts with existing deps | `@supabase/supabase-js` has no peer dependency conflicts with Firebase or React 18 |
| SQL migration errors on first run | Each migration uses `IF NOT EXISTS` guards; idempotent by design |
| TypeScript type drift from SQL schema | Manual types are written to exactly match SQL; documented regeneration process |
| Env var conflicts | Supabase vars use distinct `VITE_SUPABASE_*` prefix; no overlap with `VITE_FIREBASE_*` |
| Import side effects | `supabase.ts` is never imported by any existing code; no side effects possible |

---

## Next Step

After implementation is complete, run `/test supabase-setup` to validate:
- All existing tests still pass (no regressions)
- New Supabase config tests pass
- SQL migration files are syntactically valid
- TypeScript types compile without errors
- Build succeeds (`tsc -b && vite build`)
