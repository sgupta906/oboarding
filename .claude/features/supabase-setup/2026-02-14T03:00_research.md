# Research: supabase-setup

## Metadata
- **Feature:** supabase-setup
- **Created:** 2026-02-14T03:00
- **Status:** research-complete
- **Researcher:** research-agent
- **Migration Step:** 1 of 5 (supabase-setup -> supabase-data-layer -> supabase-auth -> supabase-realtime -> cleanup)

## Feature Context

This is Step 1 of a 5-step migration from Firebase (Auth + Firestore + Storage) to Supabase. This step focuses exclusively on:

1. Installing the Supabase JS client
2. Creating the Supabase connection config file
3. Designing and creating the Postgres database schema (SQL migrations)
4. Translating Firestore's document/embedded-array model to proper relational tables
5. Setting up basic Row Level Security (RLS) policies
6. Configuring environment variables

This step does NOT modify any existing application code. The Firebase services remain fully functional. The goal is to have the Supabase database schema ready so that subsequent steps (data-layer, auth, realtime) can consume it.

### Dependencies
- None (this is the first step)
- Requires a Supabase project to be created (can be local via Supabase CLI or hosted)

### What depends on this
- `supabase-data-layer` - needs the schema and client to replace dataClient.ts
- `supabase-auth` - needs the users table and auth config
- `supabase-realtime` - needs the tables with realtime enabled

---

## Requirements

### Functional Requirements
- [ ] FR1: Install `@supabase/supabase-js` package (source: migration plan)
- [ ] FR2: Create `src/config/supabase.ts` - Supabase client initialization with env vars (source: migration plan, mirrors firebase.ts pattern)
- [ ] FR3: Create SQL migration(s) for all 8 Firestore collections translated to Postgres tables (source: migration plan)
- [ ] FR4: Normalize embedded arrays (steps[], roleTags[], roles[], profiles[], profileIds[], templateIds[]) into proper relational structures (source: data model analysis)
- [ ] FR5: Create foreign key relationships between tables (source: data model analysis)
- [ ] FR6: Set up basic RLS policies - at minimum enable RLS on all tables (source: migration plan)
- [ ] FR7: Update `.env.template` with Supabase env vars alongside existing Firebase vars (source: migration plan)
- [ ] FR8: Create TypeScript types for database schema (generated or manual) (source: best practice)

### Technical Requirements
- [ ] TR1: Schema must support all current CRUD operations documented in dataClient.ts (2084 lines of operations)
- [ ] TR2: Schema must preserve all data relationships currently implicit in Firestore's document model
- [ ] TR3: Migration SQL must be idempotent (safe to run multiple times)
- [ ] TR4: UUID primary keys for all tables (standard Supabase pattern, replaces Firestore's auto-generated string IDs)
- [ ] TR5: Timestamps should use `timestamptz` type (not Unix integers) -- but add helper to convert from existing Unix timestamps during data migration
- [ ] TR6: Vite env vars must use `VITE_` prefix for client-side access (matches existing pattern)

### Constraints
- Must NOT break existing Firebase functionality (coexistence during migration)
- Must NOT modify any existing `.ts`/`.tsx` files
- SQL migrations should live in `supabase/migrations/` directory (Supabase CLI convention)

---

## Existing Code Analysis

### Project State
- **Project exists:** YES - fully functional React+Vite+TypeScript app with Firebase
- **Tech stack:** React 18, Vite 7, TypeScript 5.5, Firebase 12.6, Tailwind CSS 3.4
- **Test framework:** Vitest 4.0 with React Testing Library
- **Current database:** Firebase Firestore (with extensive localStorage fallback)
- **Current auth:** Firebase Auth (with localStorage mock fallback)

### Firestore Collections (7 collections + 1 auth-specific)

The application uses these Firestore collections, identified from `dataClient.ts` collection constants (lines 37-43) and `userOperations.ts`:

| # | Collection Name | TypeScript Type | Key Characteristics |
|---|----------------|-----------------|---------------------|
| 1 | `templates` | `Template` | Has embedded `steps: Step[]` array |
| 2 | `onboarding_instances` | `OnboardingInstance` | Has embedded `steps: Step[]`, `profileIds: string[]`, `templateIds: string[]`, `templateSnapshots: {}` |
| 3 | `suggestions` | `Suggestion` | References stepId and instanceId |
| 4 | `activities` | `Activity` | Audit trail entries |
| 5 | `roles` | `CustomRole` | Custom role definitions |
| 6 | `profiles` | `Profile` | Has embedded `roleTags: string[]` |
| 7 | `profileTemplates` | `ProfileTemplate` | Has embedded `steps: Step[]`, references profileId |
| 8 | `users` | `User` (+ `FirestoreUser` for auth) | Has embedded `roles: string[]`, `profiles: string[]` |

### Detailed Type Analysis

#### 1. Template (src/types/index.ts:243-252)
```typescript
interface Template {
  id: string;
  name: string;
  description: string;
  role: string;           // Role name (e.g., 'Engineering')
  steps: Step[];          // EMBEDDED ARRAY - needs child table
  createdAt: number;      // Unix timestamp
  updatedAt?: number;
  isActive: boolean;
}
```

#### 2. OnboardingInstance (src/types/index.ts:258-283)
```typescript
interface OnboardingInstance {
  id: string;
  employeeName: string;
  employeeEmail: string;
  role: string;
  department: string;
  templateId: string;         // FK to templates
  steps: Step[];              // EMBEDDED ARRAY - needs child table
  createdAt: number;
  startDate?: number;
  completedAt?: number;
  progress: number;           // 0-100
  status: 'active' | 'completed' | 'on_hold';
  profileIds?: string[];      // EMBEDDED ARRAY - needs junction table
  templateIds?: string[];     // EMBEDDED ARRAY - needs junction table
  templateSnapshots?: {       // EMBEDDED MAP - needs child table
    [templateId: string]: {
      profileId: string;
      steps: Step[];
      templateName: string;
      capturedAt: number;
    };
  };
}
```

#### 3. Step (embedded, not a collection - src/types/index.ts:117-126)
```typescript
interface Step {
  id: number;              // Sequential integer within parent
  title: string;
  description: string;
  role: string;
  owner: string;
  expert: string;
  status: StepStatus;      // 'pending' | 'completed' | 'stuck'
  link: string;
}
```

#### 4. Suggestion (src/types/index.ts:137-145)
```typescript
interface Suggestion {
  id: number | string;     // Mixed type!
  stepId: number;
  user: string;            // User name (not ID)
  text: string;
  status: SuggestionStatus; // 'pending' | 'reviewed' | 'implemented'
  createdAt?: number;
  instanceId?: string;     // FK to onboarding_instances
}
```

#### 5. Activity (src/types/index.ts:228-237)
```typescript
interface Activity {
  id: string;
  userInitials: string;
  action: string;
  timeAgo: string;
  timestamp?: number;
  userId?: string;
  resourceType?: string;
  resourceId?: string;
}
```

#### 6. CustomRole (src/types/index.ts:18-25)
```typescript
interface CustomRole {
  id: string;
  name: string;            // Unique, case-insensitive
  description?: string;
  createdAt: number;
  updatedAt: number;
  createdBy: string;       // FK to users
}
```

#### 7. Profile (src/types/index.ts:40-47)
```typescript
interface Profile {
  id: string;
  name: string;
  description?: string;
  roleTags: string[];      // EMBEDDED ARRAY - needs junction table
  createdAt: number;
  createdBy: string;       // FK to users
}
```

#### 8. ProfileTemplate (src/types/index.ts:54-65)
```typescript
interface ProfileTemplate {
  id: string;
  profileId: string;       // FK to profiles
  name: string;
  description?: string;
  steps: Step[];           // EMBEDDED ARRAY - needs child table
  createdAt: number;
  updatedAt?: number;
  createdBy: string;       // FK to users
  version: number;
  isPublished: boolean;
}
```

#### 9. User (src/types/index.ts:83-92)
```typescript
interface User {
  id: string;
  email: string;           // Unique, case-insensitive
  name: string;
  roles: string[];         // EMBEDDED ARRAY - needs junction table
  profiles?: string[];     // EMBEDDED ARRAY - needs junction table
  createdAt: number;
  updatedAt: number;
  createdBy: string;
}
```

#### 10. FirestoreUser (src/config/authTypes.ts:25-31) - Auth-specific user
```typescript
interface FirestoreUser {
  uid: string;
  email: string;
  role: UserRole;          // 'employee' | 'manager' | 'admin'
  createdAt: number;
  updatedAt: number;
}
```

### Identified Embedded Arrays Requiring Normalization

| Parent Type | Field | Element Type | Normalization Strategy |
|------------|-------|-------------|----------------------|
| Template | `steps` | Step | Child table: `template_steps` |
| OnboardingInstance | `steps` | Step | Child table: `instance_steps` |
| OnboardingInstance | `profileIds` | string (profile FK) | Junction table: `instance_profiles` |
| OnboardingInstance | `templateIds` | string (template FK) | Junction table: `instance_template_refs` |
| OnboardingInstance | `templateSnapshots` | object | Child table: `instance_template_snapshots` + its own steps child |
| ProfileTemplate | `steps` | Step | Child table: `profile_template_steps` |
| Profile | `roleTags` | string (role name) | Junction table: `profile_role_tags` |
| User | `roles` | string (role name) | Junction table: `user_roles` |
| User | `profiles` | string (profile name) | Junction table: `user_profiles` |

### Identified Foreign Key Relationships

| From Table | Column | To Table | Column | Notes |
|-----------|--------|----------|--------|-------|
| templates | - | roles | name | via role field (name, not ID) |
| onboarding_instances | template_id | templates | id | Direct FK |
| onboarding_instances | - | roles | name | via role field |
| suggestions | instance_id | onboarding_instances | id | Optional FK |
| roles | created_by | users | id | Creator reference |
| profiles | created_by | users | id | Creator reference |
| profile_templates | profile_id | profiles | id | Direct FK |
| profile_templates | created_by | users | id | Creator reference |

### Data Access Patterns (from dataClient.ts)

Operations that must be supported by the schema:

**Templates:**
- List all templates
- Get single template by ID
- Create template (with embedded steps)
- Update template (including steps sync to instances)
- Delete template

**Onboarding Instances:**
- List all instances
- Get instance by ID
- Create instance from template (copies steps)
- Update instance (partial updates)
- Update step status within instance (read-modify-write on steps array)
- Query by employeeEmail (used for employee view)
- Query by templateId (used for step sync)

**Suggestions:**
- List all suggestions
- Create suggestion
- Update suggestion status
- Delete suggestion

**Activities:**
- List all activities
- Log activity (create)

**Roles:**
- List all roles
- Get role by ID
- Check role name uniqueness (case-insensitive)
- Check if role is in use (referenced by templates/instances)
- Create role
- Update role
- Delete role

**Profiles:**
- List all profiles
- Get profile by ID
- Create profile
- Update profile
- Delete profile

**Profile Templates:**
- List all (optionally filtered by profileId)
- Get by ID
- Create
- Update
- Delete

**Users:**
- List all users
- Get user by ID
- Check email uniqueness (case-insensitive)
- Create user
- Update user
- Delete user (cascading cleanup)

**Real-time Subscriptions (9 total):**
- subscribeToTemplates
- subscribeToOnboardingInstance (single)
- subscribeToOnboardingInstances (all)
- subscribeToSteps (instance steps)
- subscribeToActivities
- subscribeToRoles
- subscribeToProfiles
- subscribeToProfileTemplates (by profileId)
- subscribeToEmployeeInstance (by email)
- subscribeToUsers

### Code to Reuse
- `src/types/index.ts` - TypeScript types define the data model (will need new DB types alongside)
- `src/config/firebase.ts` - Pattern for config file (will create parallel `supabase.ts`)

### Code NOT to Modify (in this step)
- `src/services/dataClient.ts` - Will be replaced in step 2
- `src/services/authService.ts` - Will be replaced in step 3
- `src/services/roleClient.ts` - Business logic layer, may not need changes
- `src/services/userOperations.ts` - Will be replaced in step 2
- `src/config/authContext.tsx` - Will be updated in step 3

### Patterns to Follow
- Environment variables use `VITE_` prefix (Vite convention)
- Config files live in `src/config/`
- Service files live in `src/services/`
- Types defined in `src/types/`
- Tests colocated with source (`.test.ts` suffix)

---

## Proposed Postgres Schema Design

### Design Decisions

**D1: Normalized Steps vs JSONB**
- Decision: Use **child tables** for steps (not JSONB arrays)
- Rationale: Steps are queried individually (updateStepStatus), have their own status, and need to be updated independently. JSONB would require read-modify-write for every status change, which is what Firestore does and what we're trying to improve.

**D2: Role/Profile References - By Name vs By ID**
- Decision: Use **name-based references** for roles in steps/templates (matching current behavior) but use **ID-based foreign keys** for structural relationships (profile_templates -> profiles)
- Rationale: The current codebase stores role names as strings (e.g., 'Engineering') in templates and steps. Changing to IDs would require refactoring all UI code, which is out of scope. Junction tables use proper FK references.

**D3: templateSnapshots - Separate Table vs JSONB**
- Decision: Use **JSONB column** for templateSnapshots
- Rationale: templateSnapshots are write-once (captured at instantiation) and read as a whole blob. They are never individually queried or updated. JSONB preserves the nested structure naturally and avoids creating 2 additional tables for a rarely-used feature.

**D4: Step ID Strategy**
- Decision: Steps use **composite primary key** (parent_id + step_order) or sequential integer within parent
- Rationale: In Firestore, step.id is a sequential integer within its parent (1, 2, 3...). In Postgres, we need a unique identifier. Using a composite key of (parent_id, position) or a UUID PK with a position/order column.
- Final choice: **UUID PK with position column** - most flexible, avoids issues with step reordering

**D5: Timestamp Strategy**
- Decision: Use `timestamptz` columns with `DEFAULT now()` for new data, but the application layer will need to handle Unix timestamp conversion during migration
- Rationale: Postgres native timestamps are superior to Unix integers for querying, sorting, and human readability

### Table Schema (16 tables total)

#### Core Tables (8 - matching Firestore collections)

```sql
-- 1. users
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL,

  CONSTRAINT users_email_unique UNIQUE (lower(email))
);

-- 2. roles
CREATE TABLE roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL,

  CONSTRAINT roles_name_unique UNIQUE (lower(name))
);

-- 3. profiles
CREATE TABLE profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL
);

-- 4. templates
CREATE TABLE templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  role TEXT NOT NULL,          -- Role name string (matches current behavior)
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- 5. profile_templates
CREATE TABLE profile_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  version INTEGER NOT NULL DEFAULT 1,
  is_published BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL
);

-- 6. onboarding_instances
CREATE TABLE onboarding_instances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  employee_name TEXT NOT NULL,
  employee_email TEXT NOT NULL,
  role TEXT NOT NULL,
  department TEXT NOT NULL,
  template_id UUID REFERENCES templates(id) ON DELETE SET NULL,
  progress INTEGER NOT NULL DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'completed', 'on_hold')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  start_date TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  template_snapshots JSONB     -- Write-once blob, not individually queried
);

-- 7. suggestions
CREATE TABLE suggestions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  step_id INTEGER NOT NULL,
  user_name TEXT NOT NULL,          -- Currently stores user name, not ID
  text TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'reviewed', 'implemented')),
  created_at TIMESTAMPTZ DEFAULT now(),
  instance_id UUID REFERENCES onboarding_instances(id) ON DELETE SET NULL
);

-- 8. activities
CREATE TABLE activities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_initials TEXT NOT NULL,
  action TEXT NOT NULL,
  time_ago TEXT,                     -- Display string (may be computed in future)
  timestamp TIMESTAMPTZ DEFAULT now(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  resource_type TEXT,
  resource_id TEXT                    -- Generic reference (UUID as text since it could reference any table)
);
```

#### Child Tables for Embedded Steps (3 tables)

```sql
-- Steps belonging to a template
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID NOT NULL REFERENCES templates(id) ON DELETE CASCADE,
  position INTEGER NOT NULL,        -- Ordering (was step.id in Firestore)
  title TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  role TEXT NOT NULL DEFAULT 'All',
  owner TEXT NOT NULL DEFAULT '',
  expert TEXT NOT NULL DEFAULT '',
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'stuck')),
  link TEXT DEFAULT '',

  CONSTRAINT template_steps_unique_position UNIQUE (template_id, position)
);

-- Steps belonging to an onboarding instance
CREATE TABLE instance_steps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  instance_id UUID NOT NULL REFERENCES onboarding_instances(id) ON DELETE CASCADE,
  position INTEGER NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  role TEXT NOT NULL DEFAULT 'All',
  owner TEXT NOT NULL DEFAULT '',
  expert TEXT NOT NULL DEFAULT '',
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'stuck')),
  link TEXT DEFAULT '',

  CONSTRAINT instance_steps_unique_position UNIQUE (instance_id, position)
);

-- Steps belonging to a profile template
CREATE TABLE profile_template_steps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_template_id UUID NOT NULL REFERENCES profile_templates(id) ON DELETE CASCADE,
  position INTEGER NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  role TEXT NOT NULL DEFAULT 'All',
  owner TEXT NOT NULL DEFAULT '',
  expert TEXT NOT NULL DEFAULT '',
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'stuck')),
  link TEXT DEFAULT '',

  CONSTRAINT profile_template_steps_unique_position UNIQUE (profile_template_id, position)
);
```

#### Junction Tables (5 tables)

```sql
-- User roles (User.roles[])
CREATE TABLE user_roles (
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role_name TEXT NOT NULL,        -- Stores role name string (e.g., 'manager', 'admin', 'employee')
  PRIMARY KEY (user_id, role_name)
);

-- User profiles (User.profiles[])
CREATE TABLE user_profiles (
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  profile_name TEXT NOT NULL,     -- Stores profile name string
  PRIMARY KEY (user_id, profile_name)
);

-- Profile role tags (Profile.roleTags[])
CREATE TABLE profile_role_tags (
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  role_tag TEXT NOT NULL,         -- Role tag string (e.g., 'Engineering', 'All')
  PRIMARY KEY (profile_id, role_tag)
);

-- Instance profile assignments (OnboardingInstance.profileIds[])
CREATE TABLE instance_profiles (
  instance_id UUID NOT NULL REFERENCES onboarding_instances(id) ON DELETE CASCADE,
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  PRIMARY KEY (instance_id, profile_id)
);

-- Instance template references (OnboardingInstance.templateIds[])
CREATE TABLE instance_template_refs (
  instance_id UUID NOT NULL REFERENCES onboarding_instances(id) ON DELETE CASCADE,
  template_id UUID NOT NULL REFERENCES profile_templates(id) ON DELETE CASCADE,
  PRIMARY KEY (instance_id, template_id)
);
```

### Indexes

```sql
-- Performance indexes for common queries
CREATE INDEX idx_onboarding_instances_employee_email ON onboarding_instances(lower(employee_email));
CREATE INDEX idx_onboarding_instances_template_id ON onboarding_instances(template_id);
CREATE INDEX idx_onboarding_instances_status ON onboarding_instances(status);
CREATE INDEX idx_suggestions_instance_id ON suggestions(instance_id);
CREATE INDEX idx_activities_timestamp ON activities(timestamp DESC);
CREATE INDEX idx_activities_user_id ON activities(user_id);
CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_instance_steps_instance_id ON instance_steps(instance_id);
CREATE INDEX idx_instance_steps_status ON instance_steps(status);
CREATE INDEX idx_profile_templates_profile_id ON profile_templates(profile_id);
CREATE INDEX idx_profile_template_steps_template_id ON profile_template_steps(profile_template_id);
CREATE INDEX idx_user_roles_user_id ON user_roles(user_id);
CREATE INDEX idx_user_profiles_user_id ON user_profiles(user_id);
```

### Row Level Security (RLS) - Basic Policies

For Step 1, we set up permissive policies. More granular role-based policies will be refined in Step 3 (supabase-auth) when Supabase Auth is integrated.

```sql
-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE profile_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE onboarding_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE suggestions ENABLE ROW LEVEL SECURITY;
ALTER TABLE activities ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE instance_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE profile_template_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE profile_role_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE instance_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE instance_template_refs ENABLE ROW LEVEL SECURITY;

-- For Step 1: Allow all authenticated users to read/write all tables
-- (mirrors current Firestore rules: allow read, write: if true)
-- These will be tightened in supabase-auth step
CREATE POLICY "Allow all for authenticated users" ON users
  FOR ALL USING (true) WITH CHECK (true);
-- (repeat for all 16 tables)
```

### Updated at Trigger

```sql
-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_updated_at BEFORE UPDATE ON users
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER roles_updated_at BEFORE UPDATE ON roles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER templates_updated_at BEFORE UPDATE ON templates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER profile_templates_updated_at BEFORE UPDATE ON profile_templates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER onboarding_instances_updated_at BEFORE UPDATE ON onboarding_instances
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

### Total Table Count: 16

| Category | Tables | Count |
|----------|--------|-------|
| Core | users, roles, profiles, templates, profile_templates, onboarding_instances, suggestions, activities | 8 |
| Step child | template_steps, instance_steps, profile_template_steps | 3 |
| Junction | user_roles, user_profiles, profile_role_tags, instance_profiles, instance_template_refs | 5 |
| **Total** | | **16** |

---

## Supabase Config Design

### Environment Variables

```env
# Supabase Configuration (add to .env.template alongside existing Firebase vars)
VITE_SUPABASE_URL=http://127.0.0.1:54321
VITE_SUPABASE_ANON_KEY=your_anon_key_here
```

### Client Configuration File

File: `src/config/supabase.ts`

```typescript
import { createClient } from '@supabase/supabase-js';
import type { Database } from '../types/database.types';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables. Check .env.local');
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);
```

### Generated Types File

File: `src/types/database.types.ts` (auto-generated via `supabase gen types typescript`)

This will contain the full Database type that provides type-safe query building.

---

## File Structure Plan

```
supabase/                              # NEW - Supabase CLI directory
  migrations/
    00001_create_schema.sql            # All tables, indexes, triggers
    00002_enable_rls.sql               # RLS policies
    00003_seed_defaults.sql            # Default roles and profiles
  config.toml                          # Supabase local config

src/
  config/
    supabase.ts                        # NEW - Supabase client (parallel to firebase.ts)
  types/
    database.types.ts                  # NEW - Generated database types
```

---

## Risk Assessment

### Technical Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Embedded array normalization loses data fidelity | High | Low | Comprehensive mapping documented; junction/child tables preserve all data |
| Step ID mismatch (Firestore integer IDs vs Postgres UUID) | High | Medium | Use `position` column to maintain ordering; map old integer IDs to position values |
| templateSnapshots JSONB loses query ability | Low | Low | Feature is write-once/read-whole; JSONB is appropriate |
| Mixed `Suggestion.id` type (number or string) | Medium | Medium | Postgres uses UUID; data migration must handle both types |
| `created_by` self-reference in users table | Low | Medium | Allow NULL for created_by; system-created users have NULL creator |
| Role references by name vs ID inconsistency | Medium | Low | Document clearly; steps/templates use name strings, junction tables use proper FKs where possible |
| Realtime subscription count (9 active subscriptions) | Medium | Medium | Supabase Realtime supports multiple channels; may need to optimize in step 4 |

### Complexity
- **Level:** Medium
- **Rationale:** The schema translation is straightforward for 5 of 8 tables. The complexity comes from:
  1. Normalizing 3 different embedded `Step[]` arrays into separate child tables
  2. Creating 5 junction tables for embedded string arrays
  3. The `templateSnapshots` nested structure (mitigated by using JSONB)
  4. The `users` table circular reference (`created_by` -> `users.id`)

---

## Open Questions

- [x] Q1: Should we use Supabase CLI for local development or only hosted Supabase?
  - Resolution: Use Supabase CLI with `supabase/migrations/` directory for local development. This allows running migrations locally and in CI/CD. The Supabase project URL/key in `.env` can point to either local or hosted.

- [x] Q2: Should step tables use the same schema or should template_steps omit the `status` column (since template steps are always 'pending')?
  - Resolution: Keep the same schema for all step tables. Template steps default to 'pending'. This simplifies the code that copies steps between templates and instances.

- [x] Q3: Should `FirestoreUser` and `User` types be unified into one `users` table?
  - Resolution: Yes. The `User` type (from `types/index.ts`) and `FirestoreUser` (from `authTypes.ts`) both map to the same `users` collection. In Postgres, there will be one `users` table. The `FirestoreUser.role` (single string) maps to `user_roles` junction table. The `FirestoreUser.uid` maps to `users.id`.

- [x] Q4: How should we handle the `Suggestion.user` field which stores a name string, not a user ID?
  - Resolution: Keep as `user_name TEXT` in the suggestions table. This matches current behavior. Changing to a FK would require refactoring suggestion creation logic, which is out of scope for this step.

- [x] Q5: Should `Activity.timeAgo` be stored or computed?
  - Resolution: Keep it as a stored text field for now (matching current behavior). In a future optimization, this could be computed from `timestamp`. Not in scope for this step.

- [ ] Q6: Does the user have a Supabase project already set up, or do we need to include Supabase CLI setup instructions?
  - Recommendation: Include both `supabase init` setup and migration files so this works for both local dev (Supabase CLI) and hosted Supabase.
  - Status: NEEDS USER INPUT (non-blocking -- we will include both)

---

## Recommended Approach

### Implementation Strategy

Create a clean, well-documented SQL migration that translates the Firestore document model to a proper relational Postgres schema. Install the Supabase client package and create a parallel config file that coexists with the Firebase config.

**Key principle:** This step creates infrastructure only. No existing code is modified. The Firebase app continues working unchanged.

### Order of Work

1. **Install Supabase JS client** - `npm install @supabase/supabase-js`
2. **Create Supabase config file** - `src/config/supabase.ts` with env var setup
3. **Create SQL migration: core tables** - 8 primary tables matching Firestore collections
4. **Create SQL migration: child tables** - 3 step tables (template_steps, instance_steps, profile_template_steps)
5. **Create SQL migration: junction tables** - 5 junction tables for embedded arrays
6. **Create SQL migration: indexes** - Performance indexes for common query patterns
7. **Create SQL migration: RLS policies** - Basic permissive policies (tightened in step 3)
8. **Create SQL migration: triggers** - updated_at auto-update triggers
9. **Create SQL migration: seed data** - Default roles and profiles
10. **Update .env.template** - Add Supabase env vars alongside Firebase vars
11. **Generate TypeScript types** - Database types from schema (or create manually)
12. **Create basic test** - Verify Supabase client can be imported without errors

### What to Defer

- **Granular RLS policies** - Deferred to `supabase-auth` step (step 3) when auth is integrated
- **Data migration scripts** - Not needed yet; no data to migrate until data layer is replaced
- **Firebase removal** - Deferred to `cleanup` step (step 5)
- **Supabase Realtime configuration** - Deferred to `supabase-realtime` step (step 4)
- **Supabase Storage setup** - Deferred; current app uses Firebase Storage minimally

---

## Key Files Referenced

| File | Path | Relevance |
|------|------|-----------|
| Firebase config | `/workspaces/onboarding/src/config/firebase.ts` | Pattern for Supabase config |
| TypeScript types | `/workspaces/onboarding/src/types/index.ts` | All data model definitions (373 lines) |
| Auth types | `/workspaces/onboarding/src/config/authTypes.ts` | Auth user types |
| Data client | `/workspaces/onboarding/src/services/dataClient.ts` | All collection operations (2084 lines) |
| Auth service | `/workspaces/onboarding/src/services/authService.ts` | Auth operations (304 lines) |
| Role client | `/workspaces/onboarding/src/services/roleClient.ts` | Role validation/CRUD (352 lines) |
| User operations | `/workspaces/onboarding/src/services/userOperations.ts` | User CRUD with cascading delete (1025 lines) |
| Firestore rules | `/workspaces/onboarding/firestore.rules` | Current security model (permissive) |
| Env template | `/workspaces/onboarding/.env.template` | Current env var pattern |
| Package.json | `/workspaces/onboarding/package.json` | Current dependencies |

---

## Next Step

**All critical questions are resolved. Non-blocking question Q6 has a safe default.**

Run `/plan supabase-setup` to create the detailed implementation plan with tasks.
