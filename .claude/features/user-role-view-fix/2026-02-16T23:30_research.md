# Research: user-role-view-fix

## Metadata
- **Feature:** user-role-view-fix
- **Created:** 2026-02-16T23:30
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context
- **Description:** Users created via the Users panel are assigned custom role names from the `roles` table (e.g., "talker", "hr-admin", "team-lead"). When these users sign in, their role is stored in `user_roles.role_name` as the custom name. However, the UI checks for exact strings `'manager'` or `'admin'` to grant manager dashboard access. Custom role names fall through to employee view, even though the user was created as a system user (non-employee).
- **Where it fits:** This is a view-routing bug that affects all users created through the Users panel who are assigned any custom role other than the literal strings "manager" or "admin".
- **Dependencies:** None -- this is a standalone bugfix.

## Requirements

### Functional Requirements
- FR1: Users created via Users panel with ANY non-employee role must see the Manager Dashboard (not Employee View)
- FR2: Users with the role "employee" must continue to see Employee View only
- FR3: Users with null role must see Employee View (defensive)
- FR4: The NavBar must show the view switcher (Employee View / Manager View / Templates) for all non-employee roles
- FR5: The Templates route must be accessible to all non-employee roles
- FR6: Existing test accounts (test-manager@example.com, test-admin@example.com) must continue working as before

### Technical Requirements
- TR1: The `UserRole` type must be broadened from `'employee' | 'manager' | 'admin'` to `string` to accommodate custom role names from the `roles` table
- TR2: All 4 locations that check `role === 'manager' || role === 'admin'` must be flipped to `role !== 'employee' && role !== null`
- TR3: The `getUserRole()` in authService.ts already returns `roleName as UserRole | null` -- the cast must accommodate arbitrary strings
- TR4: The auth credential stored in localStorage already stores the role as a plain string -- no change needed there

### Code Examples / References

**The bug flow:**
1. Admin opens Users panel, creates user with email `alice@co.com` and role `["team-lead"]`
2. `userService.ts:236` stores `primaryRole = userData.roles[0]` = `"team-lead"`
3. `userService.ts:302` calls `addUserToAuthCredentials("alice@co.com", "team-lead", newId)`
4. Alice signs in via email form
5. `authService.ts:133-134` finds the credential, stores `{ role: "team-lead" }` in localStorage
6. `authContext.tsx:139` sets `role = "team-lead"`
7. `App.tsx:21` checks `role === 'manager' || role === 'admin'` -- FALSE for "team-lead"
8. Alice gets employee view instead of manager dashboard

### Warnings/Critical Notes
> The `UserRole` type is used in 20+ locations across the codebase. Changing it from a union of 3 strings to `string` requires careful validation that TypeScript doesn't break anywhere. However, the DB schema (`user_roles.role_name`) is already unconstrained `string`, so the app type should match.

> The `impersonateUserForQA` function in `authContext.tsx` takes `role: UserRole` as a parameter. After broadening the type, this will accept any string, which is correct behavior.

## Existing Code Analysis

### Project State
- Project exists: YES
- 520 tests passing across 35 test files
- Zustand migration complete (5/5 slices)

### Locations That Need Changes

#### 1. `src/config/authTypes.ts` (line 9) -- Type Definition
```typescript
// CURRENT:
export type UserRole = 'employee' | 'manager' | 'admin';

// NEEDED:
export type UserRole = string;
```
This is the root type that flows everywhere. The DB `user_roles.role_name` column is already unconstrained `string`. The app type should match.

#### 2. `src/App.tsx` -- 3 locations

**Line 21 -- `getInitialView()`:**
```typescript
// CURRENT:
return role === 'manager' || role === 'admin' ? 'manager' : 'employee';

// NEEDED:
return role != null && role !== 'employee' ? 'manager' : 'employee';
```

**Line 33 -- `useEffect` role change handler:**
```typescript
// CURRENT:
if (role === 'manager' || role === 'admin') {

// NEEDED:
if (role != null && role !== 'employee') {
```

**Line 88 -- `canAccessTemplates`:**
```typescript
// CURRENT:
const canAccessTemplates = role === 'manager' || role === 'admin';

// NEEDED:
const canAccessTemplates = role != null && role !== 'employee';
```

#### 3. `src/components/OnboardingHub.tsx` (line 39) -- `isManager`
```typescript
// CURRENT:
const isManager = role === 'manager' || role === 'admin';

// NEEDED:
const isManager = role != null && role !== 'employee';
```
Note: `role` comes from `useAuth()` which returns `UserRole | null`. The null check is needed.

#### 4. `src/components/ui/NavBar.tsx` (line 40) -- `canAccessManagerView`
```typescript
// CURRENT:
const canAccessManagerView = role === 'manager' || role === 'admin';

// NEEDED:
const canAccessManagerView = role != null && role !== 'employee';
```

#### 5. `src/config/authContext.tsx` (line 284) -- JSDoc comment only
```typescript
// CURRENT (comment):
 *     {(role === 'manager' || role === 'admin') && <ManagerView />}

// NEEDED (comment):
 *     {(role != null && role !== 'employee') && <ManagerView />}
```
This is only in a JSDoc comment for `useAuth`, not in executable code.

### Files That Need NO Changes

- **`src/services/authService.ts`** -- `getUserRole()` reads `role_name` from DB and returns it as `UserRole | null`. After broadening `UserRole` to `string`, this works correctly. The `MOCK_EMAIL_ROLES` map still correctly maps test emails to 'employee', 'manager', 'admin'. `setUserRole()` takes `UserRole` parameter -- still works with string.

- **`src/services/supabase/userService.ts`** -- Line 236 (`primaryRole = userData.roles[0] || 'employee'`) stores the custom role name into auth credentials. This is the SOURCE of the bug, but the code itself is correct. The role name IS the custom name, and it SHOULD be stored. The fix is in how the UI interprets it.

- **`src/services/supabase/mappers.ts`** -- `toUser()` maps `roleRows.map(r => r.role_name)` to `User.roles: string[]`. Already unconstrained. No change.

- **`src/views/SignInView.tsx`** -- Uses `UserRole` for `TestAccountButton.role` prop. After broadening to `string`, the test accounts with 'employee', 'manager', 'admin' still work. The `impersonateUserForQA` function accepts `UserRole` -- still works.

- **`src/config/authContext.tsx`** -- Uses `UserRole` for state types (`useState<UserRole | null>`). After broadening to `string`, this still works. `loadMockAuthFromStorage()` parses `role` from localStorage as `UserRole` -- still works with string.

### Patterns to Follow
- The codebase uses a consistent pattern: derive a boolean from role, then use that boolean throughout:
  - `App.tsx`: `canAccessTemplates`
  - `OnboardingHub.tsx`: `isManager`
  - `NavBar.tsx`: `canAccessManagerView`
- All 3 should use the same logic: `role != null && role !== 'employee'`

### Helper Function Recommendation
Consider creating a utility function to centralize this logic and avoid repeating the check in 4 places:
```typescript
// In authTypes.ts or a new utils file
export function hasManagerAccess(role: UserRole | null): boolean {
  return role != null && role !== 'employee';
}
```
This would make the check DRY and easy to update if access logic changes in the future. Each location would become:
- `App.tsx:21`: `return hasManagerAccess(role) ? 'manager' : 'employee';`
- `App.tsx:33`: `if (hasManagerAccess(role)) {`
- `App.tsx:88`: `const canAccessTemplates = hasManagerAccess(role);`
- `OnboardingHub.tsx:39`: `const isManager = hasManagerAccess(role);`
- `NavBar.tsx:40`: `const canAccessManagerView = hasManagerAccess(role);`

## Constraints

### Performance
- No performance impact -- this is a string comparison change, not a data flow change.

### Platform
- No platform constraints.

### Dependencies
- No new dependencies needed.

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Broadening `UserRole` from union to `string` breaks TypeScript type safety | Low | Low | The DB schema is already unconstrained string. TypeScript types should match reality. Union was aspirational, not enforced. |
| Test files that hardcode `'employee' \| 'manager' \| 'admin'` type annotations break | Medium | Medium | Search all test files for the old union type and update them. Found in `authService.test.ts:244`. |
| Null role falls through to manager view | High | Low | Always check `role != null` before checking `!== 'employee'`. The `&&` short-circuit handles this. |
| Auth flow stores wrong role type | Low | None | `addUserToAuthCredentials` already stores arbitrary strings. `getAuthCredential` returns them unchanged. No casting involved. |

### Complexity
- **Level:** Simple
- **Rationale:** 4-5 locations to change with identical logic flip. 1 type definition change. No new components, no data flow changes, no API changes. A helper function is optional but recommended for DRYness.

## Open Questions

- [x] Q1: Should `UserRole` become `string` or should we add an explicit list of known custom roles?
  - Resolution: `string` -- the `roles` table allows arbitrary custom role names. The type system cannot enumerate them at compile time. The DB schema is already unconstrained.

- [x] Q2: Should we use `role !== 'employee'` or create a positive check like "has manager-level access"?
  - Resolution: Flip to `role !== 'employee'` (Approach B as specified by user). The semantic is: "any non-employee role gets manager access." This is cleaner than maintaining a growing allowlist.

- [x] Q3: Should we create a centralized helper function?
  - Resolution: Yes, recommended. `hasManagerAccess(role)` in `authTypes.ts` keeps the logic DRY across 5 call sites. But this is optional -- inline logic also works since the pattern is simple.

- [x] Q4: Does `authService.test.ts` line 244 need updating?
  - Resolution: Yes. The line `const testRoles: Array<'employee' | 'manager' | 'admin'>` hardcodes the old union type. After changing `UserRole` to `string`, this should become `const testRoles: UserRole[]` or `const testRoles: string[]`.

## Recommended Approach

### Implementation Strategy

**Step 1: Broaden the `UserRole` type**
- Change `src/config/authTypes.ts:9` from `'employee' | 'manager' | 'admin'` to `string`

**Step 2: Create a centralized helper (optional but recommended)**
- Add `hasManagerAccess(role: UserRole | null): boolean` to `src/config/authTypes.ts`
- Logic: `return role != null && role !== 'employee';`

**Step 3: Flip the checks in 3 production files (4-5 locations)**
1. `src/App.tsx` -- lines 21, 33, 88
2. `src/components/OnboardingHub.tsx` -- line 39
3. `src/components/ui/NavBar.tsx` -- line 40
4. `src/config/authContext.tsx` -- line 284 (JSDoc comment only)

**Step 4: Fix test files**
- `src/services/authService.test.ts:244` -- update type annotation

**Step 5: Write new tests**
- Add test that a custom role (e.g., "team-lead") gets `hasManagerAccess() === true`
- Add test that "employee" gets `hasManagerAccess() === false`
- Add test that `null` gets `hasManagerAccess() === false`

### Order of Work
1. Type definition change (`authTypes.ts`)
2. Helper function (`authTypes.ts`)
3. `App.tsx` -- 3 locations
4. `OnboardingHub.tsx` -- 1 location
5. `NavBar.tsx` -- 1 location
6. `authContext.tsx` -- comment update
7. Test file fixes
8. New tests for `hasManagerAccess`
9. Run full test suite

### What to Defer
- No need to change any service files, mappers, or database schema
- No need to change the UserModal or UsersPanel -- they already handle arbitrary role names correctly
- No need to change the SignInView -- test accounts are hardcoded but still valid

## Files Summary

### Must Change (Production Code)
| File | Line(s) | Change |
|------|---------|--------|
| `src/config/authTypes.ts` | 9 | `UserRole` type: union -> string |
| `src/config/authTypes.ts` | NEW | Add `hasManagerAccess()` helper |
| `src/App.tsx` | 21, 33, 88 | Flip role checks to use helper |
| `src/components/OnboardingHub.tsx` | 39 | Flip `isManager` to use helper |
| `src/components/ui/NavBar.tsx` | 40 | Flip `canAccessManagerView` to use helper |
| `src/config/authContext.tsx` | 284 | Update JSDoc comment |

### Must Change (Test Code)
| File | Line(s) | Change |
|------|---------|--------|
| `src/services/authService.test.ts` | 244 | Update type annotation |

### No Change Needed
| File | Reason |
|------|--------|
| `src/services/authService.ts` | Already handles arbitrary role strings correctly |
| `src/services/supabase/userService.ts` | Role storage is correct; bug is in UI interpretation |
| `src/services/supabase/mappers.ts` | Already maps to `string[]` |
| `src/config/authContext.tsx` | Execution code already works with `UserRole` as string |
| `src/views/SignInView.tsx` | Test accounts still valid |
| `src/components/modals/UserModal.tsx` | Already handles arbitrary role names |
| `src/components/manager/UsersPanel.tsx` | Already handles arbitrary role names |

## Next Step

**All questions resolved.**
Run `/plan user-role-view-fix` to create implementation plan.
