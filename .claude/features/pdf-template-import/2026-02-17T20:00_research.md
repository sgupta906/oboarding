# Research: pdf-template-import

## Metadata
- **Feature:** pdf-template-import
- **Created:** 2026-02-17T20:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context

Managers currently create onboarding templates by manually filling out a form in `TemplateModal` -- typing the template name, selecting roles, and adding steps one at a time (title + description + owner + expert per step). For organizations with existing onboarding documentation in PDF format, this is tedious.

This feature allows a manager to upload a PDF file containing bulleted/numbered onboarding instructions and automatically parse them into template steps. The manager then reviews and edits the parsed steps in a preview screen before saving via the existing `createTemplate` service.

### Where It Fits

- **Upstream dependency:** Existing template system (templateService, TemplateModal, useTemplates hook) -- all complete and stable.
- **Downstream consumers:** Once a template is created via PDF import, it works identically to manually-created templates -- instances can be created from it, steps sync to instances, etc.
- **No database changes needed.** PDF import produces the same `Omit<Template, 'id' | 'createdAt'>` payload that manual creation does.

## Requirements

### Functional Requirements
- [ ] FR1: Manager can upload a PDF file (`.pdf` only) from the Templates view (source: user request)
- [ ] FR2: Client-side PDF text extraction using `pdfjs-dist` -- no server-side processing (source: user request)
- [ ] FR3: Heuristic bullet/numbered-list parser converts extracted text lines into template steps (source: user request)
- [ ] FR4: Each parsed bullet becomes one step: the bullet text becomes the step `title`, with an empty `description` (editable in preview) (source: recommended default)
- [ ] FR5: Preview/edit screen shows all parsed steps before saving, allowing the manager to edit titles, descriptions, owners, experts, reorder, add, or remove steps (source: user request)
- [ ] FR6: Manager provides template name and selects role(s) on the preview screen (not extracted from PDF) (source: recommended default)
- [ ] FR7: Save action creates the template via the existing `createTemplate` service through the `useTemplates` hook (source: user request)
- [ ] FR8: If the PDF contains no parseable bullets, show a clear error message (source: recommended default)
- [ ] FR9: Support multi-page PDFs -- extract text from all pages (source: recommended default)
- [ ] FR10: Cancel at any point returns to the Templates view without side effects (source: recommended default)

### Technical Requirements
- [ ] TR1: New dependency: `pdfjs-dist` (latest stable, currently ~5.x) for client-side PDF parsing
- [ ] TR2: PDF worker must be configured correctly for Vite 7 bundling (either inline worker or CDN worker URL)
- [ ] TR3: File size validation: reject PDFs over 10 MB with user-friendly error (source: recommended constraint)
- [ ] TR4: All new components must support dark mode (Tailwind `dark:` variants) per project convention
- [ ] TR5: All new components must have comprehensive unit tests (Vitest + RTL)
- [ ] TR6: PDF extraction and parsing must be in a separate utility module (`src/utils/pdfParser.ts`) for testability
- [ ] TR7: TypeScript strict mode compliance (project uses `strict: true`)
- [ ] TR8: No server-side involvement -- entire feature is client-side only

### Constraints
- Bundle size: `pdfjs-dist` adds ~400-500 KB gzipped. Consider dynamic `import()` so it's only loaded when the user clicks "Import PDF".
- Worker file: `pdfjs-dist` requires a Web Worker for PDF processing. In Vite, the recommended approach is to set `workerSrc` to a CDN URL (e.g., `https://unpkg.com/pdfjs-dist@VERSION/build/pdf.worker.min.mjs`) or to copy the worker file to `public/`.
- No AI/LLM dependency -- parsing is purely heuristic.

## Existing Code Analysis

### Project State
- Project exists: YES
- 563 tests passing across 30+ test files
- Template system is fully functional with CRUD, real-time subscriptions, and step reorder

### Relevant Existing Files

| File | Relevance |
|------|-----------|
| `src/services/supabase/templateService.ts` | `createTemplate()` -- will be called to persist the imported template |
| `src/hooks/useTemplates.ts` | `create()` wrapper with optimistic local state -- the import flow will call this |
| `src/components/templates/TemplateModal.tsx` | Existing create/edit modal -- the import preview can reuse its step editor UI |
| `src/views/TemplatesView.tsx` | Entry point -- needs an "Import PDF" button alongside "Create Template" |
| `src/components/ui/ModalWrapper.tsx` | Reusable modal container -- new import modal will use this |
| `src/types/index.ts` | `Template`, `Step`, `CustomRole` types -- no changes needed |

### Code to Reuse

1. **`ModalWrapper`** -- The import preview/edit screen should be a modal, reusing the same `ModalWrapper` component at size `2xl`.

2. **Step editor pattern from `TemplateModal`** -- The step card UI (title, description, owner, expert fields + reorder buttons + delete) can be extracted into a shared sub-component, or the import preview can directly reuse the same JSX pattern. Recommendation: **extract a `StepEditor` component** from `TemplateModal` that both the existing modal and the import preview can use. This avoids duplicating ~130 lines of step editor JSX.

3. **`useTemplates().create()`** -- The save action calls this, which calls `createTemplate()` in the service and optimistically updates local state.

4. **`useRoles()` hook** -- Import preview needs role checkboxes, same as `TemplateModal` uses.

5. **Validation logic from `TemplateModal.validateForm()`** -- The same validation rules apply (template name required, at least one role selected, at least one step with title).

### Code to Modify

1. **`src/views/TemplatesView.tsx`** -- Add "Import PDF" button next to "Create Template" button in the page header. Add state for import modal open/close. Render the new `PdfImportModal` component.

2. **`src/components/templates/TemplateModal.tsx`** -- Optionally refactor step editor into a shared component. This is recommended but not strictly required; the import modal could duplicate the pattern.

3. **`src/components/templates/index.ts`** -- Add barrel export for new component(s).

### Patterns to Follow

1. **Modal pattern:** All modals use `ModalWrapper` with header, scrollable body, and footer buttons. The import modal should follow this same pattern.

2. **State management:** The template system uses the `useTemplates` hook (not Zustand). The import flow should use the same `useTemplates().create()` function.

3. **Error display:** Red-bordered alert boxes with `bg-red-50 dark:bg-red-900/30` for errors, green for success toasts (3-second auto-dismiss). Same pattern as `TemplatesView`.

4. **Loading states:** Spinner with `animate-spin` class during async operations. Same pattern as `TemplateModal`'s submit button.

5. **Dark mode:** Every element needs both light and dark variants using Tailwind `dark:` classes.

6. **a11y:** All interactive elements need `aria-label`, form inputs need `htmlFor`/`id` pairs, modal uses `role="dialog"`.

7. **File naming:** Components use PascalCase (`PdfImportModal.tsx`), utilities use camelCase (`pdfParser.ts`), tests co-locate with source (`PdfImportModal.test.tsx`).

## pdf.js Integration Design

### Package Selection

Use `pdfjs-dist` (the official Mozilla PDF.js distribution npm package).
- Latest stable: 5.x series
- 2M+ weekly downloads, actively maintained by Mozilla
- Battle-tested for client-side PDF text extraction

### API Usage Pattern

```typescript
// src/utils/pdfParser.ts
import * as pdfjsLib from 'pdfjs-dist';

// Configure worker (one-time, on first use)
pdfjsLib.GlobalWorkerOptions.workerSrc =
  `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;

export interface ParsedStep {
  title: string;
  description: string;
}

export async function extractTextFromPdf(file: File): Promise<string> {
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

  const pages: string[] = [];
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const textContent = await page.getTextContent();
    const pageText = textContent.items
      .map((item: any) => item.str)
      .join(' ');
    pages.push(pageText);
  }

  return pages.join('\n');
}
```

### Vite Worker Configuration

Option A (recommended): CDN worker URL -- simplest, no build config changes needed.
```typescript
pdfjsLib.GlobalWorkerOptions.workerSrc =
  `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;
```

Option B: Copy worker to `public/` directory and reference as `/pdf.worker.min.mjs`. Requires a build step or manual copy.

Option C: Use Vite's `?worker` import syntax. More complex, may have compatibility issues with pdfjs-dist.

**Recommendation: Option A (CDN).** Zero build config changes, works immediately. Falls back gracefully if offline (the feature just won't work without internet, which is acceptable for this use case).

### Dynamic Import for Code Splitting

Since `pdfjs-dist` is ~400-500 KB, use dynamic `import()` so it's only loaded when the user clicks "Import PDF":

```typescript
// Only loaded when user triggers PDF import
const { extractTextFromPdf, parseBulletsToSteps } = await import('../utils/pdfParser');
```

This keeps the main bundle small and only loads the PDF library on demand.

## Bullet Parsing Algorithm Design

### Heuristic Rules

The parser should detect common bullet/numbered list patterns in extracted PDF text. PDF.js `getTextContent()` returns text items with positional information but no semantic markup. The parser works on the joined text string.

### Patterns to Detect

| Pattern | Regex | Example |
|---------|-------|---------|
| Unicode bullets | `/^[\u2022\u2023\u25E6\u2043\u2219]/` | "* Setup laptop" |
| ASCII bullets | `/^[\-\*\+]\s/` | "- Setup laptop" |
| Numbered lists | `/^\d+[\.\)]\s/` | "1. Setup laptop" |
| Lettered lists | `/^[a-zA-Z][\.\)]\s/` | "a. Setup laptop" |
| Arrow markers | `/^[>\u2192\u27A4]\s/` | "> Setup laptop" |
| Checkbox markers | `/^[\u2610\u2611\u2612\u25A1\u25A0]\s/` | "[ ] Setup laptop" |

### Algorithm

```typescript
export function parseBulletsToSteps(rawText: string): ParsedStep[] {
  const lines = rawText.split(/\n/).map(l => l.trim()).filter(Boolean);

  const bulletRegex = /^(?:[\u2022\u2023\u25E6\u2043\u2219\-\*\+>]|\d+[\.\)]|[a-zA-Z][\.\)]|[\u2610\u2611\u2612\u25A1\u25A0])\s+(.+)/;

  const steps: ParsedStep[] = [];

  for (const line of lines) {
    const match = line.match(bulletRegex);
    if (match) {
      steps.push({
        title: match[1].trim(),
        description: '',
      });
    }
  }

  // Fallback: if no bullets detected, try splitting on newlines
  // (each non-empty line becomes a step)
  if (steps.length === 0) {
    for (const line of lines) {
      if (line.length > 5 && line.length < 200) {
        steps.push({ title: line, description: '' });
      }
    }
  }

  return steps;
}
```

### Edge Cases

1. **Multi-line bullets:** A bullet that wraps to the next line in the PDF. The parser treats each line independently. If the second line doesn't match a bullet pattern, it's dropped. This is acceptable for v1 -- the manager can edit in preview.

2. **Headers/titles in the PDF:** Non-bullet text (headers, paragraphs) is ignored by the bullet regex. The fallback (line-per-step) only kicks in when zero bullets are detected.

3. **Sub-bullets (nested lists):** Treated as top-level steps. The parser doesn't detect hierarchy. Acceptable for v1.

4. **Empty/image-only PDFs:** `getTextContent()` returns empty items. The parser returns an empty array, and the UI shows an error message.

5. **Very long bullet text (>200 chars):** Still treated as a step title. The manager can shorten in preview.

6. **Duplicate bullets:** Not de-duplicated. The manager can remove duplicates in preview.

## UI/UX Design

### Entry Point

Add an "Import from PDF" button in the `TemplatesView` page header, next to the existing "Create Template" button. Use a secondary style (outline/ghost) to differentiate from the primary create action.

```
[+ Create Template]  [Upload Import from PDF]
```

Use the `FileUp` (or `Upload`) icon from lucide-react.

### Flow

1. **Click "Import from PDF"** -- Opens a file picker dialog (browser native `<input type="file" accept=".pdf">`)
2. **File selected** -- Modal opens with loading state ("Extracting text from PDF...")
3. **Extraction complete** -- Modal shows parsed steps in preview/edit form
4. **Preview/Edit form** contains:
   - Template Name (text input, required)
   - Role Tags (checkbox list, same as TemplateModal)
   - Status (Draft/Published radio, default Draft)
   - Parsed Steps list (editable: title, description, owner, expert per step)
   - Step reorder buttons (same as TemplateModal)
   - Add Step / Remove Step buttons
   - Source PDF filename displayed as read-only info
5. **Save** -- Creates template via `useTemplates().create()`
6. **Cancel** -- Closes modal, discards all parsed data

### Modal Structure

The import preview modal should have a two-phase UI:

**Phase 1: Upload/Processing**
- Drag-and-drop zone or file picker button
- File size validation (max 10 MB)
- Loading spinner during extraction
- Error messages for invalid files

**Phase 2: Preview/Edit**
- Same form layout as `TemplateModal` in create mode
- Pre-populated steps from PDF parsing
- Info banner: "X steps extracted from [filename.pdf]"
- All fields editable
- Same validation as TemplateModal

### Alternative: Simpler Approach

Instead of a separate modal, the import could populate the existing `TemplateModal` in create mode with pre-filled steps. This would mean:
1. Click "Import from PDF" -> file picker
2. Parse PDF
3. Open `TemplateModal` in create mode with steps pre-filled

**Recommendation: Use the simpler approach.** Add an `initialSteps` prop to `TemplateModal` so the PDF import can pass parsed steps directly. This avoids building a completely new modal and reuses all existing validation, step editing, and save logic.

The flow becomes:
1. Click "Import from PDF" in TemplatesView header
2. Hidden `<input type="file">` triggers browser file picker
3. Parse PDF (show inline loading indicator on the button)
4. Open `TemplateModal` in create mode with `initialSteps` pre-filled
5. Manager fills in template name, roles, edits steps as needed
6. Save works identically to normal create

This approach requires:
- Adding `initialSteps?: TemplateStep[]` prop to `TemplateModal`
- Updating the `useEffect` that handles create mode reset to use `initialSteps` if provided
- Adding the PDF import button and file handling to `TemplatesView`
- Creating `src/utils/pdfParser.ts` for extraction + parsing logic

## New Files to Create

| File | Purpose |
|------|---------|
| `src/utils/pdfParser.ts` | PDF text extraction + bullet parsing logic |
| `src/utils/pdfParser.test.ts` | Unit tests for extraction and parsing |

## Files to Modify

| File | Changes |
|------|---------|
| `src/views/TemplatesView.tsx` | Add "Import from PDF" button, file input, PDF processing handler |
| `src/components/templates/TemplateModal.tsx` | Add `initialSteps` prop to pre-fill steps from PDF import |
| `package.json` | Add `pdfjs-dist` dependency |

## Risk Assessment

### Technical Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| pdf.js worker fails to load from CDN | High -- feature non-functional | Low | Use unpkg CDN (highly reliable); show clear error if worker fails to load; could fall back to `workerSrc: null` (runs in main thread, slower but works) |
| PDF text extraction returns garbled/empty text | Medium -- no steps parsed | Medium | Show clear error "No text could be extracted from this PDF" with suggestion to try a different PDF; some PDFs are image-only or use custom encodings |
| pdfjs-dist bundle size (~500 KB) bloats app | Medium -- slower initial load | Low | Dynamic `import()` ensures pdfjs-dist only loads when user clicks Import; no impact on normal page load |
| Vite 7 compatibility issues with pdfjs-dist | Medium -- build/runtime errors | Low | pdfjs-dist 5.x is widely used with Vite; CDN worker avoids most bundler issues |
| Bullet parsing fails on unusual PDF formatting | Low -- incorrect steps parsed | Medium | Provide editable preview so manager can fix; fallback to line-per-step when no bullets detected |
| Large PDFs (100+ pages) cause browser slowdown | Medium -- poor UX | Low | 10 MB file size limit catches most oversized PDFs; could add page count warning for PDFs > 20 pages |

### Complexity
- **Level:** Medium
- **Rationale:**
  - Integrating a third-party library (pdfjs-dist) with worker configuration is the main complexity
  - The bullet parsing heuristic is straightforward but requires handling edge cases
  - The UI changes are minimal -- mostly reusing the existing TemplateModal with a new prop
  - No database changes, no new API endpoints, no backend work

## Open Questions

- [x] Q1: Should the import create a NEW modal or reuse the existing TemplateModal?
  - Resolution: Reuse the existing TemplateModal with an `initialSteps` prop. This is simpler, reduces code duplication, and maintains UI consistency.

- [x] Q2: What fields should be extracted from the PDF vs. filled in manually?
  - Resolution: Only step titles are extracted from bullet text. Template name, roles, status, step descriptions, owners, and experts are all filled in manually by the manager in the preview form.

- [x] Q3: How should multi-line bullets (wrapped text) be handled?
  - Resolution: V1 treats each line independently. Multi-line wrap may split a bullet across two "steps." The manager can fix this in preview. Future enhancement could use text positioning data from pdf.js for smarter line merging.

- [x] Q4: Should the PDF be uploaded to Supabase Storage?
  - Resolution: No. The PDF is processed entirely client-side and discarded after parsing. No server storage needed. This keeps the feature simple and avoids storage costs.

- [x] Q5: What is the maximum file size?
  - Resolution: 10 MB. This covers virtually all text-based onboarding PDFs while preventing browser memory issues.

- [x] Q6: Should the feature support drag-and-drop file upload?
  - Resolution: Not for v1. A simple file picker button is sufficient. Drag-and-drop can be added later as an enhancement.

- [x] Q7: How to handle the pdfjs-dist worker in tests?
  - Resolution: Mock `pdfjs-dist` entirely in Vitest tests. The parser logic (bullet regex matching) can be tested independently of pdf.js by passing raw text strings directly to `parseBulletsToSteps()`. The `extractTextFromPdf()` function will be tested with mocked pdf.js APIs.

- [x] Q8: CDN vs. local worker file for pdfjs-dist?
  - Resolution: CDN (unpkg) for simplicity. No build config changes needed. The app already requires internet for Supabase connectivity, so CDN dependency is not an additional constraint.

## Recommended Approach

### Implementation Strategy

Use the "simpler approach" described in the UI/UX section: add an `initialSteps` prop to the existing `TemplateModal` rather than building a separate import modal. This minimizes new code and maximizes reuse.

### Order of Work

1. **Install `pdfjs-dist` and create `src/utils/pdfParser.ts`**
   - `extractTextFromPdf(file: File): Promise<string>` -- PDF to raw text
   - `parseBulletsToSteps(rawText: string): ParsedStep[]` -- raw text to step array
   - Unit tests for `parseBulletsToSteps()` with various bullet formats
   - Unit tests for `extractTextFromPdf()` with mocked pdfjs-dist

2. **Update `TemplateModal` to accept `initialSteps` prop**
   - Add `initialSteps?: Array<{title: string; description: string}>` to `TemplateModalProps`
   - In the create-mode `useEffect`, use `initialSteps` to pre-fill steps if provided
   - Add an info banner when steps came from PDF import ("X steps imported from PDF")
   - Unit tests for the new prop behavior

3. **Update `TemplatesView` with "Import from PDF" button**
   - Add secondary button with `FileUp` icon next to "Create Template"
   - Add hidden `<input type="file" accept=".pdf">` element
   - Add state for import processing: `importLoading`, `importError`, `importedSteps`
   - On file select: validate size, dynamically import pdfParser, extract + parse, open TemplateModal with `initialSteps`
   - Show loading indicator on button during processing
   - Show error toast if parsing fails
   - Unit tests for the import button and error handling

### What to Defer

- Drag-and-drop file upload (v2 enhancement)
- Multi-line bullet merging using text position data (v2 enhancement)
- PDF section header detection for auto-grouping steps (v2 enhancement)
- Step description extraction from sub-bullets (v2 enhancement)
- Support for other file formats (DOCX, TXT) (separate feature)

## Next Step

**All questions resolved.**
Run `/plan pdf-template-import` to create the implementation plan.
