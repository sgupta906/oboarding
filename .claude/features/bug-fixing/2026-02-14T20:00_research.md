# Research: bug-fixing

## Metadata
- **Feature:** bug-fixing
- **Created:** 2026-02-14T20:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context
- The user reports the webapp is choppy and buggy: role creation is slow/unresponsive, employee view has bugs, general choppiness
- This is a post-migration fix-up: the Firebase-to-Supabase migration is complete, basic UI bugs were fixed in webapp-rework, but deeper performance and UX issues remain
- This feature covers all remaining bugs, performance issues, and UX problems across the entire app

---

## BUGS FOUND

### CRITICAL

#### BUG-01: Every Realtime subscription re-fetches the ENTIRE table on ANY change (Cascade re-fetch storm)
- **Files:** All 8 `src/services/supabase/*Service.ts` files
- **Root Cause:** Every `subscribeTo*` function follows this pattern: on ANY postgres_changes event (INSERT, UPDATE, DELETE), it calls the corresponding `list*()` function which does `SELECT *` on the entire table. This means:
  - Creating a role triggers `listRoles()` (full table fetch)
  - But creating a role also triggers template subscription (`subscribeToTemplates`) if templates channel is listening, because templates reference roles
  - `subscribeToOnboardingInstances` listens to BOTH `onboarding_instances` AND `instance_steps` -- any step change re-fetches ALL instances with ALL their steps
  - `subscribeToUsers` listens to `users`, `user_roles`, AND `user_profiles` -- any junction table change re-fetches ALL users
  - `subscribeToTemplates` listens to `templates` AND `template_steps` -- any step change re-fetches ALL templates
- **Impact:** This is the PRIMARY cause of choppiness. When a role is created:
  1. `subscribeToRoles` fires -> `listRoles()` (1 query)
  2. The role creation in `createCustomRole` first calls `roleNameExists` (1 query), then `createRole` (1 query), then the subscription re-fetch (1 query) = 4 queries minimum for one role creation
  3. If the CreateOnboardingModal is open, `useRoles` and `useTemplates` both fire subscriptions
  4. Multiple components may each have their own `useRoles()` call, each creating separate subscriptions

#### BUG-02: Multiple independent `useRoles()` calls create DUPLICATE Supabase Realtime channels
- **Files:** `src/hooks/useRoles.ts`, `src/components/manager/RoleManagementPanel.tsx`, `src/components/modals/CreateOnboardingModal.tsx`, `src/components/templates/CreateTemplateModal.tsx`
- **Root Cause:** `useRoles()` is called independently in:
  1. `RoleManagementPanel.tsx` (line 38)
  2. `CreateOnboardingModal.tsx` (line 50)
  3. `CreateTemplateModal.tsx` (line 43)
  Each call to `useRoles()` calls `subscribeToRoles()` which creates a NEW Supabase channel named `'roles-all'`. Supabase may deduplicate channel names, but each hook instance does its own `listRoles()` initial fetch AND sets up its own callback, meaning 3 separate `SELECT * FROM roles` queries fire on mount, and 3 separate re-fetches fire on every role change.
- **Impact:** 3x network requests for roles data. Combined with BUG-01, this creates a cascade of redundant fetches.

#### BUG-03: `useRoles` hook creates a new subscription on every `refetch()` call without cleaning up the old one properly
- **Files:** `src/hooks/useRoles.ts` (lines 55-82)
- **Root Cause:** The `useEffect` depends on `[refetchCount]`. When `refetch()` is called, `refetchCount` increments, the old subscription cleanup runs, and a NEW subscription is created. But `subscribeToRoles` does an initial `listRoles()` fetch inside itself (line 206 of roleService.ts), so this creates a brief period where the old channel is being removed while a new initial fetch + new channel are starting. This is wasteful but not catastrophic. The bigger problem is that `refetch()` is never actually called in the role management flow -- the realtime subscription is supposed to handle updates -- making the refetch mechanism unused overhead.
- **Impact:** Medium -- adds complexity without value.

#### BUG-04: `updateStepStatus` is extremely inefficient -- fetches entire instance, rebuilds all steps, then does DELETE + INSERT for ALL steps
- **Files:** `src/services/supabase/instanceService.ts` (lines 223-259)
- **Root Cause:** To update ONE step's status, the code:
  1. Fetches the entire instance with all steps (`getOnboardingInstance`) -- 1 query with join
  2. Validates stepId exists
  3. Maps all steps to create updated array
  4. Calls `updateOnboardingInstance` which:
     a. Updates the instance row (1 query)
     b. DELETES all step rows (1 query)
     c. RE-INSERTS all step rows (1 query)
  Total: 4 database round-trips to change one field on one step row.
  This should be a single `UPDATE instance_steps SET status = $1 WHERE instance_id = $2 AND position = $3`.
- **Impact:** This is why step status changes feel slow. Each click fires 4 queries and then triggers realtime re-fetches across multiple subscriptions.

#### BUG-05: `syncTemplateStepsToInstances` fetches ALL instances to find ones using a template
- **Files:** `src/services/supabase/templateService.ts` (lines 184-223)
- **Root Cause:** When a template is updated, `syncTemplateStepsToInstances` calls `listOnboardingInstances()` which fetches ALL instances with ALL their steps, then filters in JavaScript. It should use a database query: `SELECT * FROM onboarding_instances WHERE template_id = $1`.
- **Impact:** O(n) data transfer where n = total instances. Gets worse as the app scales.

### HIGH

#### BUG-06: `isRoleInUse` makes 3 sequential database queries
- **Files:** `src/services/supabase/roleService.ts` (lines 78-107)
- **Root Cause:** To check if a role is in use, it:
  1. Fetches the role by ID (`getRole`) to get the role name
  2. Queries templates table filtered by role name
  3. Queries onboarding_instances table filtered by role name
  These 3 queries run sequentially. Queries 2 and 3 could run in parallel with `Promise.all()`. Query 1 could be avoided if the caller passed the role name.
- **Impact:** Adds ~300-500ms latency to delete operations.

#### BUG-07: `createCustomRole` validation makes a network round-trip before creation
- **Files:** `src/services/roleClient.ts` (lines 180-205)
- **Root Cause:** `createCustomRole` calls `validateRoleNameUniqueness` which calls `roleNameExists` which does a `SELECT` query. Then it calls `dbCreateRole` which does an `INSERT`. The uniqueness check should be handled by a database UNIQUE constraint (which already exists on the roles table), so the client-side check is redundant network overhead. The INSERT would fail with a duplicate key error if the name exists.
- **Impact:** Adds ~100-200ms latency to every role creation. The user already sees "takes forever" after creating a role.

#### BUG-08: `OnboardingHub` always runs `useSteps` for `selectedInstance` even when no instance is selected
- **Files:** `src/components/OnboardingHub.tsx` (lines 76-78)
- **Root Cause:** `useSteps(selectedInstance?.id ?? '')` is called unconditionally. When `selectedInstance` is null, it passes empty string `''` to `useSteps`, which then checks `if (!instanceId)` and bails out. But the hook still runs its useEffect every render, setting loading states unnecessarily.
- **Impact:** Unnecessary hook execution on every render.

#### BUG-09: `useEmployeeOnboarding` runs for managers viewing employee tab, creating a subscription to the wrong email
- **Files:** `src/components/OnboardingHub.tsx` (lines 45-52)
- **Root Cause:** `employeeEmail` is set to `null` when user is a manager (`!isManager ? user?.email ?? null : null`), so `useEmployeeOnboarding(null)` is called. The hook correctly handles null by returning early. However, `useSteps(employeeInstance?.id ?? '')` is also called, and when `employeeInstance` is null, it passes empty string. This means two hooks are running useEffects that immediately bail out -- not a bug per se, but unnecessary computation.
- **Impact:** Low -- hooks bail out correctly.

#### BUG-10: No loading indicator during role creation -- user sees nothing happen
- **Files:** `src/components/modals/CreateRoleModal.tsx`, `src/components/manager/RoleManagementPanel.tsx`
- **Root Cause:** The CreateRoleModal does show a spinner during submission (lines 161-164), and `isCreateSubmitting` is properly managed. However, after the modal closes (`setIsCreateModalOpen(false)` on line 80 of RoleManagementPanel), the roles list relies entirely on the realtime subscription to update. If the subscription is slow (BUG-01 cascade), the user sees the modal close but no new role appear for several seconds. There is no optimistic update.
- **Impact:** This is the "takes forever to load after creating a role" complaint. The modal closes immediately but the list doesn't update until the subscription callback fires.

#### BUG-11: `TemplatesView` calls both `refetch()` AND relies on subscription, causing double data fetch
- **Files:** `src/views/TemplatesView.tsx` (lines 49, 70, 88)
- **Root Cause:** After `createTemplate`, `updateTemplate`, and `deleteTemplate`, the code calls `refetch()` on the `useTemplates` hook. But `useTemplates` is ALREADY subscribed to realtime changes via `subscribeToTemplates`. So every mutation triggers TWO re-fetches:
  1. The manual `refetch()` call which creates a new subscription (destroying the old one)
  2. The realtime event that fires because the database changed
  The `refetch()` increments `refetchCount` in useTemplates, which tears down the old subscription and creates a new one, doing a fresh `listTemplates()` fetch. Then the realtime event fires on the NEW subscription, doing ANOTHER `listTemplates()` fetch.
- **Impact:** Double network request on every template CRUD operation.

#### BUG-12: `useUsers` does optimistic local update AND gets subscription update, causing potential flickering
- **Files:** `src/hooks/useUsers.ts` (lines 56-59, 83-85)
- **Root Cause:** `createNewUser` does `setUsers((prevUsers) => [...prevUsers, newUser])` for immediate feedback, then `subscribeToUsers` also fires and does `setUsers(updatedUsers)`. If the subscription data arrives in a different order or has slightly different data (e.g., different timestamp precision), the list could flicker between the optimistic and real states.
- **Impact:** Potential brief visual flicker after creating/deleting users.

#### BUG-13: `deleteUser` uses `window.confirm` -- a synchronous browser dialog that blocks the React rendering thread
- **Files:** `src/components/manager/UsersPanel.tsx` (line 129)
- **Root Cause:** Uses native `window.confirm()` instead of a React modal. This blocks the main thread, doesn't match the app's visual style, and cannot be styled. All other delete flows use `DeleteConfirmationDialog` component.
- **Impact:** Inconsistent UX, potential jank when dialog appears.

### MEDIUM

#### BUG-14: `subscribeToEmployeeInstance` listens to ALL `onboarding_instances` changes, not just the employee's
- **Files:** `src/services/supabase/instanceService.ts` (lines 550-566)
- **Root Cause:** The channel subscribes to `{ event: '*', schema: 'public', table: 'onboarding_instances' }` without a filter. This means ANY instance change (for any employee) triggers a re-fetch for this specific employee. Should use `filter: \`employee_email=eq.${normalizedEmail}\`` to scope the subscription.
- Similarly, the `instance_steps` subscription has no filter at all -- any step change for any instance triggers a re-fetch.
- **Impact:** Unnecessary re-fetches when other employees' data changes.

#### BUG-15: `subscribeToOnboardingInstances` listens to ALL `instance_steps` changes with no filter
- **Files:** `src/services/supabase/instanceService.ts` (lines 496-506)
- **Root Cause:** The subscription on `instance_steps` has no filter. ANY step change re-fetches ALL instances. This is the most expensive subscription pattern -- a single step status change triggers `listOnboardingInstances()` which does `SELECT *, instance_steps(*)` on ALL instances.
- **Impact:** O(n*m) data transfer on every step change, where n = instances, m = average steps per instance.

#### BUG-16: `profileTemplateService` subscription listens to ALL `profile_template_steps` changes, not scoped to profile
- **Files:** `src/services/supabase/profileTemplateService.ts` (lines 251-258)
- **Root Cause:** The `profile_template_steps` subscription has no filter. Changes to steps in any profile template trigger re-fetches for the subscribed profile.
- **Impact:** Unnecessary re-fetches when other profile templates change.

#### BUG-17: `createOnboardingRunFromTemplate` does lazy import of `userService` on every call
- **Files:** `src/services/supabase/instanceService.ts` (lines 355-356)
- **Root Cause:** Uses `await import('./userService')` inside the function body to avoid circular dependency. This dynamic import runs every time the function is called. While V8 caches modules after first import, the `await` still creates an async overhead.
- **Impact:** Minor latency added to onboarding creation.

#### BUG-18: `syncTemplateStepsToInstances` also does lazy import of `instanceService` on every call
- **Files:** `src/services/supabase/templateService.ts` (lines 187)
- **Root Cause:** Same pattern as BUG-17. Uses `await import('./instanceService')` to avoid circular dependency.
- **Impact:** Minor latency added to template updates.

#### BUG-19: `TemplatesView` delete button opens EDIT modal instead of delete confirmation
- **Files:** `src/views/TemplatesView.tsx` (lines 293-300)
- **Root Cause:** The delete button (Trash2 icon) in the template card footer calls `handleEditClick(template)` instead of a delete handler. The user clicks the trash icon expecting to delete, but sees the edit modal instead. This is a copy-paste bug.
- **Impact:** Confusing UX -- delete button doesn't delete.

#### BUG-20: `DarkModeProvider` renders children WITHOUT context value on first render
- **Files:** `src/context/DarkModeContext.tsx` (lines 57-59)
- **Root Cause:** Before `isInitialized` is set to `true`, the provider renders `<>{children}</>` without wrapping in `DarkModeContext.Provider`. This means any child component that calls `useDarkMode()` during the first render will throw an error: "useDarkMode must be used within a DarkModeProvider".
- **Impact:** Potential crash on first render if timing is wrong. In practice, the `useEffect` runs synchronously enough that `isInitialized` becomes true before children render, but this is fragile.

#### BUG-21: `StepCard` has no dark mode support for text colors
- **Files:** `src/components/onboarding/StepCard.tsx` (lines 77, 114, 117)
- **Root Cause:** Text elements use `text-slate-900`, `text-slate-600`, `text-slate-500` without `dark:` variants. In dark mode, text is unreadable against dark backgrounds.
- **Impact:** Broken dark mode for employee onboarding view.

#### BUG-22: Activity `timeAgo` values are static strings, not computed relative times
- **Files:** `src/services/supabase/activityService.ts` (line 39), `src/components/OnboardingHub.tsx` (lines 101, 134, 156, 169, 180)
- **Root Cause:** Activities are logged with `timeAgo: 'just now'` as a static string. This value is stored in the database and never recalculated. So all activities forever show "just now" regardless of when they actually happened. The `timestamp` field exists but is never used to compute a relative time.
- **Impact:** Activity feed shows inaccurate times. Every activity shows "just now".

#### BUG-23: `CreateOnboardingModal` dark mode support missing for form inputs
- **Files:** `src/components/modals/CreateOnboardingModal.tsx` (lines 237-241, 272-278, etc.)
- **Root Cause:** Form input fields use `border-slate-300`, `text-slate-700`, `bg-red-50` without `dark:` variants. Labels use `text-slate-700` without dark variant. The info boxes use `bg-blue-50`, `text-blue-900` without dark variants.
- **Impact:** Form inputs are unreadable in dark mode.

#### BUG-24: `CreateRoleModal` dark mode support missing for form inputs
- **Files:** `src/components/modals/CreateRoleModal.tsx` (lines 189, 203-208, etc.)
- **Root Cause:** Same as BUG-23 -- form inputs and labels lack `dark:` variants.
- **Impact:** Form inputs are unreadable in dark mode.

#### BUG-25: `CreateTemplateModal` dark mode support missing for all form elements
- **Files:** `src/components/templates/CreateTemplateModal.tsx`
- **Root Cause:** Entire form uses light-only colors: `text-slate-700`, `border-slate-300`, `bg-slate-100`, `text-slate-600`, `border-slate-200` etc. without any `dark:` variants.
- **Impact:** Entire template creation form is broken in dark mode.

### LOW

#### BUG-26: `handleDuplicateTemplate` creates template with `createdAt: undefined` which gets passed as a property
- **Files:** `src/views/TemplatesView.tsx` (lines 98-105)
- **Root Cause:** `const newTemplate = { ...template, name: \`${template.name} (Copy)\`, createdAt: undefined }`. The spread copies the original `createdAt`, then it's set to `undefined`. The `Omit<Template, 'id' | 'createdAt'>` type should exclude `createdAt`, but the runtime still sends `undefined` to `handleCreateTemplate` -> `createTemplate`. The service generates a new `created_at` so this is harmless, but it's sloppy.
- **Impact:** No functional impact, but code smell.

#### BUG-27: `seedDefaultRoles` runs sequentially, creating roles one at a time
- **Files:** `src/services/roleClient.ts` (lines 312-326)
- **Root Cause:** Uses a `for...of` loop with `await dbCreateRole(roleName, undefined, userId)` for each of 7 default roles. Could use `Promise.all()` to create all roles in parallel.
- **Impact:** Seeding takes 7x longer than necessary. Only affects first-run.

#### BUG-28: `signInWithEmailLink` dispatches `authStorageChange` event TWICE
- **Files:** `src/views/SignInView.tsx` (lines 105-109), `src/services/authService.ts` (lines 145-149, 226-231)
- **Root Cause:** `signInWithEmailLink` in authService.ts dispatches the event, then `handleSubmit` in SignInView.tsx dispatches it AGAIN. The AuthProvider handles it idempotently, but it's unnecessary.
- **Impact:** Double event dispatch, double `loadMockAuthFromStorage()` call. No visible effect.

#### BUG-29: `areUsersEqual` does O(n) comparison with JSON.stringify on every check
- **Files:** `src/services/supabase/userService.ts` (lines 427-444)
- **Root Cause:** Uses `JSON.stringify(user1.roles) === JSON.stringify(user2.roles)` for array comparison. This is fine for small arrays but is a code smell. More importantly, this function is defined but NEVER CALLED anywhere in the codebase.
- **Impact:** Dead code. No impact.

#### BUG-30: Multiple `Intl.DateTimeFormat` instances created on every render in `RoleManagementPanel`
- **Files:** `src/components/manager/RoleManagementPanel.tsx` (lines 131-140)
- **Root Cause:** `formatDate` function is called for every role row on every render, creating a new `Intl.DateTimeFormat` instance each time. Should be memoized or created once.
- **Impact:** Minor GC pressure if many roles exist.

---

## PERFORMANCE ISSUES

### P1: Subscription Re-fetch Storm (Root Cause of Choppiness)

**How it works today:**
1. User creates a role
2. `createCustomRole` calls `roleNameExists` (query 1), then `dbCreateRole` (query 2)
3. The INSERT triggers a Postgres notification
4. `subscribeToRoles` callback fires -> calls `listRoles()` (query 3)
5. If `CreateOnboardingModal` is mounted, ITS `useRoles()` hook ALSO has a subscription -> `listRoles()` again (query 4)
6. If `CreateTemplateModal` is mounted, ITS `useRoles()` hook fires too -> `listRoles()` again (query 5)
7. Each `setRoles()` call triggers React re-renders in each component
8. Multiple re-renders cascade through the component tree

**What it should do:**
1. Use a SINGLE centralized roles cache/store that all components share
2. After creation, either optimistically add the role OR let the single subscription update the single cache
3. Total queries: 1 (INSERT) + 1 (re-fetch from subscription) = 2

### P2: Full-Table Re-fetch on Step Status Change

**How it works today (BUG-04):**
1. Employee clicks "Complete" on a step
2. `updateStepStatus` fetches the entire instance (query 1)
3. Validates, then calls `updateOnboardingInstance` which:
   - Updates instance row (query 2)
   - DELETES all steps (query 3)
   - RE-INSERTS all steps (query 4)
4. This triggers `onboarding_instances` AND `instance_steps` realtime events
5. `subscribeToOnboardingInstances` fires -> `listOnboardingInstances()` re-fetches ALL instances (query 5)
6. `subscribeToSteps` fires -> re-fetches this instance's steps (query 6)
7. `subscribeToEmployeeInstance` fires -> re-fetches this employee's instance (query 7)

**What it should do:**
1. `UPDATE instance_steps SET status = $1 WHERE instance_id = $2 AND position = $3` (1 query)
2. Update progress on the instance row (1 query)
3. Let 1 subscription update the UI = total 3 queries

### P3: No Data Caching or Deduplication
- Every hook manages its own state independently
- Opening the CreateOnboardingModal re-fetches roles AND templates even though they may already be loaded elsewhere
- No shared state between components (no React Context for data, no global store)

---

## MISSING UX PATTERNS

1. **No optimistic updates** -- All mutations wait for the subscription to re-fetch before showing changes
2. **No loading skeletons** in ManagerView dashboard tab while `isDashboardLoading` is true (just shows text "Loading dashboard...")
3. **No error boundary** -- Any uncaught error in a subscription crashes the whole app
4. **No retry logic** on failed Supabase queries (fetch once, throw on error)
5. **No connection status indicator** -- User doesn't know if Supabase is connected or not
6. **No toast notifications** -- Success/error messages are inline and disappear after timeout, not persistent toasts
7. **Activity timestamps are static** (BUG-22) -- always shows "just now"
8. **Template delete button opens edit modal** (BUG-19)

---

## DATABASE/QUERY ISSUES

1. **RLS policies are fully permissive** (`USING (true) WITH CHECK (true)`) -- any user can do anything to any row. This is marked as temporary but is a security concern.
2. **No pagination** on any list query -- `listActivities()`, `listOnboardingInstances()`, etc. all fetch everything
3. **The `isRoleInUse` function queries by role NAME, not ID** -- fragile if role names change
4. **`userEmailExists` uses `ilike` which may not use indexes efficiently** depending on collation
5. **`listOnboardingInstances` does `SELECT *, instance_steps(*)` with no ORDER BY** on the instances -- order is non-deterministic
6. **Activities table has no ORDER BY** in `listActivities()` -- activities appear in insertion order, not by timestamp

---

## EXISTING CODE ANALYSIS

### Project State
- Project exists: YES
- ~50 source files, ~650 unit tests (all mocked -- don't test real behavior)

### Patterns to Follow
- Service layer pattern: thin service functions that wrap Supabase queries
- Hook pattern: `useEffect` with subscription, cleanup on unmount
- Component pattern: functional components with hooks
- Modal pattern: `ModalWrapper` with `isOpen`/`onClose`/`footer` props

### Code to Reuse
- `ModalWrapper` component for all modals
- `DeleteConfirmationDialog` for consistent delete UX (replace `window.confirm` in UsersPanel)
- Service layer functions (fix, don't replace)
- Hooks (fix subscription patterns, don't rewrite from scratch)

### Code to Modify (all files that need changes)
| File | Issue(s) |
|------|----------|
| `src/services/supabase/roleService.ts` | BUG-01, BUG-06 |
| `src/services/supabase/instanceService.ts` | BUG-01, BUG-04, BUG-14, BUG-15, BUG-17 |
| `src/services/supabase/templateService.ts` | BUG-01, BUG-05, BUG-18 |
| `src/services/supabase/userService.ts` | BUG-01, BUG-29 |
| `src/services/supabase/activityService.ts` | BUG-01 |
| `src/services/supabase/suggestionService.ts` | BUG-01 |
| `src/services/supabase/profileService.ts` | BUG-01 |
| `src/services/supabase/profileTemplateService.ts` | BUG-01, BUG-16 |
| `src/services/roleClient.ts` | BUG-07 |
| `src/hooks/useRoles.ts` | BUG-02, BUG-03 |
| `src/hooks/useTemplates.ts` | BUG-11 |
| `src/hooks/useUsers.ts` | BUG-12 |
| `src/components/OnboardingHub.tsx` | BUG-08, BUG-09 |
| `src/components/manager/RoleManagementPanel.tsx` | BUG-10, BUG-30 |
| `src/components/manager/UsersPanel.tsx` | BUG-13 |
| `src/components/modals/CreateRoleModal.tsx` | BUG-24 |
| `src/components/modals/CreateOnboardingModal.tsx` | BUG-02, BUG-23 |
| `src/components/templates/CreateTemplateModal.tsx` | BUG-02, BUG-25 |
| `src/components/onboarding/StepCard.tsx` | BUG-21 |
| `src/views/TemplatesView.tsx` | BUG-11, BUG-19, BUG-26 |
| `src/views/SignInView.tsx` | BUG-28 |
| `src/context/DarkModeContext.tsx` | BUG-20 |

---

## CONSTRAINTS

### Performance
- Supabase Realtime has a limit of ~100 concurrent channels per client
- Each `subscribeTo*` call creates at least 1 channel, some create 2-3
- With current architecture, a single page view can create 10+ channels

### Platform
- Supabase free tier: 500MB database, 2GB bandwidth
- Full-table re-fetches consume bandwidth rapidly

### Dependencies
- `@supabase/supabase-js` handles channel management
- Tailwind CSS 3 for dark mode (class-based strategy)

---

## RISK ASSESSMENT

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Fixing subscriptions breaks existing tests | Medium | High | Tests mock supabase, so service changes won't break tests. But new behavior needs new tests. |
| Optimistic updates cause stale data | Medium | Medium | Always reconcile with subscription data. Use subscription as source of truth, optimistic as preview. |
| Changing `updateStepStatus` to direct UPDATE breaks step validation | Low | Low | Add a WHERE clause that validates the step exists. |
| Too many changes at once create regressions | High | Medium | Phase the work: fix critical performance first, then UX, then dark mode. |

### Complexity
- **Level:** Medium-High
- **Rationale:** The core issue (subscription storm) touches all 8 service files, all hooks, and several components. However, each individual fix is straightforward. The challenge is doing them all without introducing regressions.

---

## OPEN QUESTIONS

- [x] Q1: Should we implement a global state management solution (React Context, Zustand)?
  - Resolution: No. The current hook pattern is fine. The fix is to make subscriptions smarter (scoped, deduplicated) rather than adding a state library. A shared context per data type could help with deduplication but is not required for the first pass.

- [x] Q2: Should we add pagination to list queries?
  - Resolution: Not yet. The app is designed for small-to-medium orgs. Add pagination later when data volume becomes an issue.

- [x] Q3: Should we fix RLS policies as part of this?
  - Resolution: No. RLS is a separate security feature that should get its own pipeline pass. The current permissive policies work for development.

---

## RECOMMENDED APPROACH

### Implementation Strategy

Fix bugs in phases ordered by user-perceived impact:

### Phase 1: Fix Core Performance (Maximum user impact, fixes "choppiness" and "slow role creation")
1. **Fix `updateStepStatus`** -- Direct SQL update instead of fetch-delete-reinsert (BUG-04)
2. **Remove redundant uniqueness check** in `createCustomRole` -- rely on DB constraint (BUG-07)
3. **Add optimistic updates** to `useRoles.createRole` -- immediately add to local state (BUG-10)
4. **Remove double-fetch** in `TemplatesView` -- don't call `refetch()` when subscription handles it (BUG-11)
5. **Scope realtime subscriptions** -- add filters to reduce unnecessary re-fetches (BUG-14, BUG-15, BUG-16)

### Phase 2: Fix Functional Bugs
6. **Fix template delete button** -- point to delete handler, not edit (BUG-19)
7. **Replace `window.confirm`** with `DeleteConfirmationDialog` in UsersPanel (BUG-13)
8. **Fix `DarkModeProvider`** initial render -- always wrap in provider (BUG-20)
9. **Fix activity timestamps** -- compute relative time from `timestamp` field (BUG-22)

### Phase 3: Dark Mode Fixes
10. **Add dark mode** to `StepCard` (BUG-21)
11. **Add dark mode** to `CreateRoleModal` (BUG-24)
12. **Add dark mode** to `CreateOnboardingModal` (BUG-23)
13. **Add dark mode** to `CreateTemplateModal` (BUG-25)

### Phase 4: Optimization (Can defer)
14. Parallelize `isRoleInUse` queries (BUG-06)
15. Fix `syncTemplateStepsToInstances` to use filtered query (BUG-05)
16. Remove dead code (`areUsersEqual`) (BUG-29)
17. Remove duplicate `authStorageChange` dispatch (BUG-28)

### What to Defer
- Global state management / data caching layer
- Pagination on list queries
- RLS policy hardening
- Error boundary component
- Connection status indicator
- Deduplicating `useRoles()` across components (shared context)

### Order of Work
1. Service layer performance fixes (Phase 1, items 1-5) -- ~5 files
2. Functional bug fixes (Phase 2, items 6-9) -- ~4 files
3. Dark mode fixes (Phase 3, items 10-13) -- ~4 files
4. Optimization cleanup (Phase 4, items 14-17) -- ~4 files

### Estimated Scope
- **Files to modify:** ~22 files
- **New files:** 0 (fixes in existing code)
- **Test impact:** Existing mocked tests should still pass. New test coverage for optimistic updates and direct step update.
- **Estimated effort:** Medium -- each fix is isolated and straightforward, but there are many of them.

---

## Next Step

**All questions resolved. Status: research-complete.**

Run `/plan bug-fixing` to create the implementation plan.
