# Research: manager-modal-fixes

## Metadata
- **Feature:** manager-modal-fixes (Bugs #5 and #28)
- **Created:** 2026-02-16T23:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context
- **Description:** Two bugs bundled together -- both relate to manager-facing UI components:
  - **Bug #5** (`manager-markdone-broken`): "Mark as Done" in manager's Employee View does nothing
  - **Bug #28** (`modal-stale-form-data`): Modal forms retain stale data from previous open/close cycles
- **Where it fits:** These are post-Zustand-migration bugs in the manager dashboard interaction layer
- **Dependencies:** No prerequisite features; both are isolated fixes in existing components

---

## Requirements

### Functional Requirements
- FR1: When a manager views an employee's onboarding via Employee View, the "Mark as Done" / "Mark as Incomplete" / "I'm Stuck" / "Suggest Edit" buttons are hidden and a "View Only" indicator is shown (source: bug #5 in STATUS.md)
- FR2: All modal forms (CreateOnboardingModal, UserModal, RoleModal, TemplateModal, SuggestEditModal, ReportStuckModal) reset to a clean state every time they open, regardless of what happened during the previous open/close cycle (source: bug #28 in scouting report)
- FR3: No regressions in existing modal functionality -- validation, submission, error display, pre-fill (edit mode) continue to work

### Technical Requirements
- TR1: Existing test suite continues passing after changes
- TR2: New unit tests cover: (a) form reset on re-open, (b) read-only mode for managers viewing employee steps
- TR3: Follow established patterns -- Zustand store for data, component-level useState for UI-only state

### Constraints
- Must not break the existing `handleClose` -> `resetForm` flow that already exists in some modals
- Must not break edit mode pre-fill logic (UserModal, RoleModal, TemplateModal use `useEffect` to pre-fill from props)

---

## Bug #5: manager-markdone-broken

### Root Cause Analysis

The bug is in `src/components/OnboardingHub.tsx` at line 74-98.

**The `handleStatusChange` function:**
```typescript
const handleStatusChange = async (id: number, newStatus: StepStatus) => {
    if (!employeeInstance?.id) return;  // <-- THIS IS THE BUG
    setLoadingStepIds((prev) => new Set(prev).add(id));
    try {
      await updateStatus(id, newStatus);
      // ... activity logging uses employeeInstance.employeeName
    }
};
```

**Why it fails for managers:**
1. `employeeInstance` (line 43-46) is only populated for non-managers:
   ```typescript
   const employeeEmail = !isManager ? user?.email ?? null : null;
   const { instance: employeeInstance } = useEmployeeOnboarding(employeeEmail);
   ```
   For managers, `employeeEmail` is `null`, so `useEmployeeOnboarding(null)` returns `instance: null`.

2. When a manager selects an employee via the EmployeeSelector, a `selectedInstance` is created (line 58-61) and `selectedInstanceSteps` are loaded (line 64-66).

3. But `handleStatusChange` checks `if (!employeeInstance?.id) return;` -- this early-returns because `employeeInstance` is always null for managers.

4. The handler is still passed to EmployeeView via `onStatusChange={handleStatusChange}` (line 223), so the "Mark as Done" button renders and is clickable -- it just silently does nothing.

**Business Logic Decision:**
The STATUS.md note says "managers shouldn't update employee steps anyway". This is the correct business logic: only the employee themselves should mark their steps as done/stuck/pending. A manager viewing an employee's onboarding should see it as **read-only**.

**Recommended Fix:**
Pass a `readOnly` flag (or equivalent) from OnboardingHub to EmployeeView when a manager is viewing. The ActionBar should hide or disable the action buttons when in read-only mode.

Specifically:
- Add `readOnly?: boolean` prop to `EmployeeView`, `StepTimeline`, `StepCard`, and `ActionBar`
- When `isManager && currentView === 'employee'`, pass `readOnly={true}`
- In `ActionBar`, when `readOnly` is true, hide all buttons or show a read-only indicator

### Files Involved (Bug #5)
| File | Change |
|------|--------|
| `src/components/OnboardingHub.tsx` | Pass `readOnly={isManager && currentView === 'employee'}` to EmployeeView |
| `src/views/EmployeeView.tsx` | Accept and forward `readOnly` prop |
| `src/components/onboarding/StepTimeline.tsx` | Accept and forward `readOnly` prop |
| `src/components/onboarding/StepCard.tsx` | Accept and forward `readOnly` prop |
| `src/components/onboarding/ActionBar.tsx` | Hide action buttons when `readOnly` is true |
| `src/types/index.ts` | Add `readOnly` to `StepCardProps` and `ActionBarProps` |

---

## Bug #28: modal-stale-form-data

### Root Cause Analysis

The scouting report identified that modals are always-mounted in the React tree. When `ModalWrapper` returns `null` on `!isOpen`, the parent modal component and its `useState` hooks persist. The form data survives across open/close cycles if the reset logic has gaps.

**Current Modal Mounting Patterns (6 modals):**

| Modal | Where Mounted | Pattern | Has handleClose Reset? | Has useEffect Reset? |
|-------|--------------|---------|----------------------|---------------------|
| `CreateOnboardingModal` | `ManagerView.tsx:304` | Always mounted | YES (resetForm in handleClose) | NO |
| `UserModal` (create) | `UsersPanel.tsx:296` | Always mounted | YES (resetForm in handleClose) | NO |
| `UserModal` (edit) | `UsersPanel.tsx:311` | Always mounted | YES (resetForm in handleClose) | YES (pre-fill on user+isOpen change) |
| `RoleModal` (create) | `RoleManagementPanel.tsx:358` | Always mounted | YES (handleClose resets) | NO |
| `RoleModal` (edit) | `RoleManagementPanel.tsx:371` | Conditionally mounted (`{selectedRoleForEdit && ...}`) | YES | NO (uses initial useState) |
| `TemplateModal` (create) | `TemplatesView.tsx:306` | Always mounted | YES (resetForm in handleClose) | NO |
| `TemplateModal` (edit) | `TemplatesView.tsx:321` | Always mounted | YES (resetForm in handleClose) | YES (pre-fill on template+isOpen change) |
| `SuggestEditModal` | `OnboardingHub.tsx:237` | Conditionally mounted (`{currentStep && employeeInstance && ...}`) | YES (handleClose resets text) | NO |
| `ReportStuckModal` | `OnboardingHub.tsx:245` | Conditionally mounted (same guard) | N/A (no form state) | N/A |

**Where the stale data can persist:**

Looking at the actual code, the `handleClose` function in most modals DOES call `resetForm()`. So the question is: when can a close happen WITHOUT `handleClose` being called?

1. **ModalWrapper's close paths all go through the `onClose` prop**, which in each modal is `handleClose`. So backdrop click, Escape, X button all call `handleClose`. This means the reset SHOULD work.

2. **However, there are edge cases:**
   - **RoleModal (create mode)**: The initial `useState` is hardcoded to empty strings, but if `handleClose` is called, it resets properly. The issue is that RoleModal's `handleClose` resets `name` and `description` to empty, but `touched` state is also reset. This should work.
   - **TemplateModal (create mode)**: `resetForm()` creates a new step with `nextStepUid()` which increments the module-level `stepUidCounter`. Not a user-visible issue, but `_uid` values will keep growing. The real concern is whether the form fields are cleared.
   - **CreateOnboardingModal**: `resetForm()` clears all fields. `handleClose` calls `resetForm()` then `onClose()`. But `onClose()` from ManagerView is `handleCloseCreateOnboarding` which sets `isCreateOnboardingOpen(false)`. This should work.

3. **The real gap is defense-in-depth**: If ANY code path sets `isOpen` to `false` without going through the modal's `handleClose`, the form data persists. Current code does call `handleClose` consistently, but this is fragile.

**Recommended Fix:**
Add a `useEffect` hook in each modal that resets form state when `isOpen` transitions to `true`. This provides defense-in-depth: even if `handleClose` was missed or the parent directly toggles `isOpen`, the form will always start clean.

```typescript
useEffect(() => {
  if (isOpen) {
    resetForm();
  }
}, [isOpen]);
```

For edit-mode modals, the `useEffect` should pre-fill from props (which some already do).

### Files Involved (Bug #28)
| File | Change |
|------|--------|
| `src/components/modals/CreateOnboardingModal.tsx` | Add `useEffect` to reset form when `isOpen` becomes true |
| `src/components/modals/UserModal.tsx` | Add `useEffect` to reset form when `isOpen` becomes true (create mode) |
| `src/components/modals/RoleModal.tsx` | Add `useEffect` to reset form when `isOpen` becomes true |
| `src/components/templates/TemplateModal.tsx` | Add `useEffect` to reset form when `isOpen` becomes true (create mode) |
| `src/components/modals/SuggestEditModal.tsx` | Add `useEffect` to reset text/validation when `isOpen` becomes true |

Note: `ReportStuckModal` has no form state to reset. Edit-mode modals already have pre-fill `useEffect` hooks that run on `isOpen` change, so they are partially covered but should be reviewed.

---

## Existing Code Analysis

### Project State
- Project exists: YES
- Branch: `zustand-migration-bugfixes`
- 474 tests passing across ~30 test files
- Zustand migration complete (5/5 slices)
- 27 features completed in pipeline

### Code to Reuse
- `ModalWrapper` (`src/components/ui/ModalWrapper.tsx`): No changes needed -- it already correctly calls `onClose` on all close paths
- `ActionBar` pattern: The existing conditional rendering (`{!isCompleted ? ... : ...}`) is a good foundation for adding the `readOnly` branch

### Code to Modify
- `OnboardingHub.tsx`: Pass `readOnly` prop when manager views employee
- `EmployeeView.tsx`: Accept and forward `readOnly` prop
- `StepTimeline.tsx`: Accept and forward `readOnly` prop
- `StepCard.tsx`: Accept and forward `readOnly` prop
- `ActionBar.tsx`: Render read-only state when `readOnly=true`
- All 5 modal components: Add `useEffect` reset on `isOpen` transition

### Patterns to Follow
- Props flow: OnboardingHub -> EmployeeView -> StepTimeline -> StepCard -> ActionBar
- Types defined in `src/types/index.ts` -- add `readOnly` to `StepCardProps` and `ActionBarProps`
- `useEffect` pattern already established in `UserModal` (edit mode, line 56-65) and `TemplateModal` (edit mode, line 70-87)
- Each modal has a `resetForm()` helper that knows how to clear all state

---

## Constraints

### Performance
- No performance impact -- these are UI-only changes (a new boolean prop, a useEffect that runs on open)

### Platform
- No platform-specific constraints

### Dependencies
- No new dependencies needed
- All changes are within existing component files

---

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| `useEffect` reset fights with edit-mode pre-fill | Medium | Low | Edit-mode modals already have `useEffect` for pre-fill; ensure reset only applies to create mode or runs before pre-fill |
| Breaking existing `handleClose` flow | Medium | Low | The `useEffect` is additive -- it doesn't remove the existing `handleClose` reset. Both can coexist. |
| `readOnly` prop not reaching ActionBar through all component layers | Low | Low | Straightforward prop drilling through 4 components -- well-tested pattern in this codebase |
| Module-level `stepUidCounter` in TemplateModal keeps incrementing | Low | Certain | Not user-visible; UIDs are only used as React keys. Not worth fixing. |

### Complexity
- **Level:** Simple
- **Rationale:** Bug #5 is a single boolean prop threaded through 4 components. Bug #28 is a single `useEffect` added to 5 modal components. Both are low-risk, well-understood patterns with no architectural changes.

---

## Open Questions

- [x] Q1: Should managers be able to update employee steps at all?
  - Resolution: NO. The STATUS.md explicitly says "managers shouldn't update employee steps anyway." The fix should make the Employee View read-only for managers.

- [x] Q2: Should we use conditional rendering (unmount/remount) or `useEffect` reset for modal stale data?
  - Resolution: `useEffect` reset. Conditional rendering would cause the component to unmount and remount on every open, which could cause flash/flicker and is a larger refactor. The `useEffect` approach is minimal, matches existing patterns (edit-mode modals already use it), and provides defense-in-depth without changing the component tree structure.

- [x] Q3: Which modals are affected by stale data?
  - Resolution: All 5 form-bearing modals need the `useEffect` reset: CreateOnboardingModal, UserModal, RoleModal, TemplateModal, SuggestEditModal. ReportStuckModal has no form state. Edit-mode modals already have partial coverage via pre-fill useEffect but should be reviewed.

- [x] Q4: Should the `readOnly` prop replace `onStatusChange` entirely, or should it be a separate flag?
  - Resolution: Separate `readOnly` boolean flag. This is cleaner than making `onStatusChange` optional, because ActionBar still needs the prop signature for TypeScript. The `readOnly` flag controls visibility of the buttons.

---

## Recommended Approach

### Implementation Strategy

**Bug #5 Fix (manager-markdone-broken):**
1. Add `readOnly?: boolean` to `EmployeeViewProps`, `StepTimelineProps`, `StepCardProps`, and `ActionBarProps` in types
2. In `OnboardingHub.tsx`, pass `readOnly={isManager && currentView === 'employee'}` to `MemoizedEmployeeView`
3. Thread `readOnly` through EmployeeView -> StepTimeline -> StepCard -> ActionBar
4. In `ActionBar`, when `readOnly` is true, render a simple "View Only" indicator instead of action buttons
5. Add tests for the read-only state in ActionBar

**Bug #28 Fix (modal-stale-form-data):**
1. In `CreateOnboardingModal`, add `useEffect` that calls `resetForm()` when `isOpen` changes to `true`
2. In `UserModal`, add `useEffect` for create mode that resets form when `isOpen` changes to `true` (edit mode already has pre-fill `useEffect`)
3. In `RoleModal`, add `useEffect` that resets form when `isOpen` changes to `true`
4. In `TemplateModal`, add `useEffect` for create mode that calls `resetForm()` when `isOpen` changes to `true` (edit mode already has pre-fill `useEffect`)
5. In `SuggestEditModal`, add `useEffect` that resets `text` and `showValidation` when `isOpen` changes to `true`
6. Add tests for each modal verifying form reset on re-open

### Order of Work
1. Bug #5 first (simpler, fewer files, no cross-cutting concern)
2. Bug #28 second (more files but each change is identical pattern)
3. Tests for both bugs
4. Manual verification via Playwright

### What to Defer
- **Module-level `stepUidCounter` growing forever** in TemplateModal -- cosmetic, no user impact
- **Removing the now-redundant `handleClose` reset** -- keep it for defense-in-depth, both `handleClose` and `useEffect` can coexist harmlessly

---

## Next Step

**All questions resolved. Status: research-complete.**

Run `/plan manager-modal-fixes` to create implementation plan.
