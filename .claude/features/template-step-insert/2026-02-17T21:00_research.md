# Research: template-step-insert

## Metadata
- **Feature:** template-step-insert
- **Created:** 2026-02-17T21:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context

**Description:** Add the ability to insert a new step at any position in the template step list (not just at the end). Currently, the "Add Step" button in TemplateModal always appends to the end of the step array. The user wants an "Insert Step Here" affordance that lets them add a blank step between any two existing steps. When the template is saved, changes must sync to existing onboarding instances via the existing `syncTemplateStepsToInstances()` function.

**Where it fits:** This is a UX enhancement to the template management workflow. It builds on features #14 (`template-no-step-reorder` -- ChevronUp/ChevronDown), #26 (`template-steps-ux`), and #36 (`template-step-sync-fix`). No other features depend on this.

**Dependencies on other features:** None. All prerequisite features are complete:
- Step reorder UI (ChevronUp/ChevronDown) -- feature #26, complete
- Template-to-instance sync (`syncTemplateStepsToInstances()`) -- feature #36, complete
- Step ID = array position fix (`id: index + 1`) -- feature #31, complete

## Requirements

### Functional Requirements
- [ ] FR1: User can insert a new blank step between any two existing steps in the TemplateModal step list (source: user request)
- [ ] FR2: User can insert a step before the first step (i.e., at position 0) (source: implied by "anywhere")
- [ ] FR3: The "Add Step" button at the top of the steps section continues to work, appending to the end (source: backward compatibility)
- [ ] FR4: After insertion, step numbers ("Step X of Y") update correctly for all steps (source: existing behavior, must not regress)
- [ ] FR5: After insertion, the new step is empty (blank title, description, owner, expert, link) with a stable `_uid` (source: existing pattern)
- [ ] FR6: When template is saved after inserting steps, `syncTemplateStepsToInstances()` propagates changes to active instances (source: user request, existing infrastructure)
- [ ] FR7: Insertion works in both create mode and edit mode (source: user request)
- [ ] FR8: Inserted steps can be immediately reordered, edited, or removed using existing controls (source: UX completeness)

### Technical Requirements
- [ ] TR1: Step IDs in submitted payload use 1-based array position (`id: index + 1`) as established by feature #31 (source: `TemplateModal.tsx:219`)
- [ ] TR2: Each new step gets a unique `_uid` from `nextStepUid()` for stable React keys (source: `TemplateModal.tsx:41-43`)
- [ ] TR3: The `syncTemplateStepsToInstances()` function uses title-based matching -- newly inserted steps (with new titles) will automatically be added as `status: 'pending'` to instances (source: `templateService.ts:207-218`)
- [ ] TR4: The `template_steps` table has a UNIQUE constraint on `(template_id, position)` -- the existing delete-then-insert pattern in `updateTemplate()` handles this correctly (source: migration `00002`, `templateService.ts:126-158`)
- [ ] TR5: No database migration needed -- the existing schema and service layer handle arbitrary step counts and positions

### Constraints
- The TemplateModal is already 629 lines; changes should be minimal and focused
- Must follow existing dark mode patterns (all new UI elements need `dark:` variants)
- Must follow existing accessibility patterns (aria-labels on buttons)
- Must work with existing lucide-react icon library

## Existing Code Analysis

### Project State
- Project exists: YES
- Total test count: ~633 tests

### Key Files to Modify

**1. `src/components/templates/TemplateModal.tsx` (PRIMARY)**

Current step management functions:
- `handleAddStep()` (line 170-172): Appends blank step to end of array
- `handleRemoveStep()` (line 174-176): Removes step by index
- `handleMoveStepUp()` (line 178-183): Swaps step with previous
- `handleMoveStepDown()` (line 185-190): Swaps step with next
- `handleStepChange()` (line 192-200): Updates individual step field

Current "Add Step" button (line 447-455):
```tsx
<button
  type="button"
  onClick={handleAddStep}
  className="flex items-center gap-1 text-sm text-brand-600 ..."
  aria-label="Add new step"
>
  <Plus size={16} />
  Add Step
</button>
```

Step card header row (lines 464-498): Contains "Step X of Y" badge, ChevronUp, ChevronDown, and Trash2 buttons. This is where the "Insert Step" button should be added.

**2. `src/components/templates/TemplateModal.test.tsx` (TESTS)**

Currently has ~35 tests across 6 describe blocks:
- create mode (6 tests)
- edit mode (6 tests)
- step reorder (7 tests)
- step count (3 tests)
- modal size (1 test)
- initialSteps/PDF import (6 tests)

New tests needed for step insertion.

### Code to Reuse
- `nextStepUid()` -- already generates stable unique IDs for new steps
- `handleAddStep()` pattern -- same blank step creation, just at a different index
- ChevronUp/ChevronDown button styling -- the insert button should match this pattern
- Existing dark mode classes from step header row

### Code to Modify
- `TemplateModal.tsx`: Add `handleInsertStepAfter(index)` function and "Insert" button per step
- `TemplateModal.test.tsx`: Add new test cases for insertion

### Patterns to Follow

**Step creation pattern (from `handleAddStep`):**
```tsx
const newStep = { _uid: nextStepUid(), title: '', description: '', owner: '', expert: '', link: '' };
```

**Array insertion pattern:**
```tsx
const handleInsertStepAfter = (index: number) => {
  const newStep = { _uid: nextStepUid(), title: '', description: '', owner: '', expert: '', link: '' };
  const newSteps = [...steps];
  newSteps.splice(index + 1, 0, newStep);
  setSteps(newSteps);
};
```

**Button styling pattern (from ChevronUp/ChevronDown):**
```tsx
className="p-1 text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
```

### No Changes Needed
- `templateService.ts` -- the `updateTemplate()` function already handles any number of steps with delete+insert pattern. `syncTemplateStepsToInstances()` uses title-based matching and correctly handles new steps.
- `instanceService.ts` -- called by sync function, no changes needed
- `useTemplates.ts` -- hook passes through to service layer, no changes needed
- `TemplatesView.tsx` -- view layer passes through to modal, no changes needed
- `types/index.ts` -- Step type unchanged
- Database schema -- no migration needed
- Zustand store -- templates are not in the store (they use a standalone `useTemplates` hook)

## Constraints

### Performance
- No performance concerns. Step arrays are small (typically 3-15 steps). Array splice is O(n) but negligible.

### Platform
- Must work in all modern browsers (standard Array.splice, widely supported)
- No mobile layout concerns (desktop-only app per bug #29 WONTFIX)

### Dependencies
- `lucide-react` -- need to choose an icon for the insert button. Options:
  - `Plus` (already imported, used for "Add Step")
  - `PlusCircle` -- slightly more distinctive, differentiates from top-level "Add Step"
  - `ArrowDownToLine` or `ChevronsDown` -- conveys "insert below"
  - Recommendation: Use `Plus` with `size={14}` to keep it compact, matching existing button style

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Step numbers display incorrectly after insert | Low | Low | Already handled by `index + 1` in JSX template: `Step {index + 1} of {steps.length}` |
| Submitted step IDs wrong after insert | Medium | Low | Already handled by `handleSubmit` which uses `index + 1` for all steps (line 219) |
| Sync breaks for inserted steps | Low | Very Low | `syncTemplateStepsToInstances()` uses title-based matching; new steps with new titles automatically get `status: 'pending'` |
| UI clutter with too many buttons per step | Low | Medium | Mitigate with compact button styling; consider grouping insert with existing reorder buttons |
| React key collision after insert | Low | Very Low | `nextStepUid()` uses a monotonically incrementing counter; keys are guaranteed unique |

### Complexity
- **Level:** Simple
- **Rationale:** This is a single-file UI change. The core logic is a 5-line function (`splice` into array). No service layer changes, no database changes, no new dependencies. The existing sync infrastructure handles inserted steps automatically via title-based matching. The only design decision is the UI affordance (button placement, icon choice).

## Open Questions

- [x] Q1: Where should the "Insert Step" button be placed?
  - Resolution: Add an "Insert step below" button in the step header row alongside ChevronUp/ChevronDown/Trash2. This keeps all step manipulation controls grouped together. The button appears on every step card and inserts a blank step below the current one.

- [x] Q2: Should there be a way to insert before the first step?
  - Resolution: Yes. Two options: (a) clicking "Insert step below" on step 1 and then using ChevronUp on the new step, or (b) adding an "Insert step above" button to the first step. Recommendation: option (a) is sufficient -- the user can insert after step 1 and reorder. Alternatively, the top-level "Add Step" button could be changed to always prepend, but that would break existing behavior. Keeping it simple with "insert below" only.

- [x] Q3: Does `syncTemplateStepsToInstances()` handle new steps correctly?
  - Resolution: Yes. The sync function (lines 207-218 in `templateService.ts`) walks template steps in order. For any step whose title doesn't match an existing instance step, it creates a new step with `status: 'pending'`. Inserted steps will have new titles and will be correctly added to instances.

- [x] Q4: Does the database schema need changes?
  - Resolution: No. The `template_steps` table has a UNIQUE constraint on `(template_id, position)`, but the `updateTemplate()` function deletes all existing steps and re-inserts them with new positions. This handles arbitrary insertions correctly.

- [x] Q5: Should the scroll-into-view behavior (bug #19, P3 LOW) be implemented as part of this feature?
  - Resolution: Yes, this is a good opportunity. When a step is inserted, `scrollIntoView({ behavior: 'smooth', block: 'nearest' })` should be called on the new step element. This also addresses the existing P3 bug.

## Recommended Approach

### Implementation Strategy

**UI Design:** Add a small "Insert step below" button (`Plus` icon, `size={14}`) in each step card's header row, positioned between the reorder buttons and the delete button. The button inserts a blank step immediately after the current step.

**Function to add:**
```tsx
const handleInsertStepAfter = (index: number) => {
  const newStep: TemplateStep = {
    _uid: nextStepUid(),
    title: '',
    description: '',
    owner: '',
    expert: '',
    link: '',
  };
  const newSteps = [...steps];
  newSteps.splice(index + 1, 0, newStep);
  setSteps(newSteps);
};
```

**Button placement (in step header row, after ChevronDown, before Trash2):**
```tsx
<button
  type="button"
  onClick={() => handleInsertStepAfter(index)}
  className="p-1 text-slate-400 hover:text-brand-600 dark:hover:text-brand-400 transition-colors"
  aria-label={`Insert new step after step ${index + 1}`}
  title="Insert step below"
>
  <Plus size={14} />
</button>
```

**Optional scroll-into-view:** Use a ref callback or `useEffect` to scroll to the newly inserted step after state update.

### Order of Work
1. Add `handleInsertStepAfter(index)` function to TemplateModal
2. Add "Insert step below" button to each step card's header row
3. (Optional) Add scroll-into-view behavior for newly inserted steps
4. Add unit tests for insertion behavior
5. Verify sync works end-to-end (template save with inserted steps syncs to instances)

### What to Defer
- Drag-and-drop reordering (much more complex, can be done later)
- Bulk step insertion (e.g., insert 3 steps at once)
- Step templates / step library (reusable steps that can be inserted)

## Next Step

**All questions resolved.**
Run `/plan template-step-insert` to create implementation plan.
