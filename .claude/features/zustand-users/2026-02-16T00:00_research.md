# Research: zustand-users

## Metadata
- **Feature:** zustand-users
- **Created:** 2026-02-16T00:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context

This is slice 3 of 5 in the incremental Zustand migration. Slices 1 (`zustand-store` -- instances) and 2 (`zustand-steps` -- steps) are complete and committed. The existing store at `src/store/useOnboardingStore.ts` contains `InstancesSlice` and `StepsSlice` with ref-counted subscriptions and optimistic updates.

**This slice adds a `UsersSlice` to the existing Zustand store and migrates the `useUsers` hook.** It eliminates duplicate user subscriptions when `UsersPanel` (the only consumer) unmounts and remounts, and lays the groundwork for shared user data across future consumers.

### Where it fits in the project

| # | Feature | Status |
|---|---------|--------|
| 1 | `zustand-store` | **Complete** -- store + instances slice |
| 2 | `zustand-steps` | **Complete** -- steps slice |
| 3 | `zustand-users` | **THIS** -- users slice |
| 4 | `zustand-activities` | Queued |
| 5 | `zustand-cleanup` | Queued |

### Dependencies on other features
- **Depends on:** `zustand-store` (slice 1) and `zustand-steps` (slice 2) -- the Zustand store at `src/store/useOnboardingStore.ts` must exist with `InstancesSlice`, `StepsSlice`, and the established ref-counting patterns. **Both complete.**

### What depends on this feature
- Slice 4 (`zustand-activities`) extends the store further but does not depend on the users slice specifically.
- Slice 5 (`zustand-cleanup`) will remove the old `useUsers` hook in favor of the store-backed version.

## Requirements

### Functional Requirements
- [ ] FR1: Add a `UsersSlice` to the existing Zustand store that manages `User[]` data from a single realtime subscription (source: STATUS.md roadmap)
- [ ] FR2: The users slice must subscribe to realtime user changes via `subscribeToUsers()` from the service layer (source: code analysis of `userService.ts` -- uses crudFactory with channel `users-all` listening on `users`, `user_roles`, `user_profiles` tables)
- [ ] FR3: The users slice must provide CRUD action wrappers: `_createUser`, `_editUser` (optimistic + rollback), `_removeUser` (optimistic + rollback), and `_fetchUser` (source: existing `useUsers` hook API)
- [ ] FR4: Migrate `useUsers` hook to read from the store instead of maintaining its own `useState` + subscription (source: STATUS.md)
- [ ] FR5: `useUsers` must preserve its exact return type API: `{ users: User[], isLoading: boolean, error: string | null, createNewUser, editUser, removeUser, fetchUser, reset }` (source: code analysis of `UseUsersReturn` interface)
- [ ] FR6: `UsersPanel` must continue working unchanged -- it calls `useUsers()` and destructures `{ users, isLoading, error, createNewUser, editUser, removeUser }` (source: code analysis of `UsersPanel.tsx` line 24)
- [ ] FR7: The users subscription must be ref-counted: start on first consumer mount, stop when no consumers remain (source: architectural pattern from slices 1 and 2)
- [ ] FR8: `editUser` must apply optimistic updates (patch matching user in the array immediately) and roll back on server error (source: existing `useUsers` hook behavior, lines 68-82)
- [ ] FR9: `removeUser` must apply optimistic removal (filter user from array immediately) and could roll back on server error (source: existing behavior, lines 85-96)
- [ ] FR10: `createNewUser` must append the created user to the local array immediately for instant feedback (source: existing behavior, lines 52-65)
- [ ] FR11: `reset` must clear the error state (source: existing behavior, lines 111-113)
- [ ] FR12: Existing hooks that are NOT migrated (`useSuggestions`, `useActivities`, `useTemplates`, etc.) must continue working unchanged (source: STATUS.md -- "Old hooks and new store coexist")

### Technical Requirements
- [ ] TR1: Store file must be extended (not replaced) -- add `UsersSlice` alongside `InstancesSlice` and `StepsSlice` using intersection types as established in the existing store
- [ ] TR2: All 384 existing tests must continue passing after migration
- [ ] TR3: New unit tests must be added for the users slice in `src/store/useOnboardingStore.test.ts`
- [ ] TR4: TypeScript types must be correct -- `User`, `UserFormData` from `src/types/index.ts`
- [ ] TR5: Follow the same patterns established in slices 1 and 2: TSDoc comments, module-level ref-counting, barrel exports, Supabase service mocking in tests

### Constraints
- The app must be fully functional after this slice -- no half-broken state
- No changes to the Supabase service layer (`userService.ts`) -- the store consumes `subscribeToUsers`, `createUser`, `updateUser`, `deleteUser`, and `getUser` as-is
- Old hooks that are NOT being migrated in this slice must remain untouched
- The `UsersPanel.test.tsx` mocks `useUsers` at the hook import level -- this mock pattern must continue to work (the component test does not need to know about the store)

## Existing Code Analysis

### Project State
- Project exists: YES (17 features completed, including `zustand-store` and `zustand-steps`)
- Test baseline: 384 tests across 28 test files, all passing
- Build: Clean
- Zustand: Already installed (^5.x) from slice 1

### Current Data Flow (Users)

```
UsersPanel mounts
    |
    v
useUsers() hook called
    |
    v
useState: users[], isLoading, error
    |
    v
useEffect: subscribeToUsers(callback)
    |  callback: setUsers(updatedUsers), setIsLoading(false)
    |
    v (subscription fires)
subscribeToUsers (from crudFactory):
  1. Immediate fetch: listUsers().then(callback)
  2. Channel 'users-all' listens on: users, user_roles, user_profiles
  3. On any change: debounced (300ms) re-fetch -> callback
    |
    v
CRUD operations:
  createNewUser -> createUser(service) -> setUsers(append)
  editUser      -> optimistic setUsers(patch) -> updateUser(service) -> rollback on error
  removeUser    -> deleteUser(service) -> setUsers(filter)
  fetchUser     -> getUser(service)
  reset         -> setError(null)
```

### Duplicate Subscription Analysis

Unlike the instances slice (where `NewHiresPanel` and `useManagerData` both independently called `useOnboardingInstances`), the users case is simpler:

**Current consumers of `useUsers()`:**
1. `UsersPanel.tsx` (line 24) -- the ONLY consumer

**Why migration still matters:**
1. **Consistency:** All state slices in the store follow the same pattern. Having `users` outside the store while `instances` and `steps` are inside creates an inconsistent architecture.
2. **Future consumers:** If any other component needs user data (e.g., a user picker, a mention system), it would create duplicate subscriptions with the current hook-based approach. The store prevents this.
3. **The crudFactory subscription does NOT use `shared: true`** (see `userService.ts` line 154-168). This means every call to `subscribeToUsers` creates a new Supabase channel. If `UsersPanel` remounts (tab switch), it creates a new subscription without cleaning up the old one within the 300ms debounce window.
4. **Preparation for slice 5:** The cleanup slice needs all data hooks migrated to the store before it can slim down `OnboardingHub`.

### Detailed Analysis: useUsers Hook (current)

**File:** `src/hooks/useUsers.ts` (125 lines)

**State managed:**
- `users: User[]` -- local `useState`, updated by subscription callback and CRUD operations
- `isLoading: boolean` -- local `useState`, starts `true`
- `error: string | null` -- local `useState`, stores error messages as strings (NOT Error objects)

**Subscription lifecycle:**
- `useEffect` with `[]` dependency (mount-only)
- Calls `subscribeToUsers(callback)` on mount
- Returns cleanup function (unsubscribe) on unmount

**CRUD operations:**
- `createNewUser(data, createdBy)` -- calls `createUser(service)`, appends returned user to local state
- `editUser(userId, data)` -- optimistic patch via `setUsers(prev => prev.map(...))`, calls `updateUser(service)`, rolls back `setUsers(snapshot)` on error
- `removeUser(userId)` -- calls `deleteUser(service)`, then removes user from local state (NOT optimistic -- delete happens first, then local update)
- `fetchUser(userId)` -- calls `getUser(service)`, returns single user
- `reset()` -- clears error state

**Return type:**
```typescript
interface UseUsersReturn {
  users: User[];
  isLoading: boolean;
  error: string | null;       // NOTE: string, not Error
  createNewUser: (data: UserFormData, createdBy: string) => Promise<User>;
  editUser: (userId: string, data: Partial<UserFormData>) => Promise<void>;
  removeUser: (userId: string) => Promise<void>;
  fetchUser: (userId: string) => Promise<User | null>;
  reset: () => void;
}
```

> **IMPORTANT:** The `error` field is `string | null`, not `Error | null`. This differs from the instances and steps slices which use `Error | null`. The hook catches errors and extracts `.message` before storing them. The store must preserve this behavior in the hook wrapper.

### Detailed Analysis: subscribeToUsers Service Function

**File:** `src/services/supabase/userService.ts` (lines 154-172)

Generated by `createCrudService` with config:
```typescript
const crud = createCrudService<User>({
  table: 'users',
  selectClause: '*, user_roles(*), user_profiles(*)',
  mapRow: (row) => toUser(row, row.user_roles ?? [], row.user_profiles ?? []),
  entityName: 'user',
  subscription: {
    channelName: 'users-all',
    tables: [
      { table: 'users' },
      { table: 'user_roles' },
      { table: 'user_profiles' },
    ],
  },
});
export const subscribeToUsers = crud.subscribe;
```

**Behavior (from crudFactory):**
1. Immediate fetch: `listUsers().then(callback)` -- NOT debounced
2. Channel `users-all` listens on 3 tables: `users`, `user_roles`, `user_profiles`
3. Any `postgres_changes` event triggers `debouncedRefetch()` (300ms debounce)
4. Re-fetch calls `listUsers().then(callback)`
5. Returns cleanup function that cancels debounce and removes channel

**Key detail:** The `shared` flag is NOT set. Each call to `subscribeToUsers()` creates its own channel. The Zustand store's ref-counting will ensure only one subscription exists.

### Detailed Analysis: User CRUD Service Functions

**File:** `src/services/supabase/userService.ts`

| Function | Signature | Description |
|----------|-----------|-------------|
| `createUser` | `(userData: Omit<User, 'id' \| 'createdAt' \| 'updatedAt'>, createdBy: string) => Promise<User>` | Checks email uniqueness, inserts user + junction rows (user_roles, user_profiles), adds auth credentials, returns full User object |
| `updateUser` | `(userId: string, updates: Partial<Omit<User, 'id' \| 'createdAt' \| 'createdBy'>>) => Promise<void>` | Checks email uniqueness (if changed), updates user row, replaces junction rows via delete+insert |
| `deleteUser` | `(userId: string) => Promise<void>` | Fetches user for email, deletes associated onboarding instances (by email), deletes user row (CASCADE handles junctions), removes auth credentials |
| `getUser` | `(id: string) => Promise<User \| null>` | Factory-generated, single row fetch with joined data |

### Detailed Analysis: UsersPanel (sole consumer)

**File:** `src/components/manager/UsersPanel.tsx` (346 lines)

**How it consumes `useUsers()`:**
```typescript
const { users, isLoading, error, createNewUser, editUser, removeUser } = useUsers();
```

**Does NOT use:** `fetchUser`, `reset`

**Key observation:** `UsersPanel` is self-contained. It:
- Renders a table of users with loading/error/empty states
- Has create, edit, delete modal flows
- Calls CRUD operations directly from the hook return value
- Manages its own modal state (`showCreateModal`, `editingUser`, `userToDelete`)
- Manages its own operation states (`isSubmitting`, `isDeleting`, `modalError`)
- Logs activities via `logActivity` service (fire-and-forget)

**Critically:** `UsersPanel` does NOT pass users data to any child components as a prop. It's the terminal consumer. No prop drilling occurs.

### Detailed Analysis: UsersPanel Tests

**File:** `src/components/manager/UsersPanel.test.tsx` (329 lines)

**Mock strategy:** Mocks `useUsers` at the hook import level:
```typescript
vi.mock('../../hooks/useUsers', () => ({
  useUsers: () => mockUseUsersReturn,
}));
```

This mock will continue to work after migration because the hook file `src/hooks/useUsers.ts` still exists (it just reads from the store internally). The component test doesn't need to know about the store.

### Detailed Analysis: useUsers Tests

**File:** `src/hooks/useUsers.test.ts` (293 lines, 11 tests)

**Mock strategy:** Mocks `../services/supabase` at module level:
```typescript
vi.mock('../services/supabase', () => ({
  subscribeToUsers: vi.fn(),
  createUser: vi.fn(),
  updateUser: vi.fn(),
  deleteUser: vi.fn(),
  getUser: vi.fn(),
}));
```

**Tests cover:**
1. Create user successfully (returns created user)
2. Handle duplicate email error on create
3. Update user successfully (calls updateUser with correct args)
4. Handle error on update (sets error state)
5. Delete user successfully (calls deleteUser with correct ID)
6. Handle error on delete (sets error state)
7. Reset error state
8. Optimistic edit: applies patch to matching user
9. Optimistic edit: rolls back on error
10. Optimistic edit: does not affect non-matching users

**Post-migration:** These tests use `renderHook(() => useUsers())` which renders the hook in a test React component. After migration, the hook reads from the store, which needs the services mocked. Since these tests already mock `../services/supabase`, and the store imports from the same path, the mocks should continue to work. However, the store's subscription lifecycle is different from direct `useState` -- we need to verify that the tests' mock for `subscribeToUsers` correctly triggers the store's callback.

**Key concern:** Currently, each test calls `subscribeToUsers.mockImplementation(callback => { callback(mockUsers); return () => {}; })` which triggers the callback synchronously during subscription setup. The store's `_startUsersSubscription` action should handle this correctly since the crudFactory's `subscribe` also calls the callback immediately.

### Existing Zustand Store Patterns (from slices 1 + 2)

**File:** `src/store/useOnboardingStore.ts` (266 lines)

**Patterns established:**

1. **Slice interfaces:**
   - `InstancesSlice`: `instances`, `instancesLoading`, `instancesError`, `_startInstancesSubscription`
   - `StepsSlice`: `stepsByInstance`, `stepsLoadingByInstance`, `stepsErrorByInstance`, `_startStepsSubscription`, `_updateStepStatus`

2. **Combined type:** `OnboardingStore = InstancesSlice & StepsSlice` (extend with `& UsersSlice`)

3. **Module-level ref-counting:**
   - Instances: scalar `refCount` + `cleanup`
   - Steps: `Map<string, number>` for per-instanceId ref counts + `Map<string, () => void>` for cleanups

4. **`resetStoreInternals()`:** Exported for test isolation. Resets all ref counts and cleanup functions.

5. **Subscription actions:** Return cleanup functions, guarded against double invocation via `let cleaned = false`.

6. **State reset on last cleanup:** State fields reset to initial values when last consumer unmounts.

7. **Store creation:** `create<OnboardingStore>((set, get) => ({ ... }))`

### Key Type: User

```typescript
interface User {
  id: string;
  email: string;         // Required, unique, case-insensitive
  name: string;          // User's full name
  roles: string[];       // Array of role names (e.g., ['manager', 'admin'])
  profiles?: string[];   // Optional profile assignments
  createdAt: number;     // Unix timestamp
  updatedAt: number;     // Unix timestamp
  createdBy: string;     // User ID who created this user
}

interface UserFormData {
  email: string;
  name: string;
  roles: string[];
  profiles?: string[];
}
```

## Store Design (Users Slice)

### State Shape

Unlike steps (keyed by instanceId), users is a flat array similar to instances. The subscription is global -- all users are fetched.

```typescript
interface UsersSlice {
  /** All system users from the realtime subscription */
  users: User[];
  /** Whether the initial data load is in progress */
  usersLoading: boolean;
  /** Error from subscription setup or CRUD operations (string, not Error) */
  usersError: string | null;

  /**
   * Starts the ref-counted users subscription.
   * Returns a cleanup function that decrements the ref count
   * and unsubscribes when no consumers remain.
   */
  _startUsersSubscription: () => () => void;

  /**
   * Creates a new user, appends to local state immediately for instant feedback.
   * Re-throws errors after setting error state.
   */
  _createUser: (data: UserFormData, createdBy: string) => Promise<User>;

  /**
   * Optimistically updates a user's data, calls the server,
   * and rolls back on error. Re-throws server errors.
   */
  _editUser: (userId: string, data: Partial<UserFormData>) => Promise<void>;

  /**
   * Deletes a user via the server, then removes from local state.
   * Re-throws server errors.
   */
  _removeUser: (userId: string) => Promise<void>;

  /**
   * Fetches a single user by ID from the server. Does not modify store state.
   * Re-throws errors after setting error state.
   */
  _fetchUser: (userId: string) => Promise<User | null>;

  /**
   * Clears the usersError state.
   */
  _resetUsersError: () => void;
}
```

### Ref-Counting (Scalar, like Instances)

Users uses a single global subscription (like instances, unlike steps which is per-instanceId). Scalar ref-counting:

```typescript
// Module-level
let usersRefCount = 0;
let usersCleanup: (() => void) | null = null;
```

### Subscription Action

```typescript
_startUsersSubscription: () => {
  usersRefCount++;

  if (usersRefCount === 1) {
    set({ usersLoading: true, usersError: null });

    try {
      usersCleanup = subscribeToUsers((users) => {
        set({ users, usersLoading: false });
      });
    } catch (err) {
      set({
        usersError: err instanceof Error ? err.message : String(err),
        usersLoading: false,
      });
    }
  }

  let cleaned = false;
  return () => {
    if (cleaned) return;
    cleaned = true;
    usersRefCount--;

    if (usersRefCount === 0 && usersCleanup) {
      usersCleanup();
      usersCleanup = null;
      set({ users: [], usersLoading: false, usersError: null });
    }
  };
}
```

### CRUD Actions

```typescript
_createUser: async (data, createdBy) => {
  set({ usersError: null });
  try {
    const newUser = await createUser({ ...data, createdBy }, createdBy);
    set((state) => ({ users: [...state.users, newUser] }));
    return newUser;
  } catch (err) {
    const msg = err instanceof Error ? err.message : 'Failed to create user';
    set({ usersError: msg });
    throw new Error(msg);
  }
}

_editUser: async (userId, data) => {
  set({ usersError: null });
  const snapshot = get().users;
  // Optimistic update
  set((state) => ({
    users: state.users.map((u) => (u.id === userId ? { ...u, ...data } : u)),
  }));
  try {
    await updateUser(userId, data);
  } catch (err) {
    set({ users: snapshot });
    const msg = err instanceof Error ? err.message : 'Failed to update user';
    set({ usersError: msg });
    throw new Error(msg);
  }
}

_removeUser: async (userId) => {
  set({ usersError: null });
  try {
    await deleteUser(userId);
    set((state) => ({ users: state.users.filter((u) => u.id !== userId) }));
  } catch (err) {
    const msg = err instanceof Error ? err.message : 'Failed to delete user';
    set({ usersError: msg });
    throw new Error(msg);
  }
}

_fetchUser: async (userId) => {
  set({ usersError: null });
  try {
    return await getUser(userId);
  } catch (err) {
    const msg = err instanceof Error ? err.message : 'Failed to fetch user';
    set({ usersError: msg });
    throw new Error(msg);
  }
}

_resetUsersError: () => {
  set({ usersError: null });
}
```

### Hook Migration

```typescript
export function useUsers(): UseUsersReturn {
  const users = useOnboardingStore((s) => s.users);
  const isLoading = useOnboardingStore((s) => s.usersLoading);
  const error = useOnboardingStore((s) => s.usersError);

  useEffect(() => {
    const unsub = useOnboardingStore.getState()._startUsersSubscription();
    return unsub;
  }, []);

  const createNewUser = useCallback(
    (data: UserFormData, createdBy: string) =>
      useOnboardingStore.getState()._createUser(data, createdBy),
    []
  );

  const editUser = useCallback(
    (userId: string, data: Partial<UserFormData>) =>
      useOnboardingStore.getState()._editUser(userId, data),
    []
  );

  const removeUser = useCallback(
    (userId: string) =>
      useOnboardingStore.getState()._removeUser(userId),
    []
  );

  const fetchUser = useCallback(
    (userId: string) =>
      useOnboardingStore.getState()._fetchUser(userId),
    []
  );

  const reset = useCallback(
    () => useOnboardingStore.getState()._resetUsersError(),
    []
  );

  return { users, isLoading, error, createNewUser, editUser, removeUser, fetchUser, reset };
}
```

**Key improvements over current implementation:**
1. `editUser`'s `useCallback` no longer depends on `[users]` -- it calls a store action that reads current state via `get()`. The function reference is stable.
2. Single subscription shared via ref-counting -- no duplicate channels on remount.
3. Consistent architecture with instances and steps slices.

## Code to Reuse

| File | What can be reused |
|------|-------------------|
| `src/store/useOnboardingStore.ts` | Extend with `UsersSlice` -- existing `InstancesSlice` + `StepsSlice` + `create()` + `resetStoreInternals()` patterns |
| `src/store/index.ts` | Add `UsersSlice` to barrel exports |
| `src/services/supabase/userService.ts` | `subscribeToUsers()`, `createUser()`, `updateUser()`, `deleteUser()`, `getUser()` consumed as-is |
| `src/store/useOnboardingStore.test.ts` | Test patterns: mock setup, `setState()` + `resetStoreInternals()` in `beforeEach` |
| `src/hooks/useUsers.test.ts` | Existing tests verify the public API contract -- must continue passing (may need mock adjustments) |

## Code to Modify

| File | What Changes | Current Lines |
|------|-------------|--------------|
| `src/store/useOnboardingStore.ts` | Add `UsersSlice` interface, update `OnboardingStore` type, add scalar ref-counting for users, add `_startUsersSubscription` + CRUD actions + `_resetUsersError`, extend `resetStoreInternals()`, import user service functions | 266 |
| `src/store/index.ts` | Export `UsersSlice` type | 13 |
| `src/hooks/useUsers.ts` | Rewrite internals to read from store, preserve return type API | 125 |
| `src/hooks/useUsers.test.ts` | May need mock adjustments since hook now reads from store which reads from services | 293 |
| `src/store/useOnboardingStore.test.ts` | Add tests for users slice alongside existing instances and steps tests | ~485 |

## Code NOT to Modify

| File | Reason |
|------|--------|
| `src/services/supabase/userService.ts` | Service layer stays as-is |
| `src/services/supabase/crudFactory.ts` | No changes needed |
| `src/services/supabase/subscriptionManager.ts` | No changes needed |
| `src/components/manager/UsersPanel.tsx` | Consumes `useUsers()` via same API contract |
| `src/components/manager/UsersPanel.test.tsx` | Mocks `useUsers` at hook import level -- still works |
| `src/components/OnboardingHub.tsx` | Does not use `useUsers`, unaffected |
| All other hooks | Not migrated in this slice |
| All other components | No dependency on `useUsers` |

## Patterns to Follow

1. **Slice interface with prefixed state names:** `instances`/`instancesLoading`/`instancesError` and `stepsByInstance`/`stepsLoadingByInstance`/`stepsErrorByInstance`. Users should use `users`/`usersLoading`/`usersError`.

2. **Module-level scalar ref-counting:** Like instances slice (`let usersRefCount = 0; let usersCleanup: (() => void) | null = null`).

3. **`resetStoreInternals()` must reset users state too:** Extend the existing function to clear users ref count and cleanup.

4. **Action naming:** Internal actions prefixed with `_` (e.g., `_startUsersSubscription`, `_createUser`, `_editUser`, `_removeUser`, `_fetchUser`, `_resetUsersError`).

5. **Hook as thin wrapper:** The migrated `useUsers` should be a thin wrapper over the store, using selectors to read state and `useEffect` for subscription lifecycle.

6. **Error as string:** The existing hook stores error messages as `string | null`, not `Error | null`. The store's `usersError` must be `string | null` to preserve API compatibility without changes to `UsersPanel` (which renders `error` directly as text).

7. **Supabase mocking pattern:** Tests mock `../services/supabase` at module level with `vi.mock()`.

8. **TSDoc comments on all exports.**

9. **Barrel exports via `src/store/index.ts` and `src/hooks/index.ts`.**

10. **Double-invoke guard on cleanup functions:** `let cleaned = false` pattern.

## Constraints

### Performance
- Users data is typically small (dozens of users, not thousands). No performance concerns.
- The subscription re-fetches all users with joined roles and profiles on any change. With `listLimit: 200` (crudFactory default), this is bounded.
- The 300ms debounce on realtime re-fetches is preserved (it's in the service layer).
- Optimistic updates are synchronous `set()` calls -- instant UI feedback.

### Platform
- React 18 + Zustand 5.x: fully compatible, same as slices 1 and 2.
- No SSR concerns (client-only SPA).

### Dependencies
- `subscribeToUsers`, `createUser`, `updateUser`, `deleteUser`, `getUser` from `userService.ts` -- consumed as-is.
- Zustand already installed from slice 1.

## Risk Assessment

### Technical Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Error type mismatch: instances/steps use `Error \| null`, users uses `string \| null`. Mixing in one store could confuse contributors. | Low | Medium | Document clearly in TSDoc. The hook wrapper handles the conversion. The store stores strings to match the existing API. |
| `editUser` optimistic update closure: current hook closes over `users` array for snapshot. Store action uses `get()` instead, eliminating stale closure. Subtle behavioral change. | Low | Low | The `get()` approach is actually better -- it captures the snapshot at call time, not at render time. No functional difference for the user. |
| `removeUser` is NOT optimistic in current hook (deletes server-side first, then updates local state). Changing to optimistic could cause UI flicker if delete fails. | Low | Low | Keep the same non-optimistic pattern: call service first, then update local state. This matches current behavior. |
| `useUsers.test.ts` mock setup: tests mock `subscribeToUsers` to call callback synchronously. After migration, the hook's `useEffect` starts the store subscription, which starts the service subscription. The timing of synchronous callback delivery during subscription setup should work correctly with the store. | Medium | Medium | The `crudFactory.subscribe` calls `list().then(callback)` which is async. But test mocks call callback synchronously. The store's `set()` in the subscription callback will update state before the `useEffect` returns. Verify all tests pass; adjust mock timing if needed. |
| `createNewUser` return value: the hook must return the created `User` object. The store action returns it via `Promise<User>`. This must be preserved. | Low | Low | The store action `_createUser` returns `Promise<User>`. The hook wrapper calls it and returns the result. |
| More service imports in store file: unlike instances (1 import) and steps (2 imports), users needs 5 service imports. The store file grows. | Low | Low | Acceptable growth. The store will eventually contain all slices. Imports are well-organized. |

### Complexity
- **Level:** Simple-Medium
- **Rationale:** This slice follows the exact patterns from slices 1 and 2. The users slice is structurally similar to the instances slice (flat array, scalar ref-counting, global subscription). The added complexity is the CRUD action wrappers (create, edit with optimistic update, delete, fetch, reset), but these are straightforward translations of the existing hook logic. There are no per-key subscriptions (unlike steps), no optimistic update race conditions with realtime callbacks (the CRUD operations are explicit user actions, not competing with subscription callbacks in the same way as step status updates).

## Open Questions

- [x] Q1: Should `usersError` be `Error | null` (like instances/steps) or `string | null` (like current hook)?
  - Resolution: `string | null`. The current `useUsers` hook stores error messages as strings, and `UsersPanel` renders the `error` value directly as text. Changing to `Error` would require updating `UsersPanel` to render `error.message` instead. Keep as `string` to preserve API compatibility.

- [x] Q2: Should `removeUser` be optimistic (remove from UI immediately, rollback on error)?
  - Resolution: Keep the current non-optimistic pattern (delete server-side first, then update local state). This matches existing behavior and is safer for destructive operations -- you don't want to show "user deleted" then have it pop back if the server fails. The realtime subscription will also fire after deletion, but the local update ensures immediate feedback.

- [x] Q3: Should the store actions be called `_createUser` etc., or should we use different names to avoid collision with the service-level `createUser`?
  - Resolution: Use `_createUser`, `_editUser`, `_removeUser`, `_fetchUser`, `_resetUsersError`. The `_` prefix distinguishes them as store actions. The service-level functions are imported at the top of the store file and used inside the action implementations. No naming collision since the `_` prefix and the module scope separate them.

- [x] Q4: Does `resetStoreInternals()` need to be extended?
  - Resolution: Yes. Add users ref-count reset alongside instances and steps resets.

- [x] Q5: Will `useUsers.test.ts` still pass after migration?
  - Resolution: The tests mock `../services/supabase` which is the same module the store imports from. The mock will intercept both direct hook usage and store-mediated usage. However, timing may differ slightly because the store subscription starts in a `useEffect` (async), while the mock calls callback synchronously. The `renderHook` + `act` pattern in the existing tests should handle this correctly. Verify by running tests after migration.

## Recommended Approach

### Implementation Strategy

**Extend the existing store with a `UsersSlice`, then rewrite `useUsers` as a thin wrapper, following the exact patterns from slices 1 and 2.**

This is the simplest of the three slices so far because:
1. Users is a flat array (like instances, not keyed like steps)
2. There is only ONE consumer (`UsersPanel`)
3. The CRUD actions are straightforward translations of existing hook logic
4. No race condition bugs to fix (unlike instances and steps)

### Order of Work

1. **Extend `src/store/useOnboardingStore.ts`:**
   - Add `UsersSlice` interface
   - Update `OnboardingStore = InstancesSlice & StepsSlice & UsersSlice`
   - Add scalar ref-counting (`usersRefCount`, `usersCleanup`)
   - Add `_startUsersSubscription` action
   - Add CRUD actions: `_createUser`, `_editUser`, `_removeUser`, `_fetchUser`, `_resetUsersError`
   - Extend `resetStoreInternals()` to clear users ref-counting
   - Add new state fields: `users: []`, `usersLoading: false`, `usersError: null`
   - Import service functions: `subscribeToUsers`, `createUser`, `updateUser`, `deleteUser`, `getUser`

2. **Update `src/store/index.ts`:**
   - Export `UsersSlice` type

3. **Add store tests for users slice in `src/store/useOnboardingStore.test.ts`:**
   - Initial state (empty array, loading false, error null)
   - `_startUsersSubscription` starts subscription
   - Subscription callback updates `users` and clears loading
   - Error handling on subscription setup
   - Ref-counting: second start is no-op, cleanup decrements, last cleanup unsubscribes + resets state, double cleanup is safe, re-subscribe after cleanup works
   - `_createUser` appends to array and returns user
   - `_createUser` sets error on failure
   - `_editUser` optimistic update applies immediately
   - `_editUser` rolls back on server error
   - `_removeUser` removes from array after server call
   - `_removeUser` sets error on failure
   - `_fetchUser` returns user from service
   - `_resetUsersError` clears error

4. **Rewrite `src/hooks/useUsers.ts`:**
   - Import from store instead of local useState
   - `useEffect` calls `_startUsersSubscription()` with cleanup
   - CRUD callbacks call store actions
   - Return type unchanged

5. **Verify `src/hooks/useUsers.test.ts`:**
   - Run existing tests -- they should pass since they mock the same service module
   - Adjust if timing differences cause issues

6. **Run full test suite** -- all 384+ tests must pass

### What to Defer

- **Activities/suggestions slices** -- slice 4 (`zustand-activities`)
- **Removing old hooks** -- slice 5 (`zustand-cleanup`)
- **Devtools middleware** -- deferred from slice 1, still deferred
- **Changes to UsersPanel component** -- works via unchanged hook API
- **Changes to service layer** -- consumed as-is

## Next Step

**All questions resolved.**
Run `/plan zustand-users` to create the implementation plan.
