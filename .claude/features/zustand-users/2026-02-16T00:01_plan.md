# Plan: zustand-users

## Metadata
- **Feature:** zustand-users
- **Created:** 2026-02-16T00:01
- **Status:** plan-complete
- **Based on:** 2026-02-16T00:00_research.md
- **Slice:** 3 of 5 in Zustand migration

## Architecture Overview

This slice adds a `UsersSlice` to the existing Zustand store and rewrites the `useUsers` hook as a thin store wrapper. The pattern mirrors the `InstancesSlice` (flat array, scalar ref-counting, global subscription) rather than the `StepsSlice` (keyed maps, per-instanceId subscriptions).

### Current Data Flow

```
UsersPanel
    |
    v
useUsers() hook  <-- local useState x3: users[], isLoading, error
    |
    v  (useEffect on mount)
subscribeToUsers(callback)  <-- crudFactory: immediate fetch + channel 'users-all'
    |
    v  (CRUD)
createUser / updateUser / deleteUser / getUser  <-- service layer
```

### Target Data Flow

```
UsersPanel
    |
    v
useUsers() hook  <-- thin wrapper: selectors + useEffect lifecycle
    |
    v
useOnboardingStore  <-- Zustand: users, usersLoading, usersError
    |                   + _startUsersSubscription (ref-counted)
    |                   + _createUser, _editUser, _removeUser, _fetchUser, _resetUsersError
    v
subscribeToUsers / createUser / updateUser / deleteUser / getUser  <-- service layer (unchanged)
```

### Store Architecture (after this slice)

```
OnboardingStore = InstancesSlice & StepsSlice & UsersSlice

useOnboardingStore.ts
  |
  +-- InstancesSlice  (flat array, scalar ref-count)     [EXISTING]
  |     instances: OnboardingInstance[]
  |     instancesLoading: boolean
  |     instancesError: Error | null
  |     _startInstancesSubscription: () => () => void
  |
  +-- StepsSlice  (keyed maps, per-instanceId ref-count)  [EXISTING]
  |     stepsByInstance: Record<string, Step[]>
  |     stepsLoadingByInstance: Record<string, boolean>
  |     stepsErrorByInstance: Record<string, Error | null>
  |     _startStepsSubscription: (id) => () => void
  |     _updateStepStatus: (id, stepId, status) => Promise<void>
  |
  +-- UsersSlice  (flat array, scalar ref-count)           [NEW]
        users: User[]
        usersLoading: boolean
        usersError: string | null   <-- NOTE: string, not Error
        _startUsersSubscription: () => () => void
        _createUser: (data, createdBy) => Promise<User>
        _editUser: (userId, data) => Promise<void>
        _removeUser: (userId) => Promise<void>
        _fetchUser: (userId) => Promise<User | null>
        _resetUsersError: () => void
```

### Module-Level Ref-Counting (after this slice)

```
// Instances (existing)
let refCount = 0;
let cleanup: (() => void) | null = null;

// Steps (existing)
const stepsRefCounts: Map<string, number>
const stepsCleanups: Map<string, () => void>

// Users (NEW)
let usersRefCount = 0;
let usersCleanup: (() => void) | null = null;
```

## Tech Stack Summary

No new dependencies. Uses:
- **Zustand 5.x** -- already installed from slice 1
- **React 18** -- useEffect, useCallback for hook wrapper
- **TypeScript** -- intersection types for store composition
- **Vitest + React Testing Library** -- unit tests

## File Structure

### New Files

None. All changes extend existing files.

### Modified Files

| # | File | Lines (current) | What Changes |
|---|------|----------------|-------------|
| 1 | `src/store/useOnboardingStore.ts` | 266 | Add `UsersSlice` interface (~20 lines), update `OnboardingStore` type, add `usersRefCount` + `usersCleanup` module-level vars, add 6 actions + 3 state fields (~100 lines), extend `resetStoreInternals()` (~5 lines), add 5 service imports |
| 2 | `src/store/index.ts` | 13 | Add `UsersSlice` to type exports |
| 3 | `src/hooks/useUsers.ts` | 125 | Rewrite internals: replace `useState` x3 + `useEffect` + CRUD callbacks with store selectors + store action wrappers. Preserve `UseUsersReturn` interface exactly. ~65 lines after rewrite. |
| 4 | `src/store/useOnboardingStore.test.ts` | 485 | Add `UsersSlice` describe block with ~14 tests (~200 lines). Extend mocks and `beforeEach` state reset. |
| 5 | `src/hooks/useUsers.test.ts` | 293 | Add `resetStoreInternals` import and call in `beforeEach` for store isolation. Add store state reset in `beforeEach`. Existing tests should pass as-is with these additions. |

### Files NOT Modified

| File | Reason |
|------|--------|
| `src/services/supabase/userService.ts` | Service layer consumed as-is |
| `src/components/manager/UsersPanel.tsx` | Consumes `useUsers()` -- API unchanged |
| `src/components/manager/UsersPanel.test.tsx` | Mocks `useUsers` at hook import level -- still works |
| All other hooks | Not migrated in this slice |
| All other components | No dependency on `useUsers` |

## Data Model Changes

None. No database schema changes. The `UsersSlice` stores in-memory state only, sourced from the existing `subscribeToUsers` service function.

## Component Architecture

No new components. `UsersPanel` remains the sole consumer of `useUsers()`. The hook's return type is preserved exactly:

```typescript
interface UseUsersReturn {
  users: User[];
  isLoading: boolean;
  error: string | null;
  createNewUser: (data: UserFormData, createdBy: string) => Promise<User>;
  editUser: (userId: string, data: Partial<UserFormData>) => Promise<void>;
  removeUser: (userId: string) => Promise<void>;
  fetchUser: (userId: string) => Promise<User | null>;
  reset: () => void;
}
```

### State Management

State moves from per-component `useState` inside `useUsers` to centralized Zustand store:

| Before (hook) | After (store) | Notes |
|--------------|--------------|-------|
| `useState<User[]>([])` | `users: User[]` | Flat array, same shape |
| `useState<boolean>(true)` | `usersLoading: boolean` | Starts `false` in store; set to `true` when subscription starts |
| `useState<string \| null>(null)` | `usersError: string \| null` | String type preserved (differs from `instancesError: Error \| null`) |

## UsersSlice Interface

```typescript
export interface UsersSlice {
  /** All system users from the realtime subscription */
  users: User[];
  /** Whether the initial data load is in progress */
  usersLoading: boolean;
  /** Error from subscription setup or CRUD operations (string, not Error) */
  usersError: string | null;

  /** Starts the ref-counted users subscription. Returns cleanup function. */
  _startUsersSubscription: () => () => void;
  /** Creates a user, appends to local state. Re-throws on error. */
  _createUser: (data: UserFormData, createdBy: string) => Promise<User>;
  /** Optimistic update + rollback on error. Re-throws on error. */
  _editUser: (userId: string, data: Partial<UserFormData>) => Promise<void>;
  /** Deletes via server, then removes from local state. Re-throws on error. */
  _removeUser: (userId: string) => Promise<void>;
  /** Fetches single user from server. Does not modify store state. Re-throws on error. */
  _fetchUser: (userId: string) => Promise<User | null>;
  /** Clears usersError. */
  _resetUsersError: () => void;
}
```

## Testing Strategy

### Unit Tests: Store (src/store/useOnboardingStore.test.ts)

14 new tests in a `UsersSlice` describe block:

| # | Test | What it validates |
|---|------|-------------------|
| 1 | Initializes with empty users state | `users: []`, `usersLoading: false`, `usersError: null`, actions are functions |
| 2 | `_startUsersSubscription` calls `subscribeToUsers` | Service function invoked once, cleanup returned |
| 3 | Subscription callback updates users and clears loading | `set({ users, usersLoading: false })` on callback |
| 4 | Subscription error sets error string and clears loading | Error caught, stored as string |
| 5 | Second start is no-op (ref-counted) | `subscribeToUsers` called once for two starts |
| 6 | Cleanup decrements ref count | First cleanup does not unsubscribe when 2 consumers |
| 7 | Last cleanup unsubscribes and resets state | Unsubscribe called, state reset to initial |
| 8 | Double cleanup is safe (idempotent) | `let cleaned = false` guard prevents double decrement |
| 9 | Re-subscribe after full cleanup works | New subscription created after full teardown |
| 10 | `_createUser` appends to array and returns user | Service called, user added to `users[]` |
| 11 | `_createUser` sets error string on failure | Error message stored, re-thrown |
| 12 | `_editUser` optimistic update + rollback on error | Immediate patch, snapshot restored on error |
| 13 | `_removeUser` removes from array after server call | Service called first, then user filtered out |
| 14 | `_resetUsersError` clears error | `usersError` set to `null` |

### Unit Tests: Hook (src/hooks/useUsers.test.ts)

11 existing tests -- all must continue passing. Changes:
- Add `resetStoreInternals` import and call in `beforeEach`
- Add store state reset in `beforeEach` to clear users slice state

### Integration Tests

No new integration tests. The existing `UsersPanel.test.tsx` (mock-based) validates the component-hook contract and remains unchanged.

### Test Counts

| Category | Before | After |
|----------|--------|-------|
| Store tests | 18 (instances + steps) | 32 (+ 14 users) |
| Hook tests (useUsers) | 11 | 11 (unchanged) |
| Component tests (UsersPanel) | 12 | 12 (unchanged) |
| **Total project** | **384** | **~398** |

## Implementation Notes

### Design Decisions

1. **`usersError` is `string | null`, not `Error | null`:** The existing `useUsers` hook stores error messages as strings, and `UsersPanel` renders `error` directly as text (line 183). Changing to `Error` would require `UsersPanel` to render `error.message`. Keeping `string` preserves API compatibility with zero downstream changes. This is intentionally different from `instancesError: Error | null` and `stepsErrorByInstance: Record<string, Error | null>`. TSDoc comments document this clearly.

2. **`removeUser` is NOT optimistic:** The current hook deletes server-side first, then updates local state. This is intentional for destructive operations -- showing "user deleted" then having it reappear on server failure is worse UX than a brief delay. The store preserves this non-optimistic pattern.

3. **`editUser` snapshot via `get()` instead of closure:** The current hook's `editUser` closes over `[users]` for the rollback snapshot. The store action uses `get().users` which captures the snapshot at call time, not at render time. This is strictly better -- it eliminates the stale closure risk when multiple edits happen in rapid succession.

4. **`createUser` service signature:** The service `createUser` takes `(userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>, createdBy: string)`. The hook spreads `{ ...data, createdBy }` as the first arg. The store action must preserve this exact calling convention.

### Patterns Followed

- Slice interface with prefixed state names (`users`/`usersLoading`/`usersError`)
- Module-level scalar ref-counting (like instances, not keyed like steps)
- `resetStoreInternals()` extended to clear users state
- Action naming with `_` prefix
- Double-invoke guard (`let cleaned = false`) on cleanup
- TSDoc comments on all exports
- Barrel exports via `src/store/index.ts`

### Trade-offs

- **Store file growth:** The store file grows from ~266 lines to ~380 lines. This is acceptable for 3 slices. After slice 4 (activities + suggestions), we may consider splitting into separate slice files with a composition pattern, but that is deferred to slice 5.
- **Mixed error types:** `instancesError: Error | null` vs `usersError: string | null`. Inconsistent, but changing either direction would break existing consumers. Document and move on.

## Non-Goals

- **NOT changing `UsersPanel`** -- it consumes `useUsers()` via the same API contract
- **NOT changing the service layer** -- `userService.ts` is consumed as-is
- **NOT adding Zustand devtools** -- deferred from slice 1, still deferred
- **NOT splitting the store file** -- deferred to slice 5 cleanup
- **NOT migrating other hooks** -- `useActivities`, `useSuggestions`, etc. are slice 4
- **NOT making `removeUser` optimistic** -- preserves current non-optimistic behavior intentionally
- **NOT unifying error types** across slices -- would break existing consumers
