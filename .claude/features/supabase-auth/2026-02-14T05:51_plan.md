# Plan: supabase-auth

## Metadata
- **Feature:** supabase-auth
- **Created:** 2026-02-14T05:51
- **Status:** plan-complete
- **Based on:** 2026-02-14T05:50_research.md

## Summary

Replace all Firebase Auth usage with Supabase Auth equivalents while keeping the `AuthContextValue` interface and `useAuth()` hook stable. Consumers of `useAuth()` (App.tsx, NavBar, SignOutView, etc.) require zero changes. The localStorage fallback for dev mode is preserved.

## Architecture Overview

### Current Flow (Firebase)

```
SignInView
  |
  v
authService.signInWithEmailLink(email)
  |
  +-- getAuthCredential(email)  <-- localStorage (Users panel)
  +-- MOCK_EMAIL_ROLES           <-- hardcoded test accounts
  +-- createUserWithEmailAndPassword(auth, ...)   <-- Firebase Auth
  |     or signInWithEmailAndPassword(auth, ...)
  +-- setUserRole(uid, email, role)               <-- Firestore write
  +-- localStorage fallback (mockAuthUser)
  |
  v
AuthProvider (authContext.tsx)
  |
  +-- Effect 1: localStorage mockAuthUser check
  |     OR onAuthStateChanged(auth, cb)  <-- Firebase Auth listener
  |       +-- getUserRole(uid)           <-- Firestore read
  |
  +-- Effect 2: storage + authStorageChange event listeners
  |
  v
useAuth() => { user, role, loading, isAuthenticated, signOut }
```

### Target Flow (Supabase)

```
SignInView
  |
  v
authService.signInWithEmailLink(email)
  |
  +-- getAuthCredential(email)  <-- localStorage (Users panel) [UNCHANGED]
  +-- MOCK_EMAIL_ROLES           <-- hardcoded test accounts [UNCHANGED]
  +-- supabase.auth.signUp({ email, password })       <-- Supabase Auth
  |     or supabase.auth.signInWithPassword({ ... })
  +-- upsertUserRole(uid, email, role)                <-- Supabase DB write
  +-- localStorage fallback (mockAuthUser)            [UNCHANGED]
  |
  v
AuthProvider (authContext.tsx)
  |
  +-- Effect 1: localStorage mockAuthUser check       [UNCHANGED]
  |     OR supabase.auth.onAuthStateChange(cb)        <-- Supabase listener
  |       +-- getUserRoleFromSupabase(uid)             <-- Supabase DB read
  |
  +-- Effect 2: storage + authStorageChange events    [UNCHANGED]
  |
  v
useAuth() => { user, role, loading, isAuthenticated, signOut }
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                          INTERFACE UNCHANGED
```

### Key Architectural Decisions

1. **Stable public API.** `AuthContextValue`, `AuthUser`, `UserRole` types are unchanged. No consumer code changes.
2. **Env var rename.** `VITE_USE_FIREBASE_EMULATOR` -> `VITE_USE_DEV_AUTH` (generic name, not Firebase-specific).
3. **Remove `FirestoreUser` type.** Replaced by direct Supabase DB queries using `database.types.ts` types.
4. **Remove `getCurrentUser()`.** Only used internally in authService; replaced by `supabase.auth.getUser()`.
5. **Keep `getAuthCredential()` import.** Already lives in `userService.ts`, imported via `./supabase` barrel.
6. **Leave `firebase.ts` untouched.** The cleanup step handles removing it.

## Tech Stack (Auth-Specific)

| Component | Before | After |
|-----------|--------|-------|
| Auth provider | Firebase Auth SDK | `@supabase/supabase-js` auth |
| Auth listener | `onAuthStateChanged()` | `supabase.auth.onAuthStateChange()` |
| Sign up | `createUserWithEmailAndPassword()` | `supabase.auth.signUp()` |
| Sign in | `signInWithEmailAndPassword()` | `supabase.auth.signInWithPassword()` |
| Sign out | `firebaseSignOut()` | `supabase.auth.signOut()` |
| Role storage | Firestore `users/{uid}` doc | Supabase `users` + `user_roles` tables |
| Role read | `getDoc(doc(firestore, 'users', uid))` | `supabase.from('users').select('*, user_roles(*)').eq('id', uid)` |
| Role write | `setDoc(doc(firestore, 'users', uid), ...)` | Upsert to `users` + `user_roles` via userService |

## File Structure

### Files to Modify (Source - 5 files)

| # | File | Lines | Changes | Complexity |
|---|------|-------|---------|------------|
| 1 | `src/config/authTypes.ts` | 57 | Remove `FirestoreUser` interface (lines 28-34). Remove `SignInRequest` and `SignInResponse` (unused). | Low |
| 2 | `src/services/authService.ts` | 303 | Full rewrite: replace all Firebase Auth + Firestore imports with Supabase equivalents. Remove `setUserRole`, `getUserRole`, `getCurrentUser` (Firebase-specific); add `getUserRoleFromSupabase`, `upsertUserRole`. Keep `signInWithEmailLink`, `signOut` with same signatures. | High |
| 3 | `src/config/authContext.tsx` | 286 | Replace `onAuthStateChanged` import/usage with `supabase.auth.onAuthStateChange`. Replace `getUserRole` call with new Supabase-based function. Replace `auth` import from firebase with `supabase` import. Update `impersonateUserForQA` env var check. | High |
| 4 | `src/views/SignInView.tsx` | 293 | Change `VITE_USE_FIREBASE_EMULATOR` to `VITE_USE_DEV_AUTH` (line 80). | Low |
| 5 | `src/test/setup.ts` | 94 | Change `VITE_USE_FIREBASE_EMULATOR` to `VITE_USE_DEV_AUTH` (line 71). | Low |

### Files to Modify (Tests - 4 files)

| # | File | Lines | Changes | Complexity |
|---|------|-------|---------|------------|
| 6 | `src/services/authService.test.ts` | 418 | Rewrite: replace `firebase/auth` and `firebase/firestore` mocks with `@supabase/supabase-js` mocks. Update all test cases to verify Supabase API calls. | Medium |
| 7 | `src/config/authContext.test.tsx` | 573 | Rewrite: replace `onAuthStateChanged` mock with `supabase.auth.onAuthStateChange` mock. Replace `getUserRole` mock pattern. Remove `firebase/auth` and `firebase` config mocks. | Medium |
| 8 | `src/views/SignInView.integration.test.tsx` | 265 | Remove `firebase/auth` and `firebase` config mocks. Keep authService mock (same interface). | Low |
| 9 | `src/views/AuthFlow.integration.test.tsx` | 599 | Remove `firebase/auth` and `firebase` config mocks. Change `VITE_USE_FIREBASE_EMULATOR` to `VITE_USE_DEV_AUTH`. | Low |

### Files NOT Changed (stable consumers)

- `src/App.tsx` - uses `useAuth()` only
- `src/components/OnboardingHub.tsx` - uses `useAuth()` only
- `src/components/ui/NavBar.tsx` - uses `useAuth()` only
- `src/views/SignOutView.tsx` - uses `signOut` from context only
- `src/config/firebase.ts` - deferred to cleanup step
- `src/config/firebase.test.ts` - deferred to cleanup step
- `src/services/supabase/userService.ts` - already Supabase-based, no changes
- `src/services/supabase/mappers.ts` - no changes
- `src/config/supabase.ts` - no changes (already has Proxy pattern)

## Data Model

### Supabase Auth User

When a user signs up/in via `supabase.auth.signUp()` or `supabase.auth.signInWithPassword()`, Supabase creates a record in its internal `auth.users` table. The returned session contains:

```typescript
// supabase.auth.signUp() / supabase.auth.signInWithPassword() return:
{
  data: {
    user: { id: string; email: string; ... },
    session: { access_token: string; ... }
  },
  error: AuthError | null
}
```

### Role Lookup (existing Supabase tables)

The `users` and `user_roles` tables already exist from step 1 (supabase-setup):

```
users table:             user_roles junction table:
+----------+---------+   +---------+-----------+
| id (PK)  | email   |   | user_id | role_name |
+----------+---------+   +---------+-----------+
| uuid     | text    |   | uuid FK | text      |
+----------+---------+   +---------+-----------+
```

**Role lookup query:**
```sql
SELECT u.*, ur.role_name
FROM users u
LEFT JOIN user_roles ur ON ur.user_id = u.id
WHERE u.id = $1
LIMIT 1;
```

**Supabase client equivalent:**
```typescript
const { data } = await supabase
  .from('users')
  .select('*, user_roles(role_name)')
  .eq('id', uid)
  .single();

const role = data?.user_roles?.[0]?.role_name ?? null;
```

### Role Upsert (for setUserRole replacement)

```typescript
// 1. Upsert user row
await supabase.from('users').upsert({
  id: uid,
  email: email,
  name: email.split('@')[0],
  updated_at: new Date().toISOString(),
});

// 2. Upsert role (delete old + insert new)
await supabase.from('user_roles').delete().eq('user_id', uid);
await supabase.from('user_roles').insert({ user_id: uid, role_name: role });
```

## Component Architecture

No new components. The auth layer is entirely service + context:

```
src/
  config/
    authTypes.ts          <-- Remove FirestoreUser, SignInRequest, SignInResponse
    authContext.tsx        <-- Swap Firebase listener for Supabase listener
    supabase.ts           <-- UNCHANGED (already has Proxy client)
    firebase.ts           <-- UNCHANGED (deferred to cleanup)
  services/
    authService.ts        <-- Full rewrite: Firebase -> Supabase Auth + DB
    supabase/
      userService.ts      <-- UNCHANGED (already has getAuthCredential)
      mappers.ts          <-- UNCHANGED
      index.ts            <-- UNCHANGED (already exports getAuthCredential)
  views/
    SignInView.tsx         <-- Env var rename only
  test/
    setup.ts              <-- Env var rename only
```

## Detailed Change Specifications

### 1. `src/config/authTypes.ts`

**Remove:**
- `FirestoreUser` interface (lines 28-34) -- replaced by direct Supabase DB types
- `SignInRequest` interface (lines 42-44) -- unused anywhere
- `SignInResponse` interface (lines 49-53) -- unused anywhere

**Keep unchanged:**
- `UserRole` type
- `AuthUser` interface
- `AuthContextValue` interface

### 2. `src/services/authService.ts`

**Remove all Firebase imports:**
```typescript
// REMOVE these:
import { createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut as firebaseSignOut } from 'firebase/auth';
import { doc, setDoc, getDoc, Timestamp } from 'firebase/firestore';
import { auth, firestore } from '../config/firebase';
import type { FirestoreUser } from '../config/authTypes';
```

**Add Supabase imports:**
```typescript
import { supabase } from '../config/supabase';
```

**Replace `setUserRole()`:**
- Old: Firestore `setDoc(doc(firestore, 'users', uid), userData)`
- New: `upsertUserRole(uid, email, role)` using `supabase.from('users').upsert(...)` + `supabase.from('user_roles')...`

**Replace `getUserRole()`:**
- Old: Firestore `getDoc(doc(firestore, 'users', uid))` -> `userData.role`
- New: `getUserRoleFromSupabase(uid)` using `supabase.from('users').select('*, user_roles(role_name)').eq('id', uid).single()`

**Remove `getCurrentUser()`:**
- Only used internally; Supabase equivalent is `supabase.auth.getUser()` + role lookup

**Replace `signInWithEmailLink()` internals:**
- Keep same function signature and email validation
- Keep `getAuthCredential()` check (already Supabase-based)
- Keep `MOCK_EMAIL_ROLES` mapping
- Replace `createUserWithEmailAndPassword` -> `supabase.auth.signUp({ email, password })`
- Replace `signInWithEmailAndPassword` -> `supabase.auth.signInWithPassword({ email, password })`
- Replace `setUserRole` -> `upsertUserRole`
- Keep localStorage fallback path

**Replace `signOut()`:**
- Keep localStorage clear + custom event dispatch
- Replace `firebaseSignOut(auth)` -> `supabase.auth.signOut()`

### 3. `src/config/authContext.tsx`

**Remove Firebase imports:**
```typescript
// REMOVE:
import { onAuthStateChanged } from 'firebase/auth';
import { auth } from './firebase';
```

**Add Supabase import:**
```typescript
import { supabase } from './supabase';
```

**Replace Effect 1 (auth listener):**
- Old: `onAuthStateChanged(auth, async (firebaseUser) => { ... })`
- New: `supabase.auth.onAuthStateChange(async (event, session) => { ... })`
- Map `session?.user` to same internal logic
- Call `getUserRoleFromSupabase(session.user.id)` instead of `getUserRole(uid)`

**Note on callback shape difference:**
```
Firebase:  onAuthStateChanged(auth, (user) => ...)        // user is User | null
Supabase:  onAuthStateChange((event, session) => ...)     // event is string, session is Session | null
           session?.user.id, session?.user.email
```

**Update `impersonateUserForQA()`:**
- Change `VITE_USE_FIREBASE_EMULATOR` -> `VITE_USE_DEV_AUTH`

**Update `getUserRole` import:**
- Change from `import { getUserRole, signOut } from '../services/authService'`
- To `import { getUserRoleFromSupabase, signOut } from '../services/authService'`
- Or rename the new function to `getUserRole` for minimal diff

### 4. `src/views/SignInView.tsx`

**Line 80 change:**
```typescript
// Old:
const [isEmulatorMode] = useState(import.meta.env.VITE_USE_FIREBASE_EMULATOR === 'true');
// New:
const [isDevAuth] = useState(import.meta.env.VITE_USE_DEV_AUTH === 'true');
```

**Line ~234 change:**
- Update comment/label from "Emulator Mode" to "Dev Auth Mode" (or keep UI text as-is for minimal change)

### 5. `src/test/setup.ts`

**Line 71 change:**
```typescript
// Old:
(import.meta.env as any).VITE_USE_FIREBASE_EMULATOR = 'false';
// New:
(import.meta.env as any).VITE_USE_DEV_AUTH = 'false';
```

## Testing Strategy

### Unit Tests (authService.test.ts rewrite)

| Test | What it validates |
|------|-------------------|
| `signInWithEmailLink` - invalid email | Email validation logic (unchanged behavior) |
| `signInWithEmailLink` - unrecognized email | MOCK_EMAIL_ROLES lookup (unchanged behavior) |
| `signInWithEmailLink` - test email via Supabase signUp | `supabase.auth.signUp()` called with correct params |
| `signInWithEmailLink` - existing user signIn | `supabase.auth.signInWithPassword()` fallback |
| `signInWithEmailLink` - Supabase unavailable fallback | localStorage fallback path |
| `signInWithEmailLink` - Users panel credential | `getAuthCredential()` path |
| `getUserRoleFromSupabase` - found | Supabase select query returns role |
| `getUserRoleFromSupabase` - not found | Returns null |
| `getUserRoleFromSupabase` - error | Returns null gracefully |
| `upsertUserRole` - new user | Upsert + role insert |
| `upsertUserRole` - existing user | Upsert + role replace |
| `signOut` - clears localStorage | localStorage.removeItem called |
| `signOut` - calls Supabase signOut | `supabase.auth.signOut()` called |
| `signOut` - handles Supabase signOut failure | Does not throw |

**Count: ~14 unit tests**

### Integration Tests (authContext.test.tsx rewrite)

| Test | What it validates |
|------|-------------------|
| useAuth outside AuthProvider | Throws error (unchanged) |
| Loading state initially | loading=true (unchanged) |
| Unauthenticated state | user=null when no session |
| Authenticated with role (employee/manager/admin) | Session -> role lookup -> context value |
| Role fetch failure -> clear state | Graceful degradation |
| User without email | Handled gracefully |
| Cleanup on unmount | Unsubscribe called |
| signOut function provided | Context includes signOut |
| Mock auth from localStorage | localStorage takes priority |
| Invalid JSON in localStorage | Graceful fallback |
| Storage event listener | Custom event updates state |
| Cross-tab storage event | Updates state |

**Count: ~14 integration tests**

### View Integration Tests (minimal changes)

`SignInView.integration.test.tsx`: Remove Firebase mocks, keep authService mock (same interface). ~8 tests unchanged.

`AuthFlow.integration.test.tsx`: Remove Firebase mocks, update env var. ~12 tests unchanged.

**Total test count: ~48 tests across 4 test files**

## Supabase Mock Pattern for Tests

The test mocks need to shift from Firebase to Supabase. Here is the mock pattern:

```typescript
// Mock supabase config
vi.mock('../config/supabase', () => ({
  supabase: {
    auth: {
      onAuthStateChange: vi.fn(),
      signUp: vi.fn(),
      signInWithPassword: vi.fn(),
      signOut: vi.fn(),
      getUser: vi.fn(),
    },
    from: vi.fn(() => ({
      select: vi.fn().mockReturnThis(),
      eq: vi.fn().mockReturnThis(),
      single: vi.fn(),
      upsert: vi.fn(),
      insert: vi.fn(),
      delete: vi.fn().mockReturnThis(),
    })),
  },
}));
```

## Implementation Notes

### Decision: Keep function name `getUserRole` (not rename to `getUserRoleFromSupabase`)

Renaming to `getUserRoleFromSupabase` makes the intent clear during migration, but since this is the ONLY getUserRole function after migration, keeping the name `getUserRole` is cleaner. The function body changes, the name stays. This means authContext.tsx import does not change.

### Decision: Supabase auth error code handling

Supabase returns errors differently than Firebase:
- Firebase: `error.code === 'auth/email-already-in-use'`
- Supabase: `error.message` contains details, `error.status` is HTTP status

The sign-in flow checks for "user already registered" to fall back to `signInWithPassword`. Supabase's `signUp()` returns a specific error when the user exists, or it may return a user object with `identities: []` (depending on config). We handle both cases.

### Decision: Password strategy

Current Firebase approach uses `'mockPassword123!'` as a hardcoded password for test accounts. We keep this same approach with Supabase Auth since this is a demo/development environment. Production would use magic links or SSO.

### Non-Goals

- **No RLS policies.** Row-Level Security tied to Supabase Auth requires a live instance. Deferred.
- **No magic links.** Real email verification is a future enhancement.
- **No SSO/OAuth.** Out of scope for this migration step.
- **No removal of `firebase.ts`.** Handled in cleanup step 5.
- **No removal of `firebase` package.** Handled in cleanup step 5.
- **No changes to route protection.** Hash-based routing in App.tsx is unchanged.
