# Plan: devauth-uuid-invalid

## Metadata
- **Feature:** devauth-uuid-invalid (Bug #7, P0 CRITICAL)
- **Created:** 2026-02-16T22:00
- **Status:** plan-complete
- **Based On:** 2026-02-16T22:00_research.md
- **Also Fixes:** Bug #9 (users-table-always-empty) as side effect

## Problem Statement

Dev-auth mode generates non-UUID user IDs (e.g. `test-test-manager`) that are rejected
by PostgreSQL UUID columns. This blocks ALL user creation in dev mode and causes the
Users table to always appear empty.

## Architecture Overview

```
Two-Pronged Fix Strategy
========================

PRONG 1: Fix the source (generate valid UUIDs)
-----------------------------------------------

  impersonateUserForQA()           signInWithEmailLink()
  (authContext.tsx:48)              (authService.ts:165)
       |                                |
       v                                v
  uid: `test-${email...}`          uid: emailHash (base64)
       |                                |
       |  CHANGE TO                     |  CHANGE TO
       v                                v
  uid: DEV_AUTH_UUIDS[email]       uid: DEV_AUTH_UUIDS[email]
       |                                |
       +----------+---------------------+
                  |
                  v
        src/utils/uuid.ts (NEW)
        - DEV_AUTH_UUIDS map
        - isValidUUID()
        - getDevAuthUUID()


PRONG 2: Defense in depth (service-layer guards)
-------------------------------------------------

  All services that insert into UUID columns:

  userService.ts         profileService.ts      profileTemplateService.ts
  (createUser:226)       (createProfile:54)     (createProfileTemplate:82)
       |                      |                        |
       v                      v                        v
  created_by: createdBy  created_by: createdBy   created_by: createdBy
       |                      |                        |
  +--- ADD GUARD ---+--- ADD GUARD ---+--- ADD GUARD ---+
       |
       v
  const safeX = x && isValidUUID(x) ? x : null;

  activityService.ts     roleService.ts (ALREADY HAS GUARD)
  (logActivity:47)       (createRole:102) -- refactor to shared utility
       |
       v
  user_id: userId
       |
  +--- ADD GUARD ---+

  authService.ts
  (setUserRole:37)
       |
       v
  id: uid  (users table PK, already UUID after Prong 1 fix)
```

## Tech Stack Summary

- **Runtime:** React 18 + TypeScript
- **Testing:** Vitest + React Testing Library
- **Database:** Supabase (PostgreSQL with UUID columns)
- **No new dependencies required**

## File Structure

### New Files

| File | Purpose |
|------|---------|
| `src/utils/uuid.ts` | Shared UUID validation utility: `isValidUUID()`, `DEV_AUTH_UUIDS`, `getDevAuthUUID()` |
| `src/utils/uuid.test.ts` | Unit tests for UUID utility (10+ test cases) |

### Modified Files

| File | Lines | Change |
|------|-------|--------|
| `src/config/authContext.tsx` | L48 | Replace `test-${email.split('@')[0]}` with `getDevAuthUUID(email)` import |
| `src/services/authService.ts` | L165, L191, L194, L197 | Replace `emailHash` fallback with `getDevAuthUUID(email)`, add UUID guard to `setUserRole` |
| `src/services/supabase/userService.ts` | L226 | Add `isValidUUID` guard to `created_by` in `createUser` |
| `src/services/supabase/profileService.ts` | L54 | Add `isValidUUID` guard to `created_by` in `createProfile` |
| `src/services/supabase/profileTemplateService.ts` | L82 | Add `isValidUUID` guard to `created_by` in `createProfileTemplate` |
| `src/services/supabase/activityService.ts` | L47 | Add `isValidUUID` guard to `user_id` in `logActivity` |
| `src/services/supabase/roleService.ts` | L19-22, L102 | Remove local `isValidUUID` + `UUID_REGEX`, import from shared utility |
| `src/components/manager/UsersPanel.tsx` | L60, L86, L109 | Replace `'unknown'` fallback with `null` for non-UUID safety |
| `src/components/manager/NewHiresPanel.tsx` | L102 | Replace `'unknown'` fallback with `null` for non-UUID safety |

## Data Model Changes

No database schema changes. The fix is entirely in the application layer:
- UUID columns remain UUID columns
- We fix the data being written to them, not the schema

## Component Architecture

No component architecture changes. This is a data-layer fix that touches:
1. Auth utilities (UUID generation)
2. Service layer (UUID validation guards)
3. Component layer (fallback value changes from `'unknown'` to `null`)

## Shared Utility Design: `src/utils/uuid.ts`

```typescript
/**
 * UUID validation and dev-auth UUID generation utilities.
 */

/** Regex for UUID v4 format validation */
const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

/**
 * Validates whether a string is a valid UUID format.
 * Works with UUID v1-v5 formats (any 8-4-4-4-12 hex pattern).
 */
export function isValidUUID(value: string): boolean {
  return UUID_REGEX.test(value);
}

/**
 * Deterministic UUIDs for the 3 built-in test accounts.
 * These are valid UUID v4-format strings that never collide with
 * real Supabase-generated UUIDs (which use crypto.randomUUID).
 *
 * Format: 00000000-0000-4000-a000-00000000000N
 * - Version nibble = 4 (UUID v4)
 * - Variant bits = 10 (RFC 4122)
 */
export const DEV_AUTH_UUIDS: Record<string, string> = {
  'test-employee@example.com': '00000000-0000-4000-a000-000000000001',
  'test-manager@example.com':  '00000000-0000-4000-a000-000000000002',
  'test-admin@example.com':    '00000000-0000-4000-a000-000000000003',
};

/**
 * Returns the deterministic dev-auth UUID for a known test email,
 * or generates a fallback UUID using crypto.randomUUID() for unknown emails.
 */
export function getDevAuthUUID(email: string): string {
  const normalized = email.toLowerCase().trim();
  return DEV_AUTH_UUIDS[normalized] ?? crypto.randomUUID();
}
```

## Testing Strategy

### Unit Tests (src/utils/uuid.test.ts) -- ~12 tests

| # | Test | Description |
|---|------|-------------|
| 1 | isValidUUID accepts standard v4 UUID | `'550e8400-e29b-41d4-a716-446655440000'` |
| 2 | isValidUUID accepts uppercase UUID | Case insensitive |
| 3 | isValidUUID rejects non-UUID strings | `'test-test-manager'`, `'hello'`, `''` |
| 4 | isValidUUID rejects base64 hash | `'dGVzdC1lbXBsb3ll'` (the old emailHash format) |
| 5 | isValidUUID rejects UUID-like but wrong length | `'550e8400-e29b-41d4-a716'` |
| 6 | isValidUUID rejects empty string | Edge case |
| 7 | DEV_AUTH_UUIDS has entries for all 3 test emails | Map completeness |
| 8 | All DEV_AUTH_UUIDS values are valid UUIDs | Self-consistency |
| 9 | getDevAuthUUID returns correct UUID for employee | Deterministic mapping |
| 10 | getDevAuthUUID returns correct UUID for manager | Deterministic mapping |
| 11 | getDevAuthUUID returns correct UUID for admin | Deterministic mapping |
| 12 | getDevAuthUUID returns valid UUID for unknown email | Fallback path |
| 13 | getDevAuthUUID normalizes email case | `'Test-Manager@Example.COM'` |

### Existing Test Updates

Tests that hardcode non-UUID UIDs (like `'mock-uid-123'` or `'test-uid-123'`) do NOT
need to be updated. These are Supabase mock tests where the UID never reaches PostgreSQL.
The fix is at the service layer (guards) and auth layer (UUID generation), not at the
test mock layer.

However, any tests that specifically test `impersonateUserForQA` behavior will need to
verify the new UUID format.

### Integration Verification

After implementation, run `npx vitest run` to confirm all 443+ existing tests still pass.
The new uuid.test.ts should add ~13 tests.

## Implementation Notes

### Decisions

1. **Hardcoded UUIDs over computed hashes:** Using a static map of 3 known test emails
   to 3 fixed UUIDs is simpler and more reliable than computing UUIDs from email hashes.
   The 3 test accounts are well-known and stable. Dynamic users from the Users panel
   already get real Supabase-generated UUIDs via `addUserToAuthCredentials`.

2. **`crypto.randomUUID()` as fallback:** For any email not in the hardcoded map (edge
   case -- should not happen in normal dev-auth flow), we fall back to `crypto.randomUUID()`.
   This is available in all target environments (modern browsers + Node 19+/Vitest).

3. **Defense in depth:** Even though Prong 1 fixes the root cause, we still add UUID
   validation guards at the service layer. This protects against future code that might
   pass non-UUID values to UUID columns. The pattern is already proven in `roleService.ts`.

4. **`'unknown'` fallback replacement:** `UsersPanel.tsx` and `NewHiresPanel.tsx` use
   `authUser?.uid ?? 'unknown'` as `userId` for activity logging. The string `'unknown'`
   is not a valid UUID and would fail the new service-layer guard. We change the fallback
   to `null`, which is accepted by the nullable UUID columns.

### Patterns

- **Guard pattern:** `const safeX = x && isValidUUID(x) ? x : null;`
- **Import pattern:** `import { isValidUUID, getDevAuthUUID } from '../utils/uuid';`
- **No behavioral changes for production:** Real Supabase Auth always generates valid UUIDs.
  These changes only affect dev-auth mode and add defensive guards.

### Trade-offs

- Adding a shared utility for just 2 functions + 1 constant may seem like overhead, but
  it eliminates duplication (currently in roleService, needs to be in 5 more places) and
  provides a single source of truth for UUID validation logic.

## Non-Goals

- **NOT changing database schema** -- UUID columns remain UUID, no migration needed
- **NOT fixing Bug #8** (user-form-clears-on-error) -- separate bug, separate pipeline
- **NOT fixing Bug #10** (users-error-persists) -- separate bug
- **NOT fixing Bug #11** (users-tab-hmr-bounce) -- separate bug
- **NOT fixing Bug #12** (users-duplicate-error-display) -- separate bug
- **NOT adding `setUserRole` UUID guard** -- After Prong 1 fix, `setUserRole` always
  receives valid UUIDs. If someone calls it with bad data, the DB will reject it, which
  is the correct behavior for a function that writes to a PK column (not nullable).
