# Research: realtime-websocket-fail

## Metadata
- **Feature:** realtime-websocket-fail
- **Created:** 2026-02-16T02:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context
- **Description:** P0 CRITICAL bug -- Supabase Realtime WebSocket closes before connecting. Browser console shows: `WebSocket connection to 'wss://ecnshfhpgwjxvuybewth.supabase.co/realtime/v1/websocket...' failed: WebSocket is closed before the connection is established.` This means zero push updates work across sessions -- all realtime subscriptions silently fail to deliver change events.
- **Where it fits:** Realtime subscriptions underpin the entire app. The Zustand store (5 slices) subscribes to Supabase Realtime for instances, steps, users, activities, and suggestions. Without a working WebSocket, the store only has data from the initial REST fetch. Cross-session updates (manager sees employee progress, employee sees new onboarding instance) never arrive.
- **Dependencies on other features:** The `step-update-400` fix (bug #1) must be completed first because it fixes the database trigger that blocks all UPDATEs to `onboarding_instances`. However, this bug is independent -- even if step updates worked, Realtime pushes would still fail.

## Root Cause Analysis

### The Bug Has MULTIPLE Contributing Factors

After thorough analysis, this is **not a single-cause bug**. There are 3 distinct issues that together result in zero working Realtime subscriptions. They must ALL be addressed.

---

### Factor 1: Dev-Auth Mode Bypasses Supabase Auth -- No Valid JWT for WebSocket

**This is the primary root cause.**

**The auth flow in dev-auth mode (`VITE_USE_DEV_AUTH=true`):**

1. User enters a test email (e.g., `test-manager@example.com`) in `SignInView`
2. `signInWithEmailLink()` in `authService.ts` attempts `supabase.auth.signUp()` / `signInWithPassword()`
3. If Supabase Auth succeeds, a real session is established (JWT token stored by supabase-js)
4. If Supabase Auth fails (e.g., email confirmation required, rate limit, etc.), it **falls back to localStorage mock auth** (lines 199-231 of `authService.ts`)
5. `AuthProvider` checks localStorage FIRST (line 135-141 of `authContext.tsx`): if `mockAuthUser` exists, it skips the Supabase `onAuthStateChange` listener entirely

**The critical problem:** When using localStorage mock auth, the `supabase` client has NO authenticated session. The `supabase-js` client's internal auth state is empty -- no access token, no refresh token. When `supabase.channel(...).subscribe()` is called:

1. The supabase-js Realtime client opens a WebSocket to `wss://ecnshfhpgwjxvuybewth.supabase.co/realtime/v1/websocket`
2. It sends the **anon key** as the initial token (since there's no authenticated session)
3. For `postgres_changes` subscriptions, Supabase Realtime server verifies the token against RLS policies
4. The anon key JWT has `role: "anon"` -- Supabase Realtime checks if the `anon` role can SELECT on the subscribed tables
5. Despite having permissive RLS policies (`USING (true)`), the `anon` role may not be permitted to subscribe to Realtime depending on the project's Realtime configuration

**Evidence from `supabase.ts` (lines 25-41):**
```typescript
function getSupabaseClient(): SupabaseClient<Database> {
  if (!_supabase) {
    // ...
    _supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);
  }
  return _supabase;
}
```
No `realtime` options are configured. The client uses default settings. No `accessToken` callback is provided for custom auth.

**Evidence from `authContext.tsx` (lines 133-141):**
```typescript
useEffect(() => {
  const mockUser = loadMockAuthFromStorage();
  if (mockUser) {
    setUser(mockUser);
    setRole(mockUser.role);
    setLoading(false);
    return; // Don't listen to Supabase if using mock auth
  }
  // ...Supabase auth listener setup below (never reached when mock auth exists)
}, []);
```
When mock auth is present, the Supabase `onAuthStateChange` listener is NEVER set up. The supabase-js client never receives a session. Its internal auth state remains unauthenticated.

---

### Factor 2: Supabase Realtime Publication May Not Be Applied

**Migration `00007_enable_realtime.sql` exists in the codebase:**
```sql
ALTER PUBLICATION supabase_realtime ADD TABLE
  users, roles, profiles, templates, profile_templates,
  onboarding_instances, suggestions, activities,
  template_steps, instance_steps, profile_template_steps,
  user_roles, user_profiles, profile_role_tags,
  instance_profiles, instance_template_refs;
```

**However**, there is no Supabase CLI config (`supabase/config.toml`) and no evidence of automated migration deployment. The `step-update-400` research confirms that migrations needed to be manually applied to the remote Supabase instance. The project uses `supabase/.temp/project-ref` (value: `ecnshfhpgwjxvuybewth`) but no local Supabase instance.

**Risk:** If migration `00007` was not applied to the remote Supabase project, then NO tables are in the `supabase_realtime` publication, and `postgres_changes` events will never fire regardless of auth state.

**How to verify:** Run in the Supabase SQL Editor:
```sql
SELECT tablename FROM pg_publication_tables WHERE pubname = 'supabase_realtime';
```
If this returns 0 rows, the publication is empty and the migration was never applied.

---

### Factor 3: Supabase Project May Have Realtime Disabled

Supabase hosted projects have Realtime enabled by default, but it can be disabled in the project settings. If Realtime is disabled at the project level, the WebSocket endpoint will reject connections immediately -- which matches the symptom "WebSocket is closed before the connection is established."

**How to verify:** Check the Supabase Dashboard at `https://supabase.com/dashboard/project/ecnshfhpgwjxvuybewth/settings/api` -- look for Realtime settings.

---

### Interaction of All 3 Factors

| Factor | Status | Effect |
|--------|--------|--------|
| No authenticated session (Factor 1) | CONFIRMED in code | WebSocket connects with anon key only; postgres_changes may be rejected |
| Publication not applied (Factor 2) | LIKELY (no deployment evidence) | Even with auth, no change events fire |
| Realtime disabled (Factor 3) | POSSIBLE (needs dashboard check) | WebSocket endpoint rejects connection entirely |

The "WebSocket is closed before the connection is established" error message most strongly suggests Factor 3 (Realtime disabled) or a combination of Factors 1+2 (anon key rejected because the Realtime server can't verify subscriptions against empty publication).

## Requirements

### Functional Requirements
- [ ] FR1: Supabase Realtime WebSocket must connect successfully and stay open
- [ ] FR2: `postgres_changes` events must fire when data is modified in any of the 16 tables
- [ ] FR3: Zustand store subscriptions must receive real-time updates (instances, steps, users, activities, suggestions)
- [ ] FR4: Cross-session updates must work: manager sees employee progress changes in real-time, employee sees newly assigned onboarding instances
- [ ] FR5: The fix must work in both dev-auth mode (localStorage mock) and real Supabase Auth mode

### Technical Requirements
- [ ] TR1: Ensure `supabase_realtime` publication includes all 16 tables (verify migration 00007 is applied)
- [ ] TR2: Ensure the Supabase project has Realtime enabled (dashboard setting)
- [ ] TR3: Ensure the supabase-js client has an authenticated session when subscribing to `postgres_changes` channels -- OR configure the Supabase project to allow anon subscriptions
- [ ] TR4: No regression in existing REST API calls (list, get, create, update, delete)
- [ ] TR5: No regression in existing tests (425 passing)

### Code Examples / References

**Current subscription code in `crudFactory.ts` (lines 149-166):**
```typescript
let channel = supabase.channel(subConfig.channelName);

for (const entry of subConfig.tables) {
  const opts: Record<string, string> = {
    event: '*',
    schema: 'public',
    table: entry.table,
  };
  if (entry.filter) {
    opts.filter = entry.filter;
  }
  channel = channel.on('postgres_changes', opts as any, () => {
    debouncedRefetch();
  });
}

channel.subscribe();
```

**Current Supabase client creation (`supabase.ts` line 38):**
```typescript
_supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);
```
No `realtime` options, no `accessToken` callback.

### Warnings/Critical Notes
> The fix requires BOTH server-side (Supabase project configuration) AND client-side (auth token for WebSocket) changes. A client-only fix will not resolve the issue if the publication is missing or Realtime is disabled. A server-only fix will not resolve the issue if the WebSocket has no valid auth token.

## Existing Code Analysis

### Project State
- Project exists: YES
- All 5 Zustand store slices are implemented and working (for initial REST fetch)
- Subscription infrastructure exists and is well-architected (ref-counting, shared subscriptions, debounced re-fetch)
- The client-side subscription code is correct in structure -- the issue is auth/config, not code logic

### Code to Reuse
- `src/services/supabase/crudFactory.ts`: Subscription setup is correct, just needs a valid auth token
- `src/services/supabase/subscriptionManager.ts`: Shared subscription manager is sound
- `src/store/useOnboardingStore.ts`: All 5 subscription starters work correctly for initial data
- `supabase/migrations/00007_enable_realtime.sql`: The SQL is correct, just needs to be verified as applied

### Code to Modify
- `src/config/supabase.ts`: May need to add `realtime` configuration options to `createClient()` call
- `src/services/authService.ts`: The sign-in flow needs to reliably establish a Supabase Auth session (not fall back to localStorage mock for the purpose of Realtime)

### Patterns to Follow
- Supabase-js v2 `createClient` supports `realtime` options including `params.apikey` and custom `accessToken` function
- The existing crudFactory subscription pattern (channel + postgres_changes + debounced refetch) is correct and should not change

## Root Cause Summary

### Primary Issue: No Authenticated Supabase Session in Dev-Auth Mode

When `VITE_USE_DEV_AUTH=true` (which is the default in `.env.local`), the auth flow:

1. Attempts Supabase Auth sign-up/sign-in
2. **Falls back to localStorage mock** if Supabase Auth fails (common for test emails without confirmed accounts)
3. The AuthProvider sees the mock auth and **skips** Supabase `onAuthStateChange` entirely
4. The `supabase` client has **no session** -- its internal auth state is null
5. WebSocket connections use only the anon key
6. The Realtime server may reject the subscription because the anon role cannot subscribe to `postgres_changes` without proper RLS authorization tokens

### The Fix Must Address:

1. **Server-side (Supabase Dashboard):**
   - Verify Realtime is enabled for the project
   - Verify migration 00007 was applied (tables in `supabase_realtime` publication)
   - If not applied, run the `ALTER PUBLICATION` SQL

2. **Client-side (code change):**
   - Ensure the sign-in flow reliably produces a Supabase Auth session (real JWT)
   - The sign-in function already tries `supabase.auth.signUp` + `signInWithPassword` -- the fallback to localStorage indicates this step is failing silently
   - Possible approaches:
     a. Fix the sign-up/sign-in so it succeeds (may require email confirmation disabled in Supabase Auth settings)
     b. Use `supabase.auth.signInWithPassword` with a known password for test users
     c. Add a `global.headers` or custom `accessToken` function to the Supabase client that provides the anon key explicitly for Realtime

## Constraints

### Performance
- No performance constraints -- Realtime WebSocket is a single persistent connection, not per-table

### Platform
- Supabase hosted project at `ecnshfhpgwjxvuybewth.supabase.co`
- No Supabase CLI installed -- changes to the remote instance must be done via Dashboard SQL Editor
- `@supabase/supabase-js` v2.95.3, `@supabase/realtime-js` v2.95.3

### Dependencies
- `step-update-400` should be resolved first (it fixes the trigger blocking UPDATEs) but is not strictly a dependency for this bug
- No new npm packages needed

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Supabase project Realtime disabled | High | Medium | Check Dashboard settings; enable if disabled |
| Migration 00007 not applied | High | Medium | Run SQL in Dashboard SQL Editor to verify and apply |
| Auth sign-in silently fails for test emails | High | High | This IS the current behavior; fix by ensuring sign-in succeeds or providing anon Realtime access |
| Enabling real Supabase Auth breaks dev-auth workflow | Medium | Medium | Keep localStorage mock for UI role routing, but also establish a real Supabase session for API/Realtime |
| RLS policies block anon Realtime even though they say "allow all" | Medium | Low | Supabase Realtime checks RLS at subscription time; permissive policies should work with anon key |

### Complexity
- **Level:** Medium
- **Rationale:** The fix spans server-side configuration (Supabase Dashboard) and client-side auth flow. The client-side change is moderate -- it needs to ensure a real Supabase Auth session exists while maintaining the dev-auth UX. The subscription code itself does NOT need changes.

## Open Questions

- [x] Q1: Is this a Supabase project config issue (Realtime not enabled)?
  - Resolution: POSSIBLY. Must be verified in Supabase Dashboard. The "WebSocket is closed before the connection is established" error is consistent with Realtime being disabled OR the connection being rejected by the server.

- [x] Q2: Is this a missing publication issue (tables not in supabase_realtime)?
  - Resolution: LIKELY. Migration 00007 exists in the codebase but there is no evidence it was applied to the remote instance. No automated migration deployment exists (no Supabase CLI config). Must be verified via SQL: `SELECT tablename FROM pg_publication_tables WHERE pubname = 'supabase_realtime';`

- [x] Q3: Is this an auth issue (no valid JWT for WebSocket)?
  - Resolution: YES, CONFIRMED in code. When using dev-auth mode with localStorage mock, the supabase-js client has NO authenticated session. The WebSocket sends only the anon key. While the anon key SHOULD work for tables with permissive RLS policies, this depends on Supabase project configuration.

- [x] Q4: Is this a dev-auth mode issue specifically?
  - Resolution: YES. The `AuthProvider` (line 140) returns early when mock auth exists in localStorage, skipping the `onAuthStateChange` listener. The supabase-js client's internal session is never populated. In production with real Supabase Auth, this would NOT be an issue because `signInWithPassword` would establish a real session with JWT tokens.

- [x] Q5: Is this a client-side code issue (wrong subscription setup)?
  - Resolution: NO. The subscription code in `crudFactory.ts` and `instanceService.ts` follows the correct Supabase Realtime API pattern. The channel setup, event configuration, and cleanup are all correct.

- [x] Q6: Do the RLS policies allow anon SELECT?
  - Resolution: YES. All 16 tables have `FOR ALL USING (true) WITH CHECK (true)` policies. The `anon` role should be able to read from all tables. However, Supabase Realtime has its own authorization layer that may behave differently from PostgREST.

## Recommended Approach

### Implementation Strategy

**Three-pronged fix (all required):**

#### Prong 1: Verify and Apply Server-Side Configuration

Run in Supabase Dashboard SQL Editor:

```sql
-- Check if Realtime publication includes our tables
SELECT tablename FROM pg_publication_tables WHERE pubname = 'supabase_realtime';
```

If empty, apply migration 00007:
```sql
ALTER PUBLICATION supabase_realtime ADD TABLE
  users, roles, profiles, templates, profile_templates,
  onboarding_instances, suggestions, activities,
  template_steps, instance_steps, profile_template_steps,
  user_roles, user_profiles, profile_role_tags,
  instance_profiles, instance_template_refs;
```

Also verify Realtime is enabled in project settings.

#### Prong 2: Fix Auth Flow to Establish Real Supabase Session

The sign-in flow in `authService.ts` already attempts `supabase.auth.signUp` and `signInWithPassword`. The most likely failure point is:

1. **Email confirmation required:** Supabase Auth may require email confirmation for sign-up. Test users never confirm emails. Fix: Disable email confirmation in Supabase Auth settings (Dashboard > Authentication > Settings > Email Auth > Confirm email = OFF).

2. **Sign-in with password succeeds but session is not used:** The `signInWithEmailLink` function succeeds at Supabase Auth but then the `AuthProvider` finds `mockAuthUser` in localStorage from a previous session and uses that instead. Fix: Clear `mockAuthUser` from localStorage when a real Supabase Auth sign-in succeeds, so the AuthProvider uses the real session.

3. **Dual-track approach:** Keep the mock auth in localStorage for the app's role routing (so the UI knows the user is "manager" or "employee"), but ALSO ensure a real Supabase Auth session exists so the supabase-js client has a valid JWT for Realtime.

**Recommended code change in `authService.ts`:**
- After a successful `signInWithPassword`, do NOT set `useSupabaseAuth = false`
- The Supabase Auth session is automatically stored by supabase-js (in its own storage)
- The `AuthProvider` can still use localStorage for role determination
- The supabase-js Realtime client will automatically use the session's JWT for WebSocket auth

**Recommended code change in `authContext.tsx`:**
- When mock auth is found in localStorage, STILL set up the `onAuthStateChange` listener (don't return early)
- This allows the supabase-js client to maintain its session while the app uses mock auth for role routing
- OR: After setting mock auth state, check if there's also a real Supabase session and use that for the supabase client

#### Prong 3: Add Error Handling and Logging for Realtime Connections

Add channel status callbacks in `crudFactory.ts` to detect and log Realtime connection failures:

```typescript
channel.subscribe((status) => {
  if (status === 'SUBSCRIBED') {
    console.log(`[Realtime] Channel ${subConfig.channelName} subscribed`);
  } else if (status === 'CHANNEL_ERROR') {
    console.error(`[Realtime] Channel ${subConfig.channelName} error`);
  } else if (status === 'TIMED_OUT') {
    console.error(`[Realtime] Channel ${subConfig.channelName} timed out`);
  }
});
```

This ensures future Realtime issues are immediately visible in the console rather than failing silently.

### Order of Work
1. **Server verification (manual, Supabase Dashboard):**
   - Check Realtime is enabled in project settings
   - Run publication check SQL
   - Apply migration 00007 SQL if needed
   - Check Supabase Auth email confirmation setting (disable if enabled)
2. **Client-side auth fix:**
   - Modify `authContext.tsx` to not skip `onAuthStateChange` when mock auth exists
   - Ensure `signInWithEmailLink` in `authService.ts` reliably establishes a Supabase Auth session
3. **Add Realtime status logging:**
   - Add subscription status callbacks in `crudFactory.ts`
   - Add status callbacks in custom subscription functions in `instanceService.ts` and `profileTemplateService.ts`
4. **End-to-end verification:**
   - Sign in as test-manager
   - Open browser DevTools Network tab, filter by WS
   - Verify WebSocket connects and stays open
   - Modify data in another session (or Supabase Dashboard)
   - Verify the Zustand store receives the update

### What to Defer
- Migrating away from dev-auth mode entirely (this is a larger refactor and not needed for the fix)
- Adding reconnection/retry logic for WebSocket drops (supabase-js handles this internally with exponential backoff)
- Per-table subscription health monitoring (overkill for now; console logging is sufficient)

## Key Files

| File | Path | Role |
|------|------|------|
| Supabase client | `/home/sanjay/Workspace/onboarding/src/config/supabase.ts` | Creates the Supabase client -- no realtime options configured |
| Auth context | `/home/sanjay/Workspace/onboarding/src/config/authContext.tsx` | AuthProvider skips `onAuthStateChange` when mock auth exists (line 140) |
| Auth service | `/home/sanjay/Workspace/onboarding/src/services/authService.ts` | Sign-in flow falls back to localStorage mock when Supabase Auth fails |
| CRUD factory | `/home/sanjay/Workspace/onboarding/src/services/supabase/crudFactory.ts` | Creates Realtime channels for all factory-based services (lines 149-166) |
| Instance service | `/home/sanjay/Workspace/onboarding/src/services/supabase/instanceService.ts` | Custom subscriptions for instance, steps, and employee instance (3 functions) |
| Profile template service | `/home/sanjay/Workspace/onboarding/src/services/supabase/profileTemplateService.ts` | Custom subscription (1 function) |
| Zustand store | `/home/sanjay/Workspace/onboarding/src/store/useOnboardingStore.ts` | 5 subscription starters that call the service subscribe functions |
| Realtime migration | `/home/sanjay/Workspace/onboarding/supabase/migrations/00007_enable_realtime.sql` | SQL to add tables to supabase_realtime publication |
| RLS migration | `/home/sanjay/Workspace/onboarding/supabase/migrations/00005_enable_rls.sql` | Permissive RLS policies on all 16 tables |
| Env config | `/home/sanjay/Workspace/onboarding/.env.local` | `VITE_USE_DEV_AUTH=true`, Supabase URL and anon key |

## Subscription Inventory

All places that create Supabase Realtime channels:

| Location | Channel Name | Tables Listened | Used By |
|----------|-------------|-----------------|---------|
| crudFactory (instances) | `instances-all` | `onboarding_instances`, `instance_steps` | `subscribeToOnboardingInstances` -> Zustand instances slice |
| crudFactory (users) | `users-all` | `users`, `user_roles`, `user_profiles` | `subscribeToUsers` -> Zustand users slice |
| crudFactory (activities) | `activities-all` | `activities` | `subscribeToActivities` -> Zustand activities slice |
| crudFactory (suggestions) | `suggestions-all` | `suggestions` | `subscribeToSuggestions` -> Zustand suggestions slice |
| crudFactory (roles) | `roles-all` | `roles` | `subscribeToRoles` -> RoleManagementPanel |
| crudFactory (templates) | `templates-all` | `templates`, `template_steps` | `subscribeToTemplates` -> TemplatesView |
| crudFactory (profiles) | `profiles-all` | `profiles` | `subscribeToProfiles` |
| instanceService | `instance-{id}` | `onboarding_instances`, `instance_steps` | `subscribeToOnboardingInstance` |
| instanceService | `instance-steps-{id}` | `instance_steps` | `subscribeToSteps` -> Zustand steps slice |
| instanceService | `employee-instance-{email}` | `onboarding_instances`, `instance_steps` | `subscribeToEmployeeInstance` |
| profileTemplateService | `profile-templates-{id}` | `profile_templates`, `profile_template_steps` | `subscribeToProfileTemplatesByProfile` |

Total: 11 subscription patterns, all using the same Supabase Realtime `postgres_changes` mechanism, all affected by this bug.

## Next Step

**All questions resolved. Status: research-complete.**

Run `/plan realtime-websocket-fail` to create implementation plan.
