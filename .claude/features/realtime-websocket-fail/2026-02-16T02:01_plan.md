# Plan: realtime-websocket-fail

## Metadata
- **Feature:** realtime-websocket-fail
- **Created:** 2026-02-16T02:01
- **Status:** plan-complete
- **Based-on:** 2026-02-16T02:00_research.md

---

## Problem Summary

Supabase Realtime WebSocket closes before connecting. Browser console shows:
`WebSocket connection to 'wss://...supabase.co/realtime/v1/websocket...' failed: WebSocket is closed before the connection is established.`

All 11 subscription patterns across the app silently fail to deliver change events. Cross-session updates never arrive.

**Root Cause (3 contributing factors):**
1. Dev-auth mode creates a mock localStorage session but never establishes a real Supabase session -- WebSocket has no JWT
2. Realtime publication migration (00007) may not be applied to remote DB
3. Supabase project may have Realtime disabled at the project level

---

## Architecture Overview

### Current Flow (broken)

```
SignInView
  |
  v
authService.signInWithEmailLink()
  |
  +-- Try supabase.auth.signUp/signInWithPassword
  |     |
  |     +-- SUCCESS: Real session stored by supabase-js internally
  |     |             setUserRole() called
  |     |             BUT: no mockAuthUser written to localStorage
  |     |
  |     +-- FAIL: Falls back to localStorage mockAuthUser
  |               supabase-js has NO session
  |
  v
AuthProvider (authContext.tsx) useEffect #1
  |
  +-- loadMockAuthFromStorage()
  |     |
  |     +-- Found mockAuthUser? --> setUser(), setRole(), RETURN EARLY
  |     |                           onAuthStateChange NEVER set up
  |     |                           supabase-js session state: IGNORED
  |     |
  |     +-- No mockAuthUser? --> Set up onAuthStateChange listener
  |                              Works correctly for real Supabase Auth
  |
  v
crudFactory / instanceService / profileTemplateService
  |
  +-- supabase.channel(...).on('postgres_changes', ...).subscribe()
  |     |
  |     +-- supabase-js opens WebSocket
  |     +-- Sends anon key (no session JWT available)
  |     +-- Server may reject --> "WebSocket closed before connection established"
```

### Fixed Flow (target)

```
SignInView
  |
  v
authService.signInWithEmailLink()
  |
  +-- Try supabase.auth.signUp/signInWithPassword
  |     |
  |     +-- SUCCESS: Real session stored by supabase-js
  |     |             setUserRole() called
  |     |             ALSO write mockAuthUser to localStorage (for role routing)
  |     |
  |     +-- FAIL: Falls back to localStorage mockAuthUser
  |               supabase-js has NO session (acceptable -- offline dev)
  |
  v
AuthProvider (authContext.tsx) useEffect #1
  |
  +-- loadMockAuthFromStorage()
  |     |
  |     +-- Found mockAuthUser? --> setUser(), setRole(), setLoading(false)
  |     |                           STILL set up onAuthStateChange listener
  |     |                           (allows supabase-js to maintain its session)
  |     |
  |     +-- No mockAuthUser? --> Set up onAuthStateChange listener
  |                              (unchanged behavior)
  |
  v
crudFactory / instanceService / profileTemplateService
  |
  +-- supabase.channel(...).on('postgres_changes', ...).subscribe((status) => {
  |     console.log/error based on status   <-- NEW: observability
  |   })
  |     |
  |     +-- supabase-js opens WebSocket
  |     +-- If real session exists: sends JWT --> subscriptions work
  |     +-- If no session (offline dev): sends anon key --> may still fail
  |         (acceptable -- offline dev has no live DB anyway)
```

### Key Design Decisions

1. **Dual-track auth (keep mock + allow real session):** The mock auth in localStorage serves the app's role routing (employee/manager/admin). The real Supabase Auth session (if available) serves the WebSocket JWT. Both can coexist.

2. **Don't break offline dev:** When Supabase Auth is unavailable (no live instance), the localStorage fallback still works. Realtime won't work in that case, but that's expected -- there's no live DB to push events from.

3. **AuthProvider always sets up onAuthStateChange:** Even when mock auth is present, the Supabase `onAuthStateChange` listener is set up. This allows supabase-js to maintain its session for Realtime. The mock auth data takes precedence for UI role routing, but the onAuthStateChange callback does NOT overwrite mock auth state -- it only runs if the supabase session changes and there's no mock auth.

4. **authService writes mockAuthUser on successful Supabase Auth:** When `signInWithPassword` or `signUp` succeeds, we write the mockAuthUser to localStorage so the AuthProvider can immediately use it for role routing, avoiding the async getUserRole race condition.

---

## Tech Stack Summary

No new dependencies. Uses existing:
- `@supabase/supabase-js` v2.95.3 (Realtime built-in)
- React 18 context (AuthProvider)
- Vitest + React Testing Library (tests)

---

## File Structure

### Files to Modify

| # | File | Lines | Changes |
|---|------|-------|---------|
| 1 | `src/config/authContext.tsx` | ~288 lines | Remove early return when mock auth found; always set up `onAuthStateChange` listener; guard against mock-auth overwrite |
| 2 | `src/services/authService.ts` | ~269 lines | On successful Supabase Auth, write mockAuthUser to localStorage (dual-track); dispatch authStorageChange event |
| 3 | `src/services/supabase/crudFactory.ts` | ~187 lines | Add channel status callback to `channel.subscribe()` for observability |
| 4 | `src/services/supabase/instanceService.ts` | ~557 lines | Add channel status callbacks to 3 custom `.subscribe()` calls |
| 5 | `src/services/supabase/profileTemplateService.ts` | ~256 lines | Add channel status callback to 1 custom `.subscribe()` call |

### Files to Modify (tests -- update existing)

| # | File | Changes |
|---|------|---------|
| 6 | `src/config/authContext.test.tsx` | Add tests for: mock auth + onAuthStateChange coexistence, onAuthStateChange doesn't overwrite mock auth |
| 7 | `src/services/authService.test.ts` | Add tests for: successful Supabase Auth writes mockAuthUser + dispatches event |
| 8 | `src/services/supabase/crudFactory.test.ts` | Add tests for: subscribe() calls channel.subscribe with status callback |

### Server-Side (Manual -- not code)

| # | Action | Where |
|---|--------|-------|
| S1 | Verify Realtime enabled | Supabase Dashboard > Settings > API |
| S2 | Verify/apply publication SQL | Supabase Dashboard > SQL Editor: `SELECT tablename FROM pg_publication_tables WHERE pubname = 'supabase_realtime';` |
| S3 | Verify email confirmation disabled | Supabase Dashboard > Auth > Settings > Email Auth > Confirm email |

### New Files

None. All changes are modifications to existing files.

---

## Detailed Design

### Change 1: `authContext.tsx` -- Always set up onAuthStateChange

**Current behavior (lines 133-141):**
```typescript
useEffect(() => {
  const mockUser = loadMockAuthFromStorage();
  if (mockUser) {
    setUser(mockUser);
    setRole(mockUser.role);
    setLoading(false);
    return; // <-- PROBLEM: early return skips onAuthStateChange
  }
  // ... onAuthStateChange setup
}, []);
```

**New behavior:**
```typescript
useEffect(() => {
  const mockUser = loadMockAuthFromStorage();
  if (mockUser) {
    setUser(mockUser);
    setRole(mockUser.role);
    setLoading(false);
    // DO NOT return early -- fall through to set up onAuthStateChange
  }

  // Always listen to Supabase auth state changes
  // When mock auth is active, we still want supabase-js to manage its
  // internal session so Realtime WebSocket has a valid JWT.
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    async (_event, session) => {
      // If mock auth is active, don't overwrite app-level user/role state.
      // The onAuthStateChange listener is only here so supabase-js can
      // maintain its internal session for Realtime.
      const currentMockUser = loadMockAuthFromStorage();
      if (currentMockUser) {
        return; // Mock auth takes precedence for UI state
      }

      // ... existing session handling (unchanged)
    },
  );

  return () => subscription.unsubscribe();
}, []);
```

**Why:** The `onAuthStateChange` listener is what allows supabase-js to maintain its internal auth session. By skipping it when mock auth exists, the client never gets a JWT, and the WebSocket has no token to authenticate with.

**Guard against overwrite:** Inside the `onAuthStateChange` callback, we check `loadMockAuthFromStorage()`. If mock auth is present, we skip updating the React state (user/role) -- the mock auth data takes precedence for UI routing. The supabase-js internal session still updates, which is what Realtime needs.

### Change 2: `authService.ts` -- Write mockAuthUser on successful Supabase Auth

**Current behavior:** When `signInWithPassword` succeeds, the function calls `setUserRole()` to write to the DB but does NOT write to localStorage. The `AuthProvider` only sees the mock auth if the fallback path was taken.

**New behavior:** After successful Supabase Auth (signUp or signInWithPassword), ALSO write the `mockAuthUser` to localStorage and dispatch the `authStorageChange` event. This ensures:
1. The `AuthProvider` picks up the user immediately (from localStorage)
2. The supabase-js client also has a real session (from the auth call)
3. The WebSocket gets a valid JWT

**Specific changes:**
- After line 194 (signInWithPassword success) and line 197 (signUp success), add localStorage write + custom event dispatch
- Keep the existing localStorage fallback for when Supabase Auth fails entirely

### Change 3: `crudFactory.ts` -- Add channel status logging

**Current (line 166):**
```typescript
channel.subscribe();
```

**New:**
```typescript
channel.subscribe((status) => {
  if (status === 'SUBSCRIBED') {
    console.debug(`[Realtime] Channel ${subConfig.channelName} subscribed`);
  } else if (status === 'CHANNEL_ERROR') {
    console.error(`[Realtime] Channel ${subConfig.channelName} error`);
  } else if (status === 'TIMED_OUT') {
    console.error(`[Realtime] Channel ${subConfig.channelName} timed out`);
  } else if (status === 'CLOSED') {
    console.warn(`[Realtime] Channel ${subConfig.channelName} closed`);
  }
});
```

### Change 4 & 5: `instanceService.ts` and `profileTemplateService.ts` -- Same status logging

Apply the same status callback pattern to:
- `subscribeToOnboardingInstance` (line 430)
- `subscribeToSteps` (line 484)
- `subscribeToEmployeeInstance` (line 550)
- `subscribeToProfileTemplates` (line 248)

---

## Testing Strategy

### Unit Tests (modify existing files)

**`authContext.test.tsx` (+3 tests):**
1. When mock auth exists AND onAuthStateChange fires with a session, mock auth state should NOT be overwritten (mock auth takes precedence for UI)
2. When mock auth exists, onAuthStateChange listener is still set up (subscription.unsubscribe called on unmount)
3. When mock auth is cleared (sign out) and onAuthStateChange fires, user state should update from the session

**`authService.test.ts` (+2 tests):**
1. When signUp succeeds (new user), mockAuthUser is written to localStorage with correct uid/email/role AND authStorageChange event is dispatched
2. When signInWithPassword succeeds (existing user), mockAuthUser is written to localStorage with correct uid/email/role AND authStorageChange event is dispatched

**`crudFactory.test.ts` (+2 tests):**
1. subscribe() passes a status callback to channel.subscribe (not bare `.subscribe()`)
2. subscribe() channel.subscribe receives a function argument (verify the callback is there)

**Total new tests: 7**

### Integration Tests

No new integration test files needed. The existing store tests and service tests cover the subscription wiring. The behavioral change (WebSocket actually connecting) requires a live Supabase instance -- covered by manual verification.

### Manual Verification (E2E)

After implementation:
1. Sign in as `test-manager@example.com`
2. Open DevTools Network tab, filter by WS
3. Verify WebSocket connects to `wss://...supabase.co/realtime/v1/websocket`
4. Verify console shows `[Realtime] Channel instances-all subscribed` (and similar for other channels)
5. Open a second browser tab, sign in as `test-employee@example.com`
6. Complete a step in the employee view
7. Verify the manager view updates in real time (progress, status)

---

## Server-Side Verification Checklist

These are manual steps the developer must perform in the Supabase Dashboard before or during implementation. They are NOT code changes.

1. **Check Realtime is enabled:**
   - Dashboard URL: `https://supabase.com/dashboard/project/ecnshfhpgwjxvuybewth/settings/api`
   - If Realtime is disabled, enable it

2. **Check publication tables:**
   ```sql
   SELECT tablename FROM pg_publication_tables WHERE pubname = 'supabase_realtime';
   ```
   - If returns 0 rows, run migration 00007:
   ```sql
   ALTER PUBLICATION supabase_realtime ADD TABLE
     users, roles, profiles, templates, profile_templates,
     onboarding_instances, suggestions, activities,
     template_steps, instance_steps, profile_template_steps,
     user_roles, user_profiles, profile_role_tags,
     instance_profiles, instance_template_refs;
   ```

3. **Check email confirmation:**
   - Dashboard > Auth > Settings > Email Auth
   - If "Confirm email" is ON, turn it OFF (so test user signUp produces a usable session)

---

## Implementation Notes

### Decisions

1. **Keep dual-track auth, don't remove mock auth:** Removing mock auth entirely would be a larger refactor affecting the sign-in UX and all test users. The dual-track approach (mock for UI routing, real session for Realtime) is the minimal fix.

2. **Use `console.debug` for success, `console.error` for failures:** Channel status logging uses `console.debug` for the success case (SUBSCRIBED) so it doesn't clutter the console in production. Errors use `console.error` for visibility.

3. **No retry logic:** supabase-js v2 has built-in exponential backoff retry for WebSocket connections. Adding custom retry logic would conflict with the library's internal handling.

4. **No changes to `supabase.ts` (client config):** The research suggested possibly adding `realtime` options to `createClient()`. After analysis, this is unnecessary. The default Realtime config is correct. The issue is purely about the auth session, not the client configuration.

### Patterns

- Follow existing test patterns: `vi.hoisted()` for mock setup, `vi.mock()` for module mocking, `renderHook` + `waitFor` for context tests
- Follow existing code style: JSDoc comments, TypeScript strict mode, console.warn/error for warnings

### Trade-offs

| Choice | Benefit | Cost |
|--------|---------|------|
| Dual-track auth | Minimal code change, backwards compatible | Slight complexity in AuthProvider (check mock auth in callback) |
| Always set up onAuthStateChange | Supabase-js session maintained for Realtime | Tiny extra overhead (listener set up even when mock auth active) |
| Write mockAuthUser on auth success | AuthProvider immediately picks up user | Duplicates user data in localStorage + supabase-js internal storage |

---

## Non-Goals

- **Removing dev-auth mode entirely:** This is a larger refactor and not needed for the fix. Dev-auth mode remains for fast QA switching.
- **Adding WebSocket reconnection logic:** supabase-js handles reconnection internally with exponential backoff.
- **Per-table subscription health monitoring:** Console logging is sufficient for observability. A health dashboard or status UI is overkill.
- **Migrating to Supabase CLI for migrations:** The project doesn't use Supabase CLI. Server-side changes remain manual via Dashboard SQL Editor.
- **Changing RLS policies:** The existing permissive policies (`USING (true)`) are correct. The issue is auth tokens, not authorization.

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Supabase Auth signUp/signIn fails for test emails | Medium | Medium | The existing localStorage fallback still works for UI; Realtime won't work without a real session but that's the current state anyway |
| onAuthStateChange callback overwrites mock auth state | High | Low | Explicit guard: check `loadMockAuthFromStorage()` inside callback, skip if present |
| Existing tests break due to authContext change | Medium | Medium | Tests that mock `onAuthStateChange` with early return need to account for mock auth NOT causing early return anymore |
| Server-side publication not applied | High | Medium | Document the manual verification steps clearly; add console error for channel failures so it's immediately obvious |
