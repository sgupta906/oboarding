# Plan: kpi-count-stale

## Metadata
- **Feature:** kpi-count-stale (Bug #31, P2 MEDIUM)
- **Created:** 2026-02-17T00:00
- **Status:** plan-complete
- **Based On:** `.claude/features/kpi-count-stale/2026-02-17T00:00_research.md`

## Problem Statement

When an employee completes a step via `_updateStepStatus()`, the Zustand store optimistically updates `stepsByInstance` (StepsSlice) but does NOT update the `instances` array (InstancesSlice). Since KPISection reads from `instances` to count active onboardings, the KPI counts remain stale until the Realtime subscription re-fetches all instances (~300ms debounce). Additionally, KPISection has a fallback step-counting path that could produce misleading counts if `onboardingInstances` is empty.

## Architecture Overview

```
Before Fix:

  Employee completes step
  ┌────────────────────┐
  │ _updateStepStatus  │
  └──────┬─────────────┘
         │
         ▼
  ┌──────────────────┐     ┌────────────────────┐
  │ stepsByInstance   │     │ instances[]         │
  │ (StepsSlice)     │     │ (InstancesSlice)    │
  │ UPDATED          │     │ NOT UPDATED (stale) │
  └──────────────────┘     └──────────┬──────────┘
                                      │ reads from
                                      ▼
                              ┌──────────────┐
                              │ KPISection   │
                              │ (stale data) │
                              └──────────────┘

After Fix:

  Employee completes step
  ┌────────────────────┐
  │ _updateStepStatus  │
  └──────┬─────────────┘
         │
    ┌────┴─────────────────┐
    ▼                      ▼
  ┌──────────────────┐   ┌────────────────────┐
  │ stepsByInstance   │   │ instances[]         │
  │ (StepsSlice)     │   │ (InstancesSlice)    │
  │ UPDATED          │   │ ALSO UPDATED        │
  └──────────────────┘   └──────────┬──────────┘
                                    │ reads from
                                    ▼
                            ┌──────────────┐
                            │ KPISection   │
                            │ (fresh data) │
                            └──────────────┘
```

## Tech Stack

- **Store:** Zustand (existing `useOnboardingStore`)
- **Testing:** Vitest + React Testing Library
- **Components:** React 18 + TypeScript

## File Structure

### Files to Modify

| File | Lines | Change Description |
|------|-------|--------------------|
| `src/store/useOnboardingStore.ts` | 410-440 | Add cross-slice optimistic update in `_updateStepStatus`: after updating `stepsByInstance`, also update matching instance in `instances[]` (steps, progress, status). Update rollback to capture and restore both `stepsByInstance` AND `instances` snapshots. |
| `src/components/manager/KPISection.tsx` | 40-44 | Remove the fallback step-counting path. When `onboardingInstances` is empty, return 0 instead of falling back to `countStepsByProfileAndStatus()`. |
| `src/store/useOnboardingStore.test.ts` | ~690 | Add 4 new tests for cross-slice optimistic update behavior and rollback. |
| `src/components/manager/KPISection.test.tsx` | ~108 | Add 2 new tests for KPISection with empty instances (regression) and with active instances (counts correctly). |

### No New Files

This is a targeted bugfix -- no new files are needed.

## Data Model

No database changes. The fix is entirely client-side optimistic state management.

### Instance Progress Recomputation Formula

```typescript
const completedCount = steps.filter(s => s.status === 'completed').length;
const progress = steps.length === 0 ? 0 : Math.round((completedCount / steps.length) * 100);
```

This matches the server-side formula in `instanceService.ts:273`.

### Instance Status Transition Rules

```
progress === 100  =>  status = 'completed'
progress < 100 && was 'completed'  =>  status = 'active'  (un-completing a step)
progress < 100 && was NOT 'completed'  =>  status unchanged (keep 'active' or 'on_hold')
```

## Component Architecture

No new components. Changes are within existing components:

```
useOnboardingStore (Zustand)
├── InstancesSlice
│   └── instances[]  <-- NOW also updated by _updateStepStatus
└── StepsSlice
    ├── stepsByInstance{}  <-- already updated by _updateStepStatus
    └── _updateStepStatus()  <-- modified to update BOTH slices

KPISection (React component)
└── getActiveCount()  <-- remove fallback step-counting path
```

## Testing Strategy

### Unit Tests (Store) -- 4 new tests

1. **`_updateStepStatus also updates instances[].steps`** -- Verify that after calling `_updateStepStatus`, the matching instance in `instances[]` has the step status updated.
2. **`_updateStepStatus recomputes instances[].progress`** -- Verify that progress is recomputed: 2 steps, 1 completed = 50%.
3. **`_updateStepStatus transitions instance status to completed when all steps done`** -- Verify that when all steps become 'completed', instance status changes to 'completed'.
4. **`_updateStepStatus rollback reverts both stepsByInstance and instances`** -- Verify that on server error, BOTH `stepsByInstance` AND `instances` are rolled back to their pre-mutation snapshots.

### Unit Tests (KPISection) -- 2 new tests

5. **`getActiveCount returns 0 when onboardingInstances is empty (no fallback)`** -- Verify that with empty instances and non-empty steps, the active count is 0 (not a step count).
6. **`getActiveCount correctly counts active instances`** -- Verify that with 2 active and 1 completed instance, the count is 2.

### Total: 6 new tests

Existing test count: 638. Expected after fix: 644.

## Implementation Notes

### Key Design Decisions

1. **Single `set()` call for instances update:** Rather than a separate `set()` call, we could merge the stepsByInstance and instances updates into one `set()` for atomicity. However, keeping them as two sequential synchronous `set()` calls is fine because Zustand batches synchronous updates within the same event loop tick. Using two calls is clearer and matches the existing code style.

2. **Rollback captures full `instances` snapshot:** The existing `_updateInstance` action (line 309) captures the full `instances` array for rollback. We follow the same pattern here. While capturing just the single modified instance would be more memory-efficient, using the full array is simpler and consistent with established patterns.

3. **Status transition is conservative:** We only transition to 'completed' when progress === 100. We transition from 'completed' back to 'active' when progress drops below 100 (un-completing a step). We never touch 'on_hold' status -- that is a manager-set state that should not change automatically.

4. **KPISection fallback removal:** The fallback path (lines 41-43) counts pending STEPS when `onboardingInstances` is empty. Since `onboardingInstances` is always provided by ManagerView (line 282), this is dead code. Removing it prevents misleading counts if `onboardingInstances` is transiently empty during initial load.

### Patterns Followed

- Optimistic update + rollback pattern (same as `_updateInstance` lines 307-323)
- Progress formula matches server-side (`instanceService.ts:273`)
- Snapshot-based rollback (capture before mutation, restore on error)

### Trade-offs

- **Optimistic progress may briefly disagree with server:** The client-side progress is a simple `completedCount / totalCount` calculation. The server recomputes the same formula. There is a brief window where both values exist, but the Realtime re-fetch replaces the entire `instances` array, so the server value always wins within ~300ms.
- **No "stuck" step handling for KPI:** The "Stuck Employees" KPI uses `countStepsByProfileAndStatus(steps, ...)` where `steps` comes from `instances.flatMap(i => i.steps)`. Since we now update `instances[].steps` optimistically, this count will also become fresh. This is a free bonus fix.

## Non-Goals

- **Not changing Realtime subscription patterns.** The re-fetch still happens and still overwrites `instances` with server data. Our optimistic update just fills the gap.
- **Not adding new network requests.** Progress is computed entirely from existing step data in the store.
- **Not modifying the server-side progress calculation.** The server formula remains the source of truth.
- **Not adding profile-based filtering to the optimistic update.** The instance update is profile-agnostic; KPISection handles profile filtering after reading from the store.
- **Not changing NewHiresPanel.** It reads from the same `instances` store, so it automatically benefits from the cross-slice update.
