# Research: kpi-count-stale

## Metadata
- **Feature:** kpi-count-stale (Bug #31)
- **Created:** 2026-02-17T00:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context
- **Description:** KPI "Active Onboardings" shows inconsistent counts between the Dashboard tab (KPISection) and the New Hires tab (NewHiresPanel filter buttons)
- **Where it fits:** Manager dashboard data consistency; affects trust in KPI metrics
- **Dependencies:** Zustand store instances slice, Supabase Realtime subscriptions

## Root Cause Analysis

### Confirmed Root Cause: Dual-State Staleness Between `instances[].steps` and `stepsByInstance`

The Zustand store maintains two parallel representations of step data that can become inconsistent:

1. **`instances` array** (InstancesSlice) -- each `OnboardingInstance` has an embedded `steps: Step[]` array, plus `progress: number` and `status: 'active' | 'completed' | 'on_hold'`
2. **`stepsByInstance` map** (StepsSlice) -- a `Record<string, Step[]>` keyed by instanceId

When an employee completes a step via `_updateStepStatus()`:
- **StepsSlice** is updated **optimistically** (instant) -- `stepsByInstance[instanceId]` reflects the new status
- **InstancesSlice** is **NOT updated** -- `instances[i].steps`, `instances[i].progress`, and `instances[i].status` remain stale until the Realtime subscription re-fetches all instances (debounced 300ms)

This creates a window where:
- KPISection reads `onboardingInstances` from InstancesSlice and counts `instance.status === 'active'`
- The instance's `progress` and `status` are stale (e.g., still shows 'active' when it should be 'completed')
- The KPI over-counts or under-counts active onboardings

### Secondary Issue: KPI Fallback Path Counts Steps Instead of Instances

In `KPISection.tsx` lines 41-43:
```typescript
if (!onboardingInstances || onboardingInstances.length === 0) {
  // Fallback to step-based counting if instances not provided (legacy support)
  return countStepsByProfileAndStatus(steps, selectedProfile, 'pending');
}
```

This fallback counts individual **steps** with status 'pending', not active **instances**. If for any transient reason `onboardingInstances` is empty (e.g., during initial load before subscription callback fires), the KPI shows a step count (potentially much higher) instead of an instance count. The `steps` prop comes from `managerSteps = instances.flatMap(i => i.steps)`, which is ALSO empty when instances is empty, so this specific path is self-consistent. But the fallback is still confusing: if `onboardingInstances` is an empty array `[]`, the condition `onboardingInstances.length === 0` triggers and it falls back to step counting. This means during initial data load both will show 0, but if instances fail to load for any reason while steps are provided separately, the counts diverge.

### Tertiary Issue: KPISection "Stuck" Count Uses Steps, "Active" Count Uses Instances

Looking at the KPISection component:
- **Active Onboardings**: Counts `instance.status === 'active'` from `onboardingInstances` prop (instance-level count)
- **Stuck Employees**: Counts via `countStepsByProfileAndStatus(steps, selectedProfile, 'stuck')` (step-level count)

The `steps` prop is `managerSteps` from ManagerView (line 77-79): `instances.flatMap(i => i.steps)`. Since the `instances[].steps` can be stale (not updated by optimistic step status changes), the "Stuck Employees" KPI will also be stale.

Meanwhile, the `stuckEmployeeNames` is computed from the SAME stale `onboardingInstances`, so it is internally consistent with the stuck count. But both are stale relative to the actual step data in `stepsByInstance`.

### The NewHiresPanel Counts

NewHiresPanel calls `useOnboardingInstances()` independently and computes:
```typescript
const statusCounts = useMemo(() => {
  const counts = { all: data.length, active: 0, completed: 0, on_hold: 0 };
  for (const inst of data) {
    if (inst.status === 'active') counts.active++;
    else if (inst.status === 'completed') counts.completed++;
    else if (inst.status === 'on_hold') counts.on_hold++;
  }
  return counts;
}, [data]);
```

Since both ManagerView and NewHiresPanel read from the SAME Zustand `instances` array, these counts should always match (both are stale in the same way). The inconsistency is NOT between Dashboard tab KPI and New Hires tab filter counts (which are the same store data), but rather between the KPI display and the ACTUAL current state of the data.

### Summary of Root Cause

The KPI counts are **internally consistent** between Dashboard and New Hires tabs (same store), but they are **stale relative to the actual step data** because:
1. `_updateStepStatus` updates `stepsByInstance` but NOT `instances[].steps/progress/status`
2. The instances subscription re-fetches after 300ms debounce, creating a visible staleness window
3. The `progress` field in instances is computed server-side, so it lags behind optimistic step updates

## Requirements

### Functional Requirements
- [ ] FR1: KPI "Active Onboardings" count must update immediately when an employee completes all steps (instance transitions active->completed)
- [ ] FR2: KPI "Stuck Employees" count must update immediately when a step is marked as stuck or un-stuck
- [ ] FR3: Instance `progress` field must stay in sync with step completion state
- [ ] FR4: Remove or guard the fallback step-counting path in KPISection to prevent incorrect metric types

### Technical Requirements
- [ ] TR1: When `_updateStepStatus` changes a step, propagate progress/status changes to the `instances` array optimistically
- [ ] TR2: Maintain the server as source of truth -- optimistic updates must be reconciled when Realtime re-fetch arrives
- [ ] TR3: No additional Supabase queries -- compute progress client-side from step data already in the store

### Constraints
- Must not break the existing Realtime subscription and ref-counting patterns
- Must not add new network requests (compute from existing data)
- Must preserve the existing test suite (638 tests passing)

## Existing Code Analysis

### Project State
- Project exists: YES
- Zustand migration: COMPLETE (5/5 slices)
- Test count: 638 tests across 30 files

### Code Locations Involved

| File | Lines | Role |
|------|-------|------|
| `src/store/useOnboardingStore.ts` | 410-440 | `_updateStepStatus` -- only updates `stepsByInstance`, NOT `instances` |
| `src/store/useOnboardingStore.ts` | 247-323 | InstancesSlice -- `instances` array with embedded steps/progress/status |
| `src/components/manager/KPISection.tsx` | 40-68 | `getActiveCount()` -- reads from `onboardingInstances` prop |
| `src/components/manager/KPISection.tsx` | 71-73 | `getStuckCount()` -- reads from `steps` prop (which is `instances.flatMap(i => i.steps)`) |
| `src/views/ManagerView.tsx` | 77-79 | `managerSteps` -- derived from `onboardingInstances.flatMap(i => i.steps)` |
| `src/views/ManagerView.tsx` | 278-283 | KPISection prop wiring |
| `src/components/manager/NewHiresPanel.tsx` | 151-159 | `statusCounts` -- computed from same store data |
| `src/services/supabase/instanceService.ts` | 238-295 | `updateStepStatus` -- server-side progress recalculation |

### Code to Modify

1. **`src/store/useOnboardingStore.ts`** -- `_updateStepStatus` action: After optimistically updating `stepsByInstance`, also update the corresponding instance in `instances` array:
   - Update `instances[i].steps` to reflect the new step status
   - Recompute `instances[i].progress` from the updated steps
   - Update `instances[i].status` to 'completed' if progress === 100

2. **`src/components/manager/KPISection.tsx`** -- Remove or guard the fallback step-counting path (lines 41-43) to prevent incorrect metric types when instances array is empty.

### Patterns to Follow
- Optimistic update + rollback pattern used by `_updateInstance` (lines 307-323)
- Progress computation formula: `Math.round((completedCount / totalCount) * 100)` (matches server-side logic at line 273)

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Optimistic progress conflicts with Realtime re-fetch | Low | Medium | Realtime re-fetch overwrites entire `instances` array, so optimistic values are naturally replaced. No conflict. |
| Completed status set prematurely (all steps completed but server disagrees) | Low | Low | Server is source of truth; optimistic 'completed' will be corrected by Realtime within 300ms |
| Race condition: step update + instance re-fetch interleave | Low | Low | Zustand set() is synchronous; re-fetch replaces all data atomically |

### Complexity
- **Level:** Simple
- **Rationale:** The fix is a targeted enhancement to `_updateStepStatus` to propagate step changes to the instances array. No new patterns needed, no new subscriptions, no architectural changes. ~15 lines of code change plus tests.

## Open Questions

All questions resolved through code analysis:

- [x] Q1: Do KPISection and NewHiresPanel read from the same store data?
  - Resolution: YES. Both call `useOnboardingInstances()` which reads from Zustand `instances` array. The data is always the same.

- [x] Q2: Why do counts differ between views?
  - Resolution: The counts differ between the KPI display and the ACTUAL current state because `_updateStepStatus` only updates `stepsByInstance`, not `instances[].steps/progress/status`. The KPIs read from `instances` which is stale until Realtime re-fetches (300ms debounce).

- [x] Q3: Is there a fallback path that could produce wrong counts?
  - Resolution: YES. KPISection line 41-43 falls back to counting pending STEPS instead of active INSTANCES when `onboardingInstances` is empty. This should be removed or explicitly guarded.

## Recommended Approach

### Implementation Strategy

**Approach: Cross-slice optimistic update in `_updateStepStatus`**

After the existing optimistic update to `stepsByInstance`, add a second `set()` call that:
1. Finds the instance in `instances` array by `instanceId`
2. Updates the matching step's status in `instance.steps`
3. Recomputes `instance.progress` from the updated steps
4. Sets `instance.status` to 'completed' if progress reaches 100%

This ensures both `stepsByInstance` and `instances` are immediately consistent after a step status change.

```typescript
// In _updateStepStatus, after the existing optimistic update to stepsByInstance:
set((state) => ({
  instances: state.instances.map((inst) => {
    if (inst.id !== instanceId) return inst;
    const updatedSteps = inst.steps.map((s) =>
      s.id === stepId ? { ...s, status } : s
    );
    const completedCount = updatedSteps.filter((s) => s.status === 'completed').length;
    const progress = updatedSteps.length === 0
      ? 0
      : Math.round((completedCount / updatedSteps.length) * 100);
    return {
      ...inst,
      steps: updatedSteps,
      progress,
      status: progress === 100 ? 'completed' as const : inst.status === 'completed' ? 'active' as const : inst.status,
    };
  }),
}));
```

Also update the rollback to revert both `stepsByInstance` AND `instances`:
```typescript
// Capture both snapshots
const stepsSnapshot = get().stepsByInstance[instanceId] ?? [];
const instancesSnapshot = get().instances;

// ... optimistic updates ...

// On error, rollback both:
set((state) => ({
  stepsByInstance: { ...state.stepsByInstance, [instanceId]: stepsSnapshot },
  instances: instancesSnapshot,
}));
```

### Secondary Fix: Remove KPISection Fallback

Remove the fallback step-counting path in `KPISection.tsx` lines 41-43. Since `onboardingInstances` is always provided by ManagerView, the fallback is dead code that could produce misleading counts if triggered.

### Order of Work
1. Fix `_updateStepStatus` to propagate changes to `instances` array (primary fix)
2. Update rollback to revert both slices
3. Remove/guard KPISection fallback path
4. Add tests for cross-slice optimistic update
5. Add test for KPISection with empty instances (regression)

### What to Defer
- No profile-based filtering changes needed (profiles are not actively used)
- No changes to Realtime subscriptions needed (they already work correctly for eventual consistency)

## Next Step

**All questions resolved.**
Run `/plan kpi-count-stale` to create implementation plan.
