# Plan: zustand-store

## Metadata
- **Feature:** zustand-store
- **Created:** 2026-02-15T00:01
- **Status:** plan-complete
- **Based on:** 2026-02-15T00:00_research.md

## Architecture Overview

### Current Data Flow (Problem)

```
                    +-------------------+
                    |   Supabase RT     |
                    +--------+----------+
                             |
              +--------------+----------------+
              |                               |
   subscribeToOnboardingInstances()   subscribeToEmployeeInstance()
              |                               |
    +---------+---------+              +------+-------+
    |                   |              |              |
useManagerData      NewHiresPanel   useEmployeeOnboarding
(OnboardingHub)    (own sub!)       (OnboardingHub)
    |                   |              |
    v                   v              v
  useState #1       useState #2    useState #3
  (instances)       (instances)    (instance)
    |                   |              |
    +---> EmployeeSelector             |
    |     (via props)                  |
    +---> KPISection                   |
          (via props)                  |
                                       |
                              EmployeeView
                              (via props)
```

Three independent state silos. Three independent subscriptions.
Updates hit each subscription independently with different timing,
causing stale data in some components.

### Target Data Flow (Solution)

```
                    +-------------------+
                    |   Supabase RT     |
                    +--------+----------+
                             |
              subscribeToOnboardingInstances()
                     (ONE subscription)
                             |
                    +--------v----------+
                    |  Zustand Store    |
                    |  +--------------+ |
                    |  | instances[]  | |
                    |  | isLoading    | |
                    |  | error        | |
                    |  +--------------+ |
                    +--------+----------+
                             |
              +--------------+----------------+
              |              |                |
  useOnboardingInstances  useEmployeeOnboarding  (direct store access)
  (thin wrapper)          (selector + filter)
              |              |                |
              v              v                v
         useManagerData   OnboardingHub   NewHiresPanel
              |              |
              v              v
    EmployeeSelector   EmployeeView
    KPISection
```

One subscription. One source of truth. All consumers read from
the same store. Updates propagate to all components simultaneously.

### Subscription Lifecycle (Reference-Counted)

```
  Mount order:  useManagerData -> NewHiresPanel -> useEmployeeOnboarding

  useManagerData mounts
    _startSubscription() called
      refCount: 0 -> 1
      subscribeToOnboardingInstances() STARTS
      returns cleanup fn
    effect cleanup saved

  NewHiresPanel mounts (via useOnboardingInstances)
    _startSubscription() called
      refCount: 1 -> 2
      no-op (already subscribed)
      returns cleanup fn
    effect cleanup saved

  useEmployeeOnboarding mounts
    _startSubscription() called
      refCount: 2 -> 3
      no-op (already subscribed)
      returns cleanup fn
    effect cleanup saved

  --- User navigates away ---

  All three unmount, cleanup fns fire:
    refCount: 3 -> 2 -> 1 -> 0
    Last cleanup: unsubscribe from Supabase RT channel
```

## Tech Stack

| Technology | Version | Purpose |
|-----------|---------|---------|
| Zustand | ^5.x | Global state management |
| React | ^18.3.1 | UI framework (existing) |
| TypeScript | ^5.5.3 | Type safety (existing) |
| Vitest | ^4.0.13 | Unit/integration testing (existing) |

## File Structure

### New Files

| File | Purpose | Lines (est.) |
|------|---------|-------------|
| `src/store/useOnboardingStore.ts` | Zustand store with instances slice, ref-counted subscription, actions | ~80 |
| `src/store/index.ts` | Barrel export for the store | ~5 |
| `src/store/useOnboardingStore.test.ts` | Unit tests for store: state management, subscription lifecycle, selectors | ~150 |

### Modified Files

| File | What Changes | Current Lines | Impact |
|------|-------------|--------------|--------|
| `src/hooks/useOnboardingInstances.ts` | Rewrite internals to read from store, preserve return type API | 61 | HIGH - public API preserved, internals replaced |
| `src/hooks/useEmployeeOnboarding.ts` | Rewrite internals to derive from store, preserve return type API | 47 | HIGH - public API preserved, internals replaced |
| `src/hooks/useOnboardingInstances.test.ts` | NEW file - add tests for the migrated hook | 0 (new) | MEDIUM |
| `src/hooks/useEmployeeOnboarding.test.ts` | NEW file - add tests for the migrated hook | 0 (new) | MEDIUM |
| `package.json` | Add `zustand` to dependencies | 54 | LOW |

### Files NOT Modified

| File | Reason |
|------|--------|
| `src/hooks/useManagerData.ts` | Calls `useOnboardingInstances()` internally -- API unchanged, works as-is |
| `src/services/supabase/instanceService.ts` | Service layer stays as-is |
| `src/services/supabase/crudFactory.ts` | No changes needed |
| `src/services/supabase/subscriptionManager.ts` | No changes needed |
| `src/components/OnboardingHub.tsx` | Uses hooks via same API contract |
| `src/components/manager/NewHiresPanel.tsx` | Calls `useOnboardingInstances()` -- same API |
| `src/components/manager/NewHiresPanel.test.tsx` | Mocks `../../hooks` -> `useOnboardingInstances` -- return type unchanged |
| `src/hooks/useSteps.test.ts` | Not affected -- different hook |
| `src/hooks/useSuggestions.test.ts` | Not affected -- different hook |
| All other hooks | Not migrated in this slice |

## Store Design

### Store Shape (TypeScript)

```typescript
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import type { OnboardingInstance } from '../types';
import { subscribeToOnboardingInstances } from '../services/supabase';

interface InstancesSlice {
  /** All onboarding instances from the realtime subscription */
  instances: OnboardingInstance[];
  /** Whether the initial data load is in progress */
  instancesLoading: boolean;
  /** Error from subscription setup or data fetch */
  instancesError: Error | null;
  /** Internal: starts the ref-counted subscription. Returns cleanup function. */
  _startInstancesSubscription: () => () => void;
}

type OnboardingStore = InstancesSlice;
// Future slices added here via intersection: InstancesSlice & StepsSlice & ...
```

### Reference-Counted Subscription Implementation

```typescript
// Module-level variables (outside the store)
let refCount = 0;
let cleanup: (() => void) | null = null;

// Inside the store's _startInstancesSubscription action:
_startInstancesSubscription: () => {
  refCount++;

  if (refCount === 1) {
    // First consumer -- start the real subscription
    set({ instancesLoading: true, instancesError: null });

    try {
      cleanup = subscribeToOnboardingInstances((instances) => {
        set({ instances, instancesLoading: false });
      });
    } catch (err) {
      set({
        instancesError: err instanceof Error ? err : new Error(String(err)),
        instancesLoading: false,
      });
    }
  }

  // Return a cleanup function that decrements the ref count
  let cleaned = false;
  return () => {
    if (cleaned) return;
    cleaned = true;
    refCount--;

    if (refCount === 0 && cleanup) {
      cleanup();
      cleanup = null;
      // Reset state when no consumers remain
      set({ instances: [], instancesLoading: false, instancesError: null });
    }
  };
}
```

### Selector Patterns

```typescript
// All instances (for NewHiresPanel, KPI, EmployeeSelector)
const instances = useOnboardingStore(s => s.instances);

// Loading state
const isLoading = useOnboardingStore(s => s.instancesLoading);

// Error state
const error = useOnboardingStore(s => s.instancesError);

// Single instance by email (for employee view) -- derived
// The selector creates a new reference each time, so components using
// this must accept potential re-renders OR we use shallow comparison
const instance = useOnboardingStore(s =>
  s.instances
    .filter(i => i.employeeEmail.toLowerCase() === email.toLowerCase())
    .sort((a, b) => b.createdAt - a.createdAt)[0] ?? null
);
```

### Hook Migration Design

**`useOnboardingInstances` (after migration):**
```typescript
export function useOnboardingInstances(enabled = true): UseOnboardingInstancesReturn {
  const instances = useOnboardingStore(s => s.instances);
  const isLoading = useOnboardingStore(s => s.instancesLoading);
  const error = useOnboardingStore(s => s.instancesError);

  useEffect(() => {
    if (!enabled) return;
    const unsub = useOnboardingStore.getState()._startInstancesSubscription();
    return unsub;
  }, [enabled]);

  return {
    data: enabled ? instances : [],
    isLoading: enabled ? isLoading : false,
    error: enabled ? error : null,
  };
}
```

**`useEmployeeOnboarding` (after migration):**
```typescript
export function useEmployeeOnboarding(email: string | null): UseEmployeeOnboardingReturn {
  const instance = useOnboardingStore(s =>
    email
      ? s.instances
          .filter(i => i.employeeEmail.toLowerCase() === email.toLowerCase())
          .sort((a, b) => b.createdAt - a.createdAt)[0] ?? null
      : null
  );
  const isLoading = useOnboardingStore(s => s.instancesLoading);
  const error = useOnboardingStore(s => s.instancesError);

  useEffect(() => {
    if (!email) return;
    const unsub = useOnboardingStore.getState()._startInstancesSubscription();
    return unsub;
  }, [email]);

  return {
    instance,
    isLoading: !!email && isLoading,
    error: email ? error : null,
  };
}
```

Key design decisions:
1. Both hooks call `_startInstancesSubscription()` -- the ref-counting ensures only one real subscription exists.
2. `useEmployeeOnboarding` derives its data from the all-instances list instead of using `subscribeToEmployeeInstance`. This eliminates a separate per-email subscription.
3. Return types are identical to the current API, so `useManagerData`, `OnboardingHub`, `NewHiresPanel` all work without changes.

## Testing Strategy

### Unit Tests: Store (`src/store/useOnboardingStore.test.ts`)

| Test | Description |
|------|-------------|
| Initial state | Store initializes with empty instances, loading=false, error=null |
| `_startInstancesSubscription` starts subscription | Calls `subscribeToOnboardingInstances`, sets loading=true |
| Subscription callback updates state | When callback fires, instances populate and loading=false |
| Subscription error handling | When subscription throws, error is set and loading=false |
| Ref-counting: second start is no-op | Second call does not start another subscription |
| Ref-counting: cleanup decrements | Calling cleanup reduces refCount |
| Ref-counting: last cleanup unsubscribes | When refCount hits 0, Supabase unsubscribe is called |
| Ref-counting: last cleanup resets state | State returns to initial when no consumers |
| Double-cleanup is safe | Calling cleanup twice does not decrement below 0 |

### Unit Tests: useOnboardingInstances (`src/hooks/useOnboardingInstances.test.ts`)

| Test | Description |
|------|-------------|
| Returns data, isLoading, error | Return shape matches API contract |
| enabled=true starts subscription | `_startInstancesSubscription` is called |
| enabled=false returns empty data | Returns `{ data: [], isLoading: false, error: null }` |
| Cleans up on unmount | Cleanup function called on unmount |
| Mirrors store state | When store updates, hook return value updates |

### Unit Tests: useEmployeeOnboarding (`src/hooks/useEmployeeOnboarding.test.ts`)

| Test | Description |
|------|-------------|
| Returns instance, isLoading, error | Return shape matches API contract |
| email=null returns null instance | Returns `{ instance: null, isLoading: false, error: null }` |
| Finds correct instance by email | Case-insensitive match on employeeEmail |
| Returns most recent instance | When multiple instances for same email, returns latest createdAt |
| Cleans up on unmount | Cleanup function called on unmount |
| Mirrors store state | When store updates, derived instance updates |

### Existing Tests: Verification

| Test File | Tests | Expected Result |
|-----------|-------|----------------|
| `src/components/manager/NewHiresPanel.test.tsx` | 12 | PASS - mocks `../../hooks` at module level, return type unchanged |
| `src/hooks/useSteps.test.ts` | 3 | PASS - unaffected hook |
| `src/hooks/useSuggestions.test.ts` | 3 | PASS - unaffected hook |
| All other test files | 332 | PASS - no changes to their dependencies |

### Test Counts

| Category | Count |
|----------|-------|
| Existing tests (must pass) | 350 |
| New store tests | ~9 |
| New useOnboardingInstances tests | ~5 |
| New useEmployeeOnboarding tests | ~6 |
| **Total expected** | **~370** |

## Implementation Notes

### Decisions

1. **Zustand 5.x over 4.x**: Better TypeScript support, maintained version, native React 18 support.

2. **Devtools middleware deferred**: The research noted devtools as nice-to-have. To keep this slice focused, we skip devtools middleware and add it in a follow-up or during `zustand-cleanup` (slice 5). The store structure supports adding it later with zero consumer changes.

3. **Module-level ref-counting over store-level**: The `refCount` and `cleanup` variables live at module scope, not inside the store. This avoids serialization issues and keeps subscription lifecycle orthogonal to state. The store only manages the data; the module manages the plumbing.

4. **No `useShallow` needed for `useOnboardingInstances`**: The hook reads `instances`, `instancesLoading`, `instancesError` as three separate selectors. Each is a primitive or array reference. Zustand's default `Object.is` equality check is sufficient -- the array reference only changes when the subscription fires new data.

5. **`useEmployeeOnboarding` selector equality**: The `.filter().sort()[0]` selector creates new intermediate arrays on every store update, but the final value is a reference to an object in the store's `instances` array. If the same object reference is returned (i.e., the employee's instance didn't change), React won't re-render because `Object.is` passes. If the instance DID change, we want the re-render. This is correct behavior without needing `useShallow`.

6. **State reset on last cleanup**: When the last consumer unmounts, we reset `instances: [], instancesLoading: false, instancesError: null`. This ensures a clean slate when consumers remount (e.g., user navigates away and back). The subscription will re-fetch fresh data on next mount.

### Patterns

- **Store file structure**: Single file for the store (`useOnboardingStore.ts`) with a barrel export (`index.ts`). Future slices add to the same store via Zustand's slice pattern (combine with `&` intersection type and spread in `create()`).

- **Test mocking pattern**: Store tests mock `../services/supabase` at the module level (same as existing hook tests). Hook tests can either mock the store module or mock the underlying services -- we choose to mock `../services/supabase` for consistency with existing patterns and to test the full integration path through the store.

- **TSDoc comments**: All exported functions and the store definition get TSDoc comments, matching the existing codebase convention.

### Trade-offs

| Decision | Benefit | Cost |
|----------|---------|------|
| Derive employee instance from all-instances list | Eliminates per-email subscription channel | Slightly more computation (filter+sort on every store update) -- negligible for <200 instances |
| Module-level ref-counting | Simple, proven pattern (mirrors subscriptionManager.ts) | Not serializable; harder to test in isolation (mitigated by resetting in test beforeEach) |
| Keep hooks as wrappers | Zero changes to consumers (OnboardingHub, NewHiresPanel, etc.) | Extra layer of indirection; hooks remain as "pass-through" code until slice 5 cleanup |

## Non-Goals

These are explicitly out of scope for this slice:

- **Devtools middleware** -- add later during cleanup slice
- **Persist middleware** -- realtime data, no need to persist
- **Steps slice** -- slice 2 (`zustand-steps`)
- **Users slice** -- slice 3 (`zustand-users`)
- **Activities/suggestions slices** -- slice 4
- **Removing old hooks entirely** -- slice 5
- **Changes to service layer** -- store consumes services as-is
- **Changes to OnboardingHub component** -- works via unchanged hook APIs
- **Optimistic update actions in store** -- `useSteps` has optimistic updates but is not migrated here
- **React Router or routing changes** -- out of scope
