# Research: zustand-store

## Metadata
- **Feature:** zustand-store
- **Created:** 2026-02-15T00:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context

This is the first slice of an incremental Zustand migration. The goal is to:

1. Install Zustand as a dependency
2. Create a Zustand store with an `instances` slice
3. Migrate `useOnboardingInstances` and `useEmployeeOnboarding` hooks to read from / write to the store
4. Fix `realtime-status-sync` and `employee-dropdown-sync` bugs as side effects of the shared state

### Where it fits in the project

This is migration slice 1 of 5 in the architecture refactor roadmap (see STATUS.md). The project completed 15 features prior to this, most recently `restore-users-tab`. The five slices are:

1. **zustand-store** (THIS) - Store setup + instances slice
2. `zustand-steps` - Steps slice
3. `zustand-users` - Users slice
4. `zustand-activities` - Activities + suggestions slices
5. `zustand-cleanup` - Remove old hooks, slim OnboardingHub

After this slice: all non-migrated hooks continue working unchanged. Only the instances data path uses the store.

### Dependencies on other features
- None -- this is the first slice, all prerequisite features are complete.

### What depends on this feature
- All subsequent slices (2-5) depend on the store foundation created here.
- Bug fixes `realtime-status-sync` and `employee-dropdown-sync` are verified as part of this slice.

## Requirements

### Functional Requirements
- [ ] FR1: Install Zustand as a runtime dependency (source: STATUS.md roadmap)
- [ ] FR2: Create a Zustand store with an `instances` slice containing all `OnboardingInstance[]` data (source: STATUS.md)
- [ ] FR3: The store must manage a single Supabase Realtime subscription for `onboarding_instances` + `instance_steps` tables, replacing the per-component subscriptions (source: STATUS.md -- "One subscription per table in the store")
- [ ] FR4: Migrate `useOnboardingInstances` hook to read from the store instead of maintaining its own `useState` + subscription (source: STATUS.md)
- [ ] FR5: Migrate `useEmployeeOnboarding` hook to derive employee instance from the store's instances array instead of maintaining its own subscription (source: STATUS.md)
- [ ] FR6: `NewHiresPanel` must continue working -- it currently calls `useOnboardingInstances()` directly (source: code analysis)
- [ ] FR7: `OnboardingHub` must continue working -- it uses `useEmployeeOnboarding` for employee view and `useManagerData` which internally calls `useOnboardingInstances` (source: code analysis)
- [ ] FR8: `EmployeeSelector` dropdown must update in real-time when new instances are created or instance data changes (source: `employee-dropdown-sync` bug)
- [ ] FR9: New Hires table progress/status must update in real-time when employees complete steps (source: `realtime-status-sync` bug)
- [ ] FR10: The store subscription must start on first consumer mount and stop when no consumers remain (lifecycle management) (source: architectural requirement)
- [ ] FR11: Existing `useSteps`, `useSuggestions`, `useActivities`, `useManagerData` hooks must continue working unchanged (source: STATUS.md -- "Old hooks and new store coexist during transition")

### Technical Requirements
- [ ] TR1: Zustand version `^5.x` (latest stable as of Feb 2026) (source: npm)
- [ ] TR2: Store must be TypeScript-typed with the `OnboardingInstance` type from `src/types/index.ts`
- [ ] TR3: Store must support selectors (e.g., `useStore(s => s.instances)`) for render optimization
- [ ] TR4: All 350 existing tests must continue passing after migration
- [ ] TR5: New unit tests must be added for the store slice and migrated hooks
- [ ] TR6: Store file must follow project conventions: TSDoc comments, modular file structure

### Constraints
- The app must be fully functional after this slice -- no half-broken state
- Old hooks that are NOT being migrated in this slice must remain untouched
- No changes to the Supabase service layer (`instanceService.ts`) -- the store consumes the existing service functions
- No changes to the `crudFactory.ts` or `subscriptionManager.ts` -- those remain as-is

## Existing Code Analysis

### Project State
- Project exists: YES (15 features completed)
- Test baseline: 350 tests across 25 test files, all passing
- Build: Clean (`npx tsc -b` + `npx vite build`)

### Current Data Flow (Instances)

```
Supabase Realtime → subscribeToOnboardingInstances() → useOnboardingInstances hook → component state
                  → subscribeToEmployeeInstance()     → useEmployeeOnboarding hook  → component state
```

**Problem: Isolated state silos.** Each hook maintains its own `useState`, its own subscription, its own copy of the data. When an employee completes a step:
- The `subscribeToEmployeeInstance` channel fires and updates the employee's local state
- The `subscribeToOnboardingInstances` channel fires and updates the manager's local state
- BUT: `NewHiresPanel` has its OWN call to `useOnboardingInstances()`, creating a DUPLICATE subscription with its own independent state
- The `EmployeeSelector` receives instances via props from `OnboardingHub` (which uses `useManagerData` -> `useOnboardingInstances`), so it only updates when that specific subscription fires -- creating a timing gap

**Target Data Flow (After migration):**
```
Supabase Realtime → store subscription → Zustand store (single source of truth)
                                          ↓
                                     useOnboardingInstances() reads from store
                                     useEmployeeOnboarding() derives from store
                                     NewHiresPanel reads from store
                                     EmployeeSelector reads from store
                                     KPISection reads from store
```

### Files to Create

| File | Purpose |
|------|---------|
| `src/store/index.ts` | Barrel export for the store |
| `src/store/useOnboardingStore.ts` | Zustand store with instances slice |
| `src/store/useOnboardingStore.test.ts` | Unit tests for the store |

### Files to Modify

| File | What Changes | Lines |
|------|-------------|-------|
| `src/hooks/useOnboardingInstances.ts` | Rewrite to read from store instead of own subscription | 61 lines |
| `src/hooks/useEmployeeOnboarding.ts` | Rewrite to derive from store instead of own subscription | 47 lines |
| `src/hooks/useManagerData.ts` | May need minor adjustments since it calls `useOnboardingInstances` internally | 95 lines |
| `src/components/manager/NewHiresPanel.test.tsx` | Update mock to match new hook implementation | 229 lines |
| `src/hooks/useSteps.test.ts` | Verify still passes (no changes expected) | 94 lines |

### Files to NOT Modify

| File | Reason |
|------|--------|
| `src/services/supabase/instanceService.ts` | Service layer stays as-is; store consumes it |
| `src/services/supabase/crudFactory.ts` | No changes needed |
| `src/services/supabase/subscriptionManager.ts` | No changes needed |
| `src/components/OnboardingHub.tsx` | Should work unchanged since hooks maintain the same API |
| `src/components/manager/NewHiresPanel.tsx` | Should work unchanged since `useOnboardingInstances` API stays the same |
| `src/components/onboarding/EmployeeSelector.tsx` | Props-based, no hook dependency |
| `src/views/ManagerView.tsx` | Props-based, no direct hook dependency on instances |
| `src/views/EmployeeView.tsx` | Props-based, no direct hook dependency |

### Patterns to Follow

1. **Hook return types must be preserved.** `useOnboardingInstances` returns `{ data, isLoading, error }`. `useEmployeeOnboarding` returns `{ instance, isLoading, error }`. These are the public API contracts.

2. **Supabase mocking pattern.** Tests mock `../services/supabase` at the module level with `vi.mock()`. The new store tests should follow the same pattern.

3. **TSDoc comments.** Every exported function has a JSDoc/TSDoc comment.

4. **Barrel exports.** Hooks use `src/hooks/index.ts`. The new store should use `src/store/index.ts`.

5. **File naming.** camelCase filenames matching the export name (e.g., `useOnboardingStore.ts`).

### Key Type: OnboardingInstance

```typescript
interface OnboardingInstance {
  id: string;
  employeeName: string;
  employeeEmail: string;
  role: string;
  department: string;
  templateId: string;
  steps: Step[];
  createdAt: number;
  startDate?: number;
  completedAt?: number;
  progress: number;
  status: 'active' | 'completed' | 'on_hold';
  profileIds?: string[];
  templateIds?: string[];
  templateSnapshots?: { ... };
}
```

### Key Service Functions (consumed by store)

From `instanceService.ts` via `crudFactory`:

```typescript
// Fetches all instances with joined steps
subscribeToOnboardingInstances(callback: (items: OnboardingInstance[]) => void): () => void
// - Uses crudFactory.subscribe()
// - Listens on 'instances-all' channel
// - Subscribes to both 'onboarding_instances' and 'instance_steps' tables
// - 300ms debounce on re-fetch
// - Returns unsubscribe function
```

From `instanceService.ts` (custom):

```typescript
// Fetches single instance by email (most recent)
subscribeToEmployeeInstance(email: string, callback: (instance | null) => void): () => void
// - Has its own separate channel per email
// - Listens on both tables
// - 300ms debounce
```

### Subscription Duplication Analysis

Currently, these subscriptions exist for instances data:

| Consumer | Subscription | Channel Name | Tables |
|----------|-------------|-------------|--------|
| `useManagerData` -> `useOnboardingInstances` | `subscribeToOnboardingInstances` | `instances-all` | `onboarding_instances`, `instance_steps` |
| `NewHiresPanel` -> `useOnboardingInstances` | `subscribeToOnboardingInstances` | `instances-all` (duplicate!) | `onboarding_instances`, `instance_steps` |
| `OnboardingHub` -> `useEmployeeOnboarding` | `subscribeToEmployeeInstance` | `employee-instance-{email}` | `onboarding_instances`, `instance_steps` |

After migration, there should be **one** store subscription that feeds all consumers.

Note: The `instances-all` subscription in `crudFactory` does NOT use `shared: true`, so each call to `subscribeToOnboardingInstances` creates its own channel. This is the root cause of the duplicate subscription.

## Bug Analysis

### Bug 1: realtime-status-sync

**Symptom:** New Hires table progress/status doesn't update when employees complete steps.

**Root Cause:** `NewHiresPanel` calls `useOnboardingInstances()` directly, creating its own subscription channel. The `subscribeToOnboardingInstances` function (via `crudFactory`) creates a new Supabase channel each time it's called. Both the `NewHiresPanel` and `useManagerData` (in `OnboardingHub`) subscribe independently. The timing of debounced re-fetches means updates may not reach `NewHiresPanel` consistently.

**Fix via Zustand:** Single store subscription means `NewHiresPanel` reads from the same `instances` array as everything else. When the subscription fires and the store updates, all consumers re-render with the new data.

### Bug 2: employee-dropdown-sync

**Symptom:** Manager's Employee View dropdown doesn't update in real-time when new employees are onboarded.

**Root Cause:** The `EmployeeSelector` receives `instances` as a prop from `OnboardingHub`, which gets them from `useManagerData` -> `useOnboardingInstances`. This is a separate subscription from `NewHiresPanel`'s. When a new onboarding run is created, the subscription may or may not fire depending on channel timing. The debounced re-fetch (300ms) can miss the update if the component re-renders before the debounce fires.

**Fix via Zustand:** All components read from the same store. When the subscription fires, the store updates, and all consumers (including the `EmployeeSelector`'s parent) re-render.

## Store Design (Recommended)

### Store Shape

```typescript
interface InstancesSlice {
  // State
  instances: OnboardingInstance[];
  isLoading: boolean;
  error: Error | null;

  // Derived data helpers (not stored, computed via selectors)
  // getInstanceById: (id: string) => OnboardingInstance | undefined
  // getInstanceByEmail: (email: string) => OnboardingInstance | null

  // Actions
  _startSubscription: () => () => void;  // internal: starts the Supabase subscription
}

interface OnboardingStore extends InstancesSlice {
  // Future slices will be added here:
  // steps: StepsSlice;
  // users: UsersSlice;
  // etc.
}
```

### Subscription Lifecycle

The store subscription should be reference-counted:

1. First consumer mounts -> start subscription
2. More consumers mount -> no-op (already subscribed)
3. Consumers unmount -> decrement ref count
4. Last consumer unmounts -> clean up subscription

This mirrors the existing `createSharedSubscription` pattern in `subscriptionManager.ts` but at the store level.

**Recommended approach:** Use a `useEffect` in the migrated hooks that calls a store action to start/stop the subscription. Or use Zustand's `subscribe` with a React effect to manage lifecycle.

### Selector Patterns

```typescript
// All instances (for NewHiresPanel, KPISection)
const instances = useOnboardingStore(s => s.instances);

// Single instance by email (for employee view)
const instance = useOnboardingStore(s =>
  s.instances.find(i => i.employeeEmail === email) ?? null
);

// Loading state
const isLoading = useOnboardingStore(s => s.isLoading);
```

### Hook Migration Strategy

**`useOnboardingInstances` (after):**
```typescript
export function useOnboardingInstances(enabled = true) {
  const instances = useOnboardingStore(s => s.instances);
  const isLoading = useOnboardingStore(s => s.isLoading);
  const error = useOnboardingStore(s => s.error);

  // Manage subscription lifecycle
  useEffect(() => {
    if (!enabled) return;
    const unsub = useOnboardingStore.getState()._startSubscription();
    return unsub;
  }, [enabled]);

  return {
    data: enabled ? instances : [],
    isLoading: enabled ? isLoading : false,
    error: enabled ? error : null,
  };
}
```

**`useEmployeeOnboarding` (after):**
```typescript
export function useEmployeeOnboarding(email: string | null) {
  const instance = useOnboardingStore(s =>
    email ? s.instances.find(i => i.employeeEmail.toLowerCase() === email.toLowerCase()) ?? null : null
  );
  const isLoading = useOnboardingStore(s => s.isLoading);
  const error = useOnboardingStore(s => s.error);

  // Ensure subscription is running when we need data
  useEffect(() => {
    if (!email) return;
    const unsub = useOnboardingStore.getState()._startSubscription();
    return unsub;
  }, [email]);

  return { instance, isLoading: !!email && isLoading, error };
}
```

This approach:
- Preserves the exact same return type API
- Eliminates the `subscribeToEmployeeInstance` subscription (employee data comes from the all-instances subscription)
- Reference-counts the subscription so it starts on first consumer and stops on last

**Key insight:** `subscribeToEmployeeInstance` fetches the most recent instance for an email. The all-instances subscription (`subscribeToOnboardingInstances`) already returns ALL instances. The employee hook can simply filter from the full list, sorting by `createdAt` descending and taking the first match. This eliminates a separate per-email subscription channel entirely.

## Constraints

### Performance
- The all-instances subscription fetches up to 200 rows (default `listLimit` in crudFactory). This is fine for the expected usage (dozens, not thousands of employees).
- Zustand selectors with reference equality prevent unnecessary re-renders. The `useEmployeeOnboarding` selector must use `useMemo` or Zustand's `useShallow` to avoid re-renders on every store update.
- The 300ms debounce on realtime re-fetches is preserved (it's in the service layer, not the hook).

### Platform
- React 18 concurrent mode compatibility: Zustand 5.x supports React 18 natively.
- No SSR concerns (this is a client-only SPA).

### Dependencies
- Zustand has zero dependencies besides React.
- No breaking changes to the service layer.

## Risk Assessment

### Technical Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Selector equality: `useEmployeeOnboarding` creates a new object reference on every store update, causing unnecessary re-renders | Medium | High | Use Zustand's `useShallow` or memoize the selector output |
| Subscription lifecycle: ref-counting logic has edge case bugs (double cleanup, stale closures) | Medium | Medium | Follow the proven pattern from `subscriptionManager.ts`; thorough unit tests |
| `useManagerData` breaks because `useOnboardingInstances` behavior subtly changes | Medium | Low | The return type is identical; `useManagerData` only reads `data`, `isLoading`, `error` |
| Test mocking: Zustand store is harder to mock than a simple hook | Low | Medium | Mock the store module or provide a test store factory; follow Zustand testing docs |
| Employee instance derivation: `find()` on the full array vs. dedicated subscription may return a different instance if multiple exist for the same email | Medium | Low | Sort by `createdAt` descending, take first -- matches the existing `subscribeToEmployeeInstance` logic (ORDER BY created_at DESC LIMIT 1) |

### Complexity
- **Level:** Medium
- **Rationale:** The core store setup is straightforward. The complexity is in (a) reference-counted subscription lifecycle, (b) ensuring selector equality to prevent re-render storms, (c) preserving exact hook API contracts, and (d) updating all affected tests without breaking the 350-test baseline.

## Open Questions

- [x] Q1: Should we use Zustand 4.x or 5.x?
  - Resolution: Use latest stable (5.x). It has better TypeScript support and is the maintained version.

- [x] Q2: Should `subscribeToEmployeeInstance` be preserved or can we derive from the all-instances list?
  - Resolution: Derive from the all-instances list. The all-instances subscription already fetches all instances with steps. The per-email subscription is redundant once we have a single store. Derivation logic: `instances.filter(i => i.employeeEmail === email).sort((a, b) => b.createdAt - a.createdAt)[0] ?? null`.

- [x] Q3: Should we use `zustand/middleware` (devtools, persist, etc.)?
  - Resolution: Use devtools middleware only (for Redux DevTools debugging). No persist -- this is real-time data from Supabase. Devtools is conditionally enabled in development only.

- [x] Q4: Where should the store file live?
  - Resolution: `src/store/useOnboardingStore.ts` with barrel export at `src/store/index.ts`. This follows the project pattern of feature-named files in dedicated directories.

- [x] Q5: How to handle the `enabled` parameter in `useOnboardingInstances`?
  - Resolution: When `enabled=false`, the hook returns empty data and doesn't start a subscription. When `enabled=true`, it calls `_startSubscription()` in a `useEffect` and cleans up on unmount. The subscription is reference-counted, so multiple `enabled=true` consumers share one subscription.

## Recommended Approach

### Implementation Strategy

**Create the store first, then migrate hooks one at a time, preserving API contracts.**

1. Install Zustand
2. Create `src/store/useOnboardingStore.ts` with:
   - `instances` state array
   - `isLoading` and `error` states
   - `_startSubscription` action with reference counting
   - The action calls `subscribeToOnboardingInstances` from the existing service layer
3. Create `src/store/index.ts` barrel export
4. Rewrite `useOnboardingInstances` to be a thin wrapper over the store
5. Rewrite `useEmployeeOnboarding` to derive from the store
6. Verify `useManagerData` still works (it should, since it calls `useOnboardingInstances` internally)
7. Update tests: add store tests, update hook test mocks
8. Run full test suite to verify no regressions

### Order of Work

1. **Install Zustand** (`npm install zustand`)
2. **Create store** (`src/store/useOnboardingStore.ts` + `src/store/index.ts`)
3. **Write store tests** (`src/store/useOnboardingStore.test.ts`)
4. **Migrate `useOnboardingInstances`** -- rewrite hook, update its test if needed
5. **Migrate `useEmployeeOnboarding`** -- rewrite hook, verify no test changes needed
6. **Verify `useManagerData`** -- should work unchanged
7. **Update `NewHiresPanel.test.tsx`** mock if needed (it mocks `useOnboardingInstances` from `../../hooks`)
8. **Run full test suite** -- all 350+ tests must pass
9. **Manual verification** of bug fixes (realtime-status-sync, employee-dropdown-sync)

### What to Defer

- **Devtools middleware** -- nice to have but not essential for this slice. Can be added in a follow-up.
- **`useSteps` migration** -- that is slice 2 (`zustand-steps`)
- **`useSuggestions` / `useActivities` migration** -- that is slice 4 (`zustand-activities`)
- **OnboardingHub god component slimming** -- incremental, happens across slices
- **Optimistic update actions in the store** -- `useSteps` has optimistic updates but is not migrated in this slice

## Next Step

**All questions resolved.**
Run `/plan zustand-store` to create the implementation plan.
