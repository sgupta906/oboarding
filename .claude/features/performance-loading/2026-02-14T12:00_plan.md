# Plan: performance-loading

## Metadata
- **Feature:** performance-loading
- **Created:** 2026-02-14T12:00
- **Status:** plan-complete
- **Based On:** `.claude/features/performance-loading/2026-02-14T12:00_research.md`

---

## Architecture Overview

### Problem Summary

The app is unusably slow because every Realtime event triggers a full table re-fetch (`SELECT *`), subscriptions are duplicated across 6+ components, there is no pagination on any list query, and there is no shared state or caching between components.

### Solution: Three-Layer Performance Fix

```
Layer 1: Debounced Subscriptions
  - Wrap every subscribe callback in a 300ms debounce
  - Rapid Realtime events batch into a single re-fetch

Layer 2: Shared Subscription Manager (singleton per table)
  - Reference-counted subscriptions: first consumer opens, last consumer closes
  - All consumers of the same table share one Supabase channel + one data cache
  - Eliminates 6x duplicate subscribeToRoles problem

Layer 3: Query Limits + Direct Queries
  - Add .limit() to all unbounded listXxx() functions
  - Fix subscribeToSteps to query instance_steps directly
  - Activities capped at 50 most recent
```

### Data Flow: Before vs. After

**BEFORE (current):**
```
                                     +--> subscribeToRoles() --> channel A --> listRoles()
RoleManagementPanel --> useRoles() --+
                                     +--> initial listRoles()

                                     +--> subscribeToRoles() --> channel B --> listRoles()
CreateUserModal -----> useRoles() ---+
                                     +--> initial listRoles()

                                     +--> subscribeToRoles() --> channel C --> listRoles()
EditUserModal -------> useRoles() ---+
                                     +--> initial listRoles()

  ... (3 more duplicate channels for CreateTemplate, EditTemplate, CreateOnboarding)

  Result: 6 channels, 6 initial fetches, 6x re-fetch on every change
```

**AFTER (planned):**
```
                                     +-- RoleManagementPanel (useRoles)
                                     |
subscriptionManager["roles"] --------+-- CreateUserModal (roles prop from parent)
  |                                  |
  +--> 1 channel                     +-- EditUserModal (roles prop from parent)
  +--> 1 initial fetch               |
  +--> debounced(300ms) re-fetch     +-- CreateTemplateModal (roles prop from parent)
  +--> ref count = 1                 |
                                     +-- EditTemplateModal (roles prop from parent)
                                     |
                                     +-- CreateOnboardingModal (roles prop from parent)

  Result: 1 channel, 1 initial fetch, 1 debounced re-fetch on change
  Modals receive roles as props -- zero additional subscriptions
```

### Component Architecture

```
App.tsx
  |
  +-- OnboardingHub.tsx
  |     |
  |     +-- useEmployeeOnboarding(email) ---- subscribeToEmployeeInstance [1 channel]
  |     +-- useSteps(instanceId) ------------ subscribeToSteps [1 channel, direct query]
  |     +-- useManagerData({ ... })
  |     |     +-- useActivities(enabled) ---- subscribeToActivities [1 channel, limit 50]
  |     |     +-- useSuggestions(enabled) --- subscribeToSuggestions [1 channel]
  |     |     +-- useOnboardingInstances(en)- subscribeToOnboardingInstances [1 channel]
  |     |
  |     +-- ManagerView (receives onboardingInstances, suggestions, activities as props)
  |     |     +-- RoleManagementPanel
  |     |     |     +-- useRoles() -------- subscriptionManager["roles"] [shared, 1 channel]
  |     |     |     +-- CreateRoleModal
  |     |     |     +-- EditRoleModal
  |     |     |
  |     |     +-- UsersPanel
  |     |     |     +-- useUsers() -------- subscribeToUsers [1 channel]
  |     |     |     +-- CreateUserModal  <-- receives roles as prop (from parent or lifted)
  |     |     |     +-- EditUserModal    <-- receives roles as prop
  |     |     |
  |     |     +-- CreateOnboardingModal <--- receives roles + templates as props
  |     |
  |     +-- TemplatesView
  |           +-- useTemplates() ----------- subscriptionManager["templates"] [shared, 1 channel]
  |           +-- CreateTemplateModal <----- receives roles as prop
  |           +-- EditTemplateModal <------- receives roles as prop
  |
  Total channels: 7 (was up to 12+)
  Total initial fetches: 7 (was up to 12+)
  On any single change: 1 debounced re-fetch (was 6+)
```

---

## Tech Stack Summary

No new dependencies. All changes use existing:
- React 18 (useState, useEffect, useCallback, useRef)
- TypeScript strict mode
- Supabase @supabase/supabase-js client (existing Proxy pattern)
- Vitest + React Testing Library (existing test setup)

---

## File Structure

### New Files

| File | Purpose |
|------|---------|
| `src/utils/debounce.ts` | Generic debounce utility function (leading/trailing) |
| `src/utils/debounce.test.ts` | Unit tests for debounce utility |
| `src/services/supabase/subscriptionManager.ts` | Shared singleton subscription manager with ref counting + debounce |
| `src/services/supabase/subscriptionManager.test.ts` | Unit tests for subscription manager |

### Modified Files

| File | Changes |
|------|---------|
| **Service Layer (debounce + limits)** | |
| `src/services/supabase/roleService.ts` (lines 196-218) | Wrap `subscribeToRoles` to use debounced re-fetch callback |
| `src/services/supabase/templateService.ts` (lines 253-282) | Wrap `subscribeToTemplates` with debounce |
| `src/services/supabase/userService.ts` (lines 426-461) | Wrap `subscribeToUsers` with debounce |
| `src/services/supabase/activityService.ts` (lines 17-28, 65-87) | Add `.limit(50)` to `listActivities`, wrap subscription with debounce |
| `src/services/supabase/suggestionService.ts` (lines 94-116) | Wrap `subscribeToSuggestions` with debounce |
| `src/services/supabase/instanceService.ts` (lines 452-497, 502-530) | Fix `subscribeToSteps` to query `instance_steps` directly; debounce all subscribe functions |
| `src/services/supabase/profileService.ts` (lines 184-213) | Wrap `subscribeToProfiles` with debounce |
| `src/services/supabase/profileTemplateService.ts` (lines 229-264) | Wrap `subscribeToProfileTemplates` with debounce |
| `src/services/supabase/index.ts` | No changes needed (subscribe exports unchanged) |
| **List query limits** | |
| `src/services/supabase/roleService.ts` (line 28-29) | Add `.limit(200)` safety cap to `listRoles()` |
| `src/services/supabase/templateService.ts` (line 20-21) | Add `.limit(200)` safety cap to `listTemplates()` |
| `src/services/supabase/userService.ts` (line 157-158) | Add `.limit(200)` safety cap to `listUsers()` |
| `src/services/supabase/suggestionService.ts` (line 17-18) | Add `.limit(200)` safety cap to `listSuggestions()` |
| `src/services/supabase/instanceService.ts` (line 50-51) | Add `.limit(200)` safety cap to `listOnboardingInstances()` |
| `src/services/supabase/profileService.ts` (line 18-19) | Add `.limit(200)` safety cap to `listProfiles()` |
| `src/services/supabase/profileTemplateService.ts` (line 18-19) | Add `.limit(200)` safety cap to `listProfileTemplates()` |
| **Modal components (accept roles/templates as props)** | |
| `src/components/modals/CreateOnboardingModal.tsx` (lines 9, 11-16, 49-50) | Add `roles` + `templates` props; remove `useRoles()` and `useTemplates()` hook calls |
| `src/components/modals/CreateUserModal.tsx` (lines 8, 11-17, 39) | Add `roles` prop; remove `useRoles()` hook call |
| `src/components/modals/EditUserModal.tsx` (lines 8, 11-18, 42) | Add `roles` prop; remove `useRoles()` hook call |
| `src/components/templates/CreateTemplateModal.tsx` (lines 9, 12-18, 43) | Add `roles` prop; remove `useRoles()` hook call |
| `src/components/templates/EditTemplateModal.tsx` (lines 11, 14-22, 52) | Add `roles` prop; remove `useRoles()` hook call |
| **Parent components (pass roles/templates down)** | |
| `src/components/manager/UsersPanel.tsx` (lines 22-25) | Add `useRoles()` call; pass `roles` to CreateUserModal and EditUserModal |
| `src/views/ManagerView.tsx` (lines 60-62) | Add `useRoles()` + `useTemplates()` calls; pass to CreateOnboardingModal |
| `src/views/TemplatesView.tsx` (lines 20-21) | Add `useRoles()` call; pass `roles` to CreateTemplateModal and EditTemplateModal |
| **Test files** | |
| `src/components/modals/CreateOnboardingModal.test.tsx` | Update to pass roles/templates as props |
| `src/components/modals/CreateUserModal.test.tsx` | Update to pass roles as prop |
| `src/components/templates/CreateTemplateModal.test.tsx` | Update to pass roles as prop |
| `src/components/templates/EditTemplateModal.test.tsx` | Update to pass roles as prop |
| `src/components/manager/UsersPanel.test.tsx` | Update to mock useRoles in UsersPanel |
| `src/components/manager/RoleManagementPanel.test.tsx` | No changes needed (already uses useRoles) |
| `src/views/ManagerView.test.tsx` | Update to mock useRoles/useTemplates |
| `src/views/TemplatesView.test.tsx` | Update to mock useRoles |

---

## Data Model Changes

None. No database schema changes or migrations. All optimizations are client-side.

---

## Debounce Utility Design

```typescript
// src/utils/debounce.ts
export function debounce<T extends (...args: any[]) => void>(
  fn: T,
  delayMs: number
): T & { cancel: () => void } {
  let timeoutId: ReturnType<typeof setTimeout> | null = null;

  const debounced = (...args: Parameters<T>) => {
    if (timeoutId !== null) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      timeoutId = null;
      fn(...args);
    }, delayMs);
  };

  debounced.cancel = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };

  return debounced as T & { cancel: () => void };
}
```

Key design decisions:
- **Trailing-edge only** (fire after quiet period) -- this is what we want for batching rapid Realtime events
- **300ms delay** -- short enough to feel responsive, long enough to batch burst events
- **Cancel method** -- needed for cleanup when subscriptions are torn down
- **No dependencies** -- pure TypeScript utility, no React

---

## Subscription Manager Design

```typescript
// src/services/supabase/subscriptionManager.ts

interface ManagedSubscription<T> {
  refCount: number;
  callbacks: Set<(data: T) => void>;
  unsubscribe: (() => void) | null;
  lastData: T | null;
}

// Module-level map: one entry per subscription key
const subscriptions = new Map<string, ManagedSubscription<any>>();

export function createSharedSubscription<T>(
  key: string,
  subscribeFn: (callback: (data: T) => void) => () => void
): {
  subscribe: (callback: (data: T) => void) => () => void;
} {
  return {
    subscribe(callback: (data: T) => void) {
      let entry = subscriptions.get(key);

      if (!entry) {
        // First consumer: create the underlying subscription
        entry = {
          refCount: 0,
          callbacks: new Set(),
          unsubscribe: null,
          lastData: null,
        };
        subscriptions.set(key, entry);

        // Start the real subscription, broadcasting to all callbacks
        entry.unsubscribe = subscribeFn((data: T) => {
          entry!.lastData = data;
          entry!.callbacks.forEach(cb => cb(data));
        });
      }

      entry.refCount++;
      entry.callbacks.add(callback);

      // If we already have data, immediately deliver it to the new consumer
      if (entry.lastData !== null) {
        callback(entry.lastData);
      }

      // Return cleanup function
      return () => {
        const e = subscriptions.get(key);
        if (!e) return;

        e.callbacks.delete(callback);
        e.refCount--;

        if (e.refCount <= 0) {
          // Last consumer: tear down the real subscription
          if (e.unsubscribe) e.unsubscribe();
          subscriptions.delete(key);
        }
      };
    },
  };
}
```

Key design decisions:
- **Module-level singleton** -- no React Context needed, works at the service layer
- **Reference counting** -- first `subscribe()` creates the channel, last cleanup closes it
- **Immediate delivery of cached data** -- new consumers get `lastData` immediately, no loading flash
- **Key-based** -- each subscription type has a unique string key (e.g., `"roles"`, `"templates"`)
- **Preserves existing function signature** -- `subscribeToRoles(callback)` return type stays `() => void`

---

## Integration Strategy for Debounce in Subscribe Functions

Rather than rewriting all 8 subscribe functions, we apply debounce at the re-fetch callback level:

```typescript
// Example: roleService.ts subscribeToRoles (AFTER)
import { debounce } from '../../utils/debounce';

export function subscribeToRoles(
  callback: (roles: CustomRole[]) => void
): () => void {
  // Debounced version of the re-fetch-and-callback pattern
  const debouncedRefetch = debounce(() => {
    listRoles().then(callback).catch(console.error);
  }, 300);

  // 1. Initial fetch (NOT debounced -- we want immediate data)
  listRoles().then(callback).catch(console.error);

  // 2. Listen for changes with debounced handler
  const channel = supabase
    .channel('roles-all')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'roles' },
      () => { debouncedRefetch(); }
    )
    .subscribe();

  // 3. Return cleanup
  return () => {
    debouncedRefetch.cancel();
    supabase.removeChannel(channel);
  };
}
```

This pattern is applied identically to all 8 subscribe functions. The initial fetch stays immediate; only Realtime event callbacks are debounced.

---

## Modal Prop-Passing Strategy

### Before (each modal fetches independently)
```
UsersPanel
  +-- CreateUserModal  --> useRoles() --> subscribeToRoles() [own channel]
  +-- EditUserModal    --> useRoles() --> subscribeToRoles() [own channel]
```

### After (parent provides data via props)
```
UsersPanel
  +-- useRoles() --> subscribeToRoles() [shared channel]
  +-- CreateUserModal  <-- roles={roles} (prop)
  +-- EditUserModal    <-- roles={roles} (prop)
```

For each modal:
1. Add `roles?: CustomRole[]` and/or `templates?: Template[]` to props interface
2. Remove `useRoles()` / `useTemplates()` hook call
3. Use `roles` from props (with `rolesLoading` derived from `!roles || roles.length === 0`)
4. Parent component calls `useRoles()` once and passes down

This is a **backward-compatible** change because:
- The existing hook return types are preserved in the parent
- Modal interfaces gain optional props (no breaking changes for tests that render modals with mocks)
- Components that already mock `useRoles` in tests just need the mock moved to the parent or the prop added

---

## subscribeToSteps Direct Query Fix

**Before:**
```typescript
const fetchSteps = async () => {
  const instance = await getOnboardingInstance(instanceId); // fetches full instance + ALL steps
  return instance ? instance.steps : [];
};
```

**After:**
```typescript
const fetchSteps = async () => {
  const { data, error } = await supabase
    .from('instance_steps')
    .select('*')
    .eq('instance_id', instanceId)
    .order('position', { ascending: true });

  if (error) {
    console.error(`Failed to fetch steps: ${error.message}`);
    return [];
  }

  return (data ?? []).map(toStep);
};
```

This eliminates the unnecessary JOIN with `onboarding_instances` and maps `instance_steps` rows directly.

A `toStep` mapper is needed in `mappers.ts` (or inline in instanceService) to convert `InstanceStepRow` to `Step`.

---

## Testing Strategy

### Unit Tests (new)
| Test File | Count | Description |
|-----------|-------|-------------|
| `src/utils/debounce.test.ts` | ~8 tests | Debounce timing, cancel, multiple calls, edge cases |
| `src/services/supabase/subscriptionManager.test.ts` | ~10 tests | Ref counting, shared data, cleanup, multiple keys, immediate cache delivery |

### Unit Tests (modified)
| Test File | Changes |
|-----------|---------|
| `src/components/modals/CreateOnboardingModal.test.tsx` | Pass roles/templates as props instead of mocking useRoles/useTemplates |
| `src/components/modals/CreateUserModal.test.tsx` | Pass roles as prop instead of mocking useRoles |
| `src/components/templates/CreateTemplateModal.test.tsx` | Pass roles as prop instead of mocking useRoles |
| `src/components/templates/EditTemplateModal.test.tsx` | Pass roles as prop instead of mocking useRoles |
| `src/components/manager/UsersPanel.test.tsx` | Add useRoles mock since UsersPanel now calls it |
| `src/views/ManagerView.test.tsx` | Add useRoles/useTemplates mocks since ManagerView now calls them |
| `src/views/TemplatesView.test.tsx` | Add useRoles mock since TemplatesView now calls it |

### Existing Tests (must still pass)
- All 655 existing tests must pass unchanged (except the test files listed above that need prop/mock updates)
- The service-layer changes (debounce, limits) are internal and should not break any tests because tests mock `subscribeToXxx` functions
- Hook tests (useActivities.test.ts, etc.) mock the subscribe functions -- debounce is internal to the real implementation

### Integration Testing
- Verify via Playwright MCP that the Manager View loads in under 2 seconds
- Verify that creating a role does not trigger 6+ re-fetches
- Verify that modals still show role dropdowns correctly

---

## Implementation Notes

### Decisions Made
1. **No React Context for shared subscriptions** -- The subscription manager lives at the service module level, not in React. This avoids wrapping the app in another Provider and keeps the solution simple.
2. **Debounce at the service layer, not the hook layer** -- Debouncing in the subscribe function means ALL consumers benefit, even future ones. The hooks don't need to know about debouncing.
3. **Shared subscription manager is opt-in** -- We start by applying debounce to all subscribe functions (immediate win), then selectively add shared subscription for roles and templates (the most-duplicated ones). Other subscriptions (activities, suggestions, instances) are typically only used in one place and don't need sharing.
4. **Activities hard-capped at 50** -- This is the only unbounded table. Other tables (roles, templates, users) are naturally small. We add `.limit(200)` as a safety net to all list functions, but activities gets `.limit(50)`.
5. **Backward-compatible modal props** -- Modals accept `roles` as an optional prop. When provided, they use it. When not provided (edge case), they could fall back to showing empty. In practice, the parent always provides it.

### Patterns Used
- **Debounce** -- trailing-edge timer to batch rapid events
- **Singleton subscription** -- module-level Map with reference counting
- **Prop drilling** -- simple React pattern to pass data from parent to child instead of each child fetching independently
- **Direct queries** -- query the specific table needed instead of fetching parent+children

### Trade-offs
- **Prop drilling vs. Context** -- We chose prop drilling because the data flow is only 1-2 levels deep. Context would be overkill and harder to test.
- **Debounce delay (300ms)** -- This means Realtime updates appear 300ms after the event instead of immediately. With optimistic updates already in place, the user sees the change instantly; the debounced re-fetch just reconciles in the background.
- **Safety limit of 200 rows** -- This is generous enough for current use but will need pagination for large deployments. Deferred to a future feature.

---

## Non-Goals (explicitly NOT doing)

1. **No TanStack Query / React Query** -- Adding a dependency is out of scope
2. **No server-side pagination** -- Not needed at current data scale
3. **No selective column fetching** -- Minor optimization, not worth the complexity
4. **No Web Workers for Realtime** -- Overkill for this app
5. **No incremental cache updates from Realtime payloads** -- The payload-based incremental update approach (parse INSERT/UPDATE/DELETE payloads and patch local state) is fragile with JOINed data. Debounced full re-fetch is simpler and more reliable.
6. **No database-side optimizations** -- No stored procedures, materialized views, or new indexes
7. **No "load more" button for activities** -- Hard cap at 50 is sufficient for now

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Shared subscription delivers stale data | `lastData` cache is updated on every re-fetch; Realtime events trigger re-fetch within 300ms |
| Debounce causes visible UI lag | Optimistic updates in useRoles/useTemplates show changes instantly; debounced re-fetch is background reconciliation |
| Modal prop changes break tests | Update test files to pass roles as props; mock moved from modal to parent test |
| Ref counting leak | Unit tests verify cleanup behavior; subscriptions.delete() on refCount <= 0 |
| New `toStep` mapper has bugs | Add unit test for the mapper; reuse existing InstanceStepRow type |
