# Research: performance-loading

## Metadata
- **Feature:** performance-loading
- **Created:** 2026-02-14T12:00
- **Status:** research-complete
- **Researcher:** research-agent

## Feature Context
- **Description:** The entire app is reported as unusable due to slow loading. Dashboard, users, roles, templates, and employee views all take far too long to appear.
- **Where it fits:** This is a cross-cutting performance issue that affects every data-loading path in the application. Must be fixed before adding new features.
- **Dependencies on other features:** Builds on top of the completed `webapp-rework` and `bug-fixing` features. No blockers.

---

## Requirements

### Functional Requirements
- FR1: All views (Dashboard, Templates, Roles, Users, Employee) load data and become interactive within a reasonable timeframe (target: < 2 seconds for initial load on a warm connection)
- FR2: Loading states are visible to the user (spinners/skeletons)
- FR3: Realtime subscriptions do not degrade initial load performance
- FR4: Navigating between views does not re-fetch data that is already loaded
- FR5: Modals that need roles/templates data do not create duplicate Supabase subscriptions

### Technical Requirements
- TR1: Eliminate duplicate Realtime channel subscriptions (previously up to 7+ `subscribeToRoles` channels open simultaneously)
- TR2: Eliminate full-table re-fetch on every Realtime change event
- TR3: Add pagination or limits to unbounded list queries (listActivities, listOnboardingInstances, listUsers, etc.)
- TR4: Parallelize independent initial data fetches instead of waterfall loading
- TR5: Prevent Realtime "refetch storms" when a single user action triggers changes across multiple tables
- TR6: Ensure all existing tests continue to pass after changes

### Constraints
- Must use existing Supabase client (no new backend infra)
- Must not change database schema (no new migrations for this feature)
- Must maintain Realtime functionality (can optimize, but not remove)
- TypeScript strict mode must pass (`npx tsc -b`)

---

## Root Cause Analysis

### CRITICAL FINDING 1: Every Realtime subscription does a full table re-fetch on EVERY change

This is the **primary systemic issue**. Every `subscribe*` function in the service layer follows this exact pattern:

```typescript
export function subscribeToXxx(callback): () => void {
  // 1. Initial fetch -- OK
  listXxx().then(callback).catch(console.error);

  // 2. On EVERY change event, re-fetch ALL rows
  const channel = supabase
    .channel('xxx-all')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'xxx' },
      () => {
        listXxx().then(callback).catch(console.error);  // <-- FULL TABLE SCAN
      }
    )
    .subscribe();

  return () => { supabase.removeChannel(channel); };
}
```

**Impact:** When a user creates a role, the Realtime event fires and `listRoles()` is called. But because `subscribeToUsers` also listens on `user_roles` table, and `subscribeToTemplates` listens on `template_steps`, a single action can cascade into 3-5 full table re-fetches across different services simultaneously. Each re-fetch is a full `SELECT * FROM xxx` with JOINs.

**Affected services (all 8 subscribe functions):**
- `subscribeToRoles` -> `listRoles()` on every change
- `subscribeToTemplates` -> `listTemplates()` on every change to `templates` OR `template_steps`
- `subscribeToUsers` -> `listUsers()` on every change to `users` OR `user_roles` OR `user_profiles`
- `subscribeToActivities` -> `listActivities()` on every change
- `subscribeToSuggestions` -> `listSuggestions()` on every change
- `subscribeToOnboardingInstances` -> `listOnboardingInstances()` on every change to `onboarding_instances` OR `instance_steps`
- `subscribeToSteps` -> `getOnboardingInstance(id)` on every change
- `subscribeToEmployeeInstance` -> custom query on every change to `onboarding_instances` OR `instance_steps`
- `subscribeToProfiles` -> `listProfiles()` on every change to `profiles` OR `profile_role_tags`
- `subscribeToProfileTemplates` -> `listProfileTemplates(profileId)` on every change

Files:
- `/workspaces/onboarding/src/services/supabase/roleService.ts` (lines 196-218)
- `/workspaces/onboarding/src/services/supabase/templateService.ts` (lines 253-282)
- `/workspaces/onboarding/src/services/supabase/userService.ts` (lines 426-461)
- `/workspaces/onboarding/src/services/supabase/activityService.ts` (lines 65-87)
- `/workspaces/onboarding/src/services/supabase/suggestionService.ts` (lines 94-116)
- `/workspaces/onboarding/src/services/supabase/instanceService.ts` (lines 502-590)
- `/workspaces/onboarding/src/services/supabase/profileService.ts` (lines 184-213)
- `/workspaces/onboarding/src/services/supabase/profileTemplateService.ts` (lines 229-264)

### CRITICAL FINDING 2: Massive duplicate subscriptions from modal components

`useRoles()` is called independently in **6 different components**, each creating its own Supabase Realtime channel and initial fetch:

1. `RoleManagementPanel.tsx` -> `useRoles(user?.uid)` (line 38)
2. `CreateTemplateModal.tsx` -> `useRoles()` (line 43)
3. `EditTemplateModal.tsx` -> `useRoles()` (line 52)
4. `CreateUserModal.tsx` -> `useRoles()` (line 39)
5. `EditUserModal.tsx` -> `useRoles()` (line 42)
6. `CreateOnboardingModal.tsx` -> `useRoles()` (line 50)

Similarly, `useTemplates()` is called in:
1. `TemplatesView.tsx` -> `useTemplates()` (line 21)
2. `CreateOnboardingModal.tsx` -> `useTemplates()` (line 49)

**Impact:** When a manager opens the Manager View and the modals are rendered (even if hidden), up to **6 simultaneous `subscribeToRoles` calls** fire, each creating:
- An initial `listRoles()` fetch (6 concurrent `SELECT * FROM roles`)
- A Realtime channel subscription (6 channels on the same table)
- On any role change: 6 more `listRoles()` fetches simultaneously

This means a single role creation could trigger **6+ concurrent database queries** just for roles, plus cascading queries from other subscriptions.

### CRITICAL FINDING 3: No pagination on any list query

All `listXxx()` functions fetch **every row** from the database with no pagination, no limits, and no cursor:

- `listRoles()`: `SELECT * FROM roles` -- unbounded
- `listTemplates()`: `SELECT *, template_steps(*) FROM templates` -- unbounded with JOIN
- `listUsers()`: `SELECT *, user_roles(*), user_profiles(*) FROM users` -- unbounded with 2 JOINs
- `listActivities()`: `SELECT * FROM activities ORDER BY timestamp DESC` -- unbounded, will grow forever
- `listSuggestions()`: `SELECT * FROM suggestions` -- unbounded
- `listOnboardingInstances()`: `SELECT *, instance_steps(*) FROM onboarding_instances` -- unbounded with JOIN

**Impact:** As the database grows, every query gets progressively slower. Activities table in particular will grow unboundedly (every user action logs an activity). With Realtime re-fetches on every change, these unlimited queries multiply.

### CRITICAL FINDING 4: Waterfall data loading in OnboardingHub

In `OnboardingHub.tsx` (lines 46-64), data loading is sequential:

```typescript
// 1. First: fetch employee instance (waits for this)
const { instance: employeeInstance } = useEmployeeOnboarding(employeeEmail);

// 2. Then: fetch steps for that instance (depends on instance.id)
const { data: employeeStepsData } = useSteps(employeeInstance?.id ?? '');

// 3. Independently: fetch manager data (but runs in parallel with #1)
const { ... } = useManagerData({ ... });
```

The employee flow has a **waterfall**: must wait for instance to load, then fetch steps. This is 2 sequential network round trips before anything renders.

Additionally, `useSteps` is called twice (line 50 and 76) -- once for the employee's own steps and once for the selected instance steps.

### CRITICAL FINDING 5: No caching layer

There is no caching of any kind:
- No in-memory cache for fetched data
- No stale-while-revalidate pattern
- No shared state between components (each hook maintains its own state)
- Navigating from Manager View to Templates View and back triggers completely fresh data fetches

### CRITICAL FINDING 6: Realtime channels listening on wildcard events

All subscriptions use `event: '*'` which fires on INSERT, UPDATE, and DELETE. For tables like `activities` where the app only ever inserts new rows, listening for UPDATE and DELETE is wasteful and generates unnecessary change events.

### CRITICAL FINDING 7: subscribeToSteps fetches the entire instance to get steps

In `instanceService.ts` (lines 452-497), `subscribeToSteps` does:
```typescript
const fetchSteps = async () => {
  const instance = await getOnboardingInstance(instanceId); // fetches full instance + ALL steps
  return instance ? instance.steps : [];
};
```

This fetches the entire `onboarding_instances` row plus all `instance_steps` just to get the steps. It should query `instance_steps` directly.

### FINDING 8: No debouncing on Realtime change handlers

When multiple changes happen rapidly (e.g., bulk operations, or Realtime events arriving in quick succession), each event triggers an independent full re-fetch. There is no debouncing to batch rapid changes into a single re-fetch.

---

## Existing Code Analysis

### Project State
- Project exists: YES
- Relevant existing files: All files listed in Root Cause Analysis above

### Code to Reuse
- Hook patterns (useState, useEffect, useCallback) are well-structured -- the optimization is in the services and subscription layer
- Optimistic updates in `useRoles.ts` and `useTemplates.ts` are good -- these should be preserved
- The `enabled` parameter pattern in `useActivities`, `useSuggestions`, `useOnboardingInstances` is good -- prevents unnecessary subscriptions

### Code to Modify

| File | Change |
|------|--------|
| `src/services/supabase/roleService.ts` | Replace full re-fetch with incremental update or debounced re-fetch |
| `src/services/supabase/templateService.ts` | Same pattern fix + direct step query |
| `src/services/supabase/userService.ts` | Same pattern fix |
| `src/services/supabase/activityService.ts` | Add limit + same pattern fix |
| `src/services/supabase/suggestionService.ts` | Same pattern fix |
| `src/services/supabase/instanceService.ts` | Fix steps query, same pattern fix |
| `src/services/supabase/profileService.ts` | Same pattern fix |
| `src/services/supabase/profileTemplateService.ts` | Same pattern fix |
| `src/hooks/useRoles.ts` | Convert to shared/singleton subscription or accept roles as prop |
| `src/hooks/useTemplates.ts` | Convert to shared/singleton subscription |
| `src/hooks/useManagerData.ts` | May need adjustment for new patterns |
| `src/components/modals/CreateOnboardingModal.tsx` | Remove direct useRoles/useTemplates; accept as props |
| `src/components/modals/CreateUserModal.tsx` | Remove direct useRoles; accept as props |
| `src/components/modals/EditUserModal.tsx` | Remove direct useRoles; accept as props |
| `src/components/templates/CreateTemplateModal.tsx` | Remove direct useRoles; accept as props |
| `src/components/templates/EditTemplateModal.tsx` | Remove direct useRoles; accept as props |
| `src/components/manager/RoleManagementPanel.tsx` | Already calls useRoles; becomes the single source |

### Patterns to Follow
- Preserve the existing `subscribeToXxx` function signature (returns cleanup function)
- Preserve existing hook return types (avoid breaking component contracts)
- Preserve optimistic updates
- Maintain the `enabled` parameter pattern for conditional subscriptions

---

## Constraints

### Performance
- Target: Initial view load under 2 seconds on warm connection
- Target: Realtime updates reflected within 500ms
- Activities query must have a limit (e.g., 50 most recent) -- table will grow unboundedly

### Platform
- Supabase free tier: limited to 500 concurrent Realtime connections (duplicate subscriptions eat into this)
- Supabase Realtime: postgres_changes events are broadcast to all subscribers -- can't filter server-side by specific row changes efficiently
- Supabase PostgREST: each `.select()` call is an HTTP request to the PostgREST API

### Dependencies
- @supabase/supabase-js client library
- React 18 (no React Query / TanStack Query in the project)
- No state management library (no Redux, no Zustand)

---

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Shared subscription pattern introduces stale data bugs | High | Medium | Use Realtime events to invalidate cache; keep re-fetch as fallback |
| Removing duplicate subscriptions breaks modal rendering | Medium | Low | Pass data as props instead; test all modal flows |
| Debouncing delays cause UI to feel unresponsive | Medium | Low | Use short debounce window (200-300ms); show optimistic updates instantly |
| Limiting activities breaks manager dashboard expectations | Low | Low | Show "Load more" button; default to 50 recent |
| Refactoring subscribe functions breaks 655 tests | High | Medium | Tests mock the supabase service layer, so internal changes should not affect most tests; validate with full test suite |

### Complexity
- **Level:** Medium
- **Rationale:** The changes are systemic (touch all 8 services and 10+ hooks/components) but follow a consistent pattern. Each service needs the same type of fix. The main risk is in the subscription deduplication strategy.

---

## Open Questions

- [x] Q1: Should we introduce a state management library (e.g., Zustand, TanStack Query)?
  - Resolution: NO. Adding a new dependency would be a larger scope change. Instead, use a lightweight singleton subscription pattern within the existing service layer. A shared cache module is simpler and sufficient.

- [x] Q2: Should we remove Realtime entirely and switch to polling?
  - Resolution: NO. Realtime is a feature of the app. The fix is to make Realtime efficient (debounce, deduplicate, incremental), not remove it.

- [x] Q3: Should activities have a hard limit or a "load more" pattern?
  - Resolution: Hard limit of 50 most recent for the initial load. The activities table will grow forever; unbounded queries are not sustainable. A "load more" button can be added in a future feature if needed.

- [x] Q4: How to deduplicate useRoles subscriptions across 6 components?
  - Resolution: Two-pronged approach: (1) Create a shared subscription module that maintains a single active subscription per table, with a reference count. Multiple `useRoles()` calls share the same underlying channel. (2) For modals, pass roles data as props from the parent that already has it.

---

## Recommended Approach

### Implementation Strategy

**Phase 1: Add debouncing to all subscribe functions (highest impact, lowest risk)**
- Add a debounce wrapper to every `subscribeToXxx` function so rapid Realtime events are batched into a single re-fetch
- This alone should dramatically reduce the "refetch storm" problem
- Estimated reduction: 5-10x fewer queries during active use

**Phase 2: Shared/singleton subscription layer**
- Create a `subscriptionManager` module that maintains a single active subscription per table
- Multiple consumers (hooks, components) share the same subscription via a reference-counted pattern
- When last consumer unsubscribes, the channel is closed
- This eliminates the 6x duplicate `subscribeToRoles` problem

**Phase 3: Add limits to unbounded queries**
- Add `.limit(50)` to `listActivities()` (with `.order('timestamp', { ascending: false })`)
- Add `.limit(100)` to other list functions as a safety net (current data is small, but will grow)
- Preserve existing sort orders

**Phase 4: Eliminate modal subscription duplication**
- Refactor modals (CreateTemplateModal, EditTemplateModal, CreateUserModal, EditUserModal, CreateOnboardingModal) to accept `roles` and/or `templates` as props instead of calling `useRoles()`/`useTemplates()` internally
- This removes 5 duplicate `useRoles()` subscriptions and 1 duplicate `useTemplates()` subscription

**Phase 5: Optimize specific queries**
- `subscribeToSteps`: Query `instance_steps` directly instead of fetching the full instance
- Consider making Realtime event handlers smarter -- use the payload from the change event to do incremental updates (add/remove/modify a single item) instead of full re-fetch, falling back to full re-fetch on error

### Order of Work
1. Create `subscriptionManager.ts` utility with debounce + singleton pattern
2. Refactor all 8 service `subscribeToXxx` functions to use the manager
3. Add query limits to all `listXxx()` functions
4. Refactor modals to accept roles/templates as props
5. Optimize `subscribeToSteps` to query steps directly
6. Run full test suite and fix any breakage
7. Manual verification via Playwright MCP

### What to Defer
- Adding TanStack Query or Zustand (too much scope)
- Server-side pagination with cursor (not needed yet at current data scale)
- Selective column fetching (`select('id, name')` instead of `select('*')`) -- minor optimization
- Moving Realtime to a Web Worker (overkill for this app)
- Database-side optimizations (stored procedures, materialized views)

---

## Quantitative Impact Estimate

### Current State (Manager View loads)
Subscriptions opened on Manager View mount:
1. `subscribeToSuggestions` -> 1 channel, 1 initial fetch
2. `subscribeToActivities` -> 1 channel, 1 initial fetch
3. `subscribeToOnboardingInstances` -> 1 channel, 1 initial fetch
4. `subscribeToRoles` (from RoleManagementPanel) -> 1 channel, 1 initial fetch
5. `subscribeToUsers` (from UsersPanel) -> 1 channel, 1 initial fetch
6. `subscribeToRoles` (from CreateOnboardingModal) -> 1 channel, 1 initial fetch **DUPLICATE**
7. `subscribeToTemplates` (from CreateOnboardingModal) -> 1 channel, 1 initial fetch **DUPLICATE**
8. `subscribeToRoles` (from CreateUserModal) -> 1 channel, 1 initial fetch **DUPLICATE**
9. `subscribeToRoles` (from EditUserModal) -> 1 channel, 1 initial fetch **DUPLICATE**
10. `subscribeToTemplates` (from TemplatesView, if rendered) -> 1 channel, 1 initial fetch **DUPLICATE**
11. `subscribeToRoles` (from CreateTemplateModal) -> 1 channel, 1 initial fetch **DUPLICATE**
12. `subscribeToRoles` (from EditTemplateModal) -> 1 channel, 1 initial fetch **DUPLICATE**

**Total: Up to 12 channels opened, 12 initial fetches fired simultaneously**
(Actual count depends on how many modals are rendered -- even if hidden, React renders them)

When a single role is created:
- `roles` table change -> all 6 role subscriptions fire -> 6x `listRoles()`
- `user_roles` table change (if user affected) -> `subscribeToUsers` fires -> `listUsers()` with 2 JOINs
- Activity logged -> `activities` table change -> `subscribeToActivities` fires -> `listActivities()` (full table)

**Total for one role creation: potentially 8+ full table queries**

### After Fix
- 1 shared role subscription (1 channel, 1 initial fetch)
- 1 shared templates subscription (1 channel, 1 initial fetch)
- Debounced: rapid changes batch into 1 re-fetch per 200ms window
- Limited: activities capped at 50 rows

**Total for one role creation: 1-2 debounced queries**

---

## Next Step

**All questions resolved. Status: research-complete.**

Run `/plan performance-loading` to create the implementation plan.
